<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>函数式编程范式初探-第一天</title>
      <link href="/2019/10/20/learn-FP/"/>
      <url>/2019/10/20/learn-FP/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在翻阅一些技术论坛的时候, 常常能看到有人提及函数式编程(FunctionalProgramming), 说他可以简化我们的代码, 提高我们的代码生产力以及降低出错的几率.</p><p>作为一个希望提高开发效率的半吊子程序员来说, 我觉得这应该是一个非常有利的’武器’, 值得去学习, 吸收其中的一些精华思想, 如果能看到可以开花结果的那一天, 那就再好不过了.</p><p>本文为自我学习总结文章, 正确性不保证, 我更推荐您阅读<code>&lt;&lt;函数式编程思维&gt;&gt;[美]Neal Ford著</code>这种不错的书籍</p><p>本文主要使用js和java来说明, 因为这两个是我目前工作的常用语言, 对我自己的好处最大. 如果你想享受更好的函数式编程体验, 可以试试<code>Clojure</code>或者<code>Scala</code></p><h2 id="是什么为什么"><a href="#是什么为什么" class="headerlink" title="是什么为什么"></a>是什么为什么</h2><p>我这人对一个技术的起源不是非常感兴趣, 所以我不想多费时间减少函数式编程的历史, 我想直接从函数式编程最常用的技术点讲起, 来让我快速的了解它</p><h3 id="以函数为抽象单元"><a href="#以函数为抽象单元" class="headerlink" title="以函数为抽象单元"></a>以函数为抽象单元</h3><p>我们在面向对象编程中, 一般都会认为一个类Object是一个抽象单元, 比如在Java中(一门完全以面向对象为基础的编程语言), 我们都要从编写类开始.</p><p>而函数式编程的第一个特点就是, 它把函数视为抽象单元, 我们可以传递函数, 以函数作为参数, 大家看看下面的例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input = [<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listForEach</span>(<span class="params">list,operate</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> list) &#123;</span><br><span class="line">        operate(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consoleKey</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//do something.</span></span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listForEach(input, consoleKey);</span><br></pre></td></tr></table></figure><p>这里我用Js实现了一段代码, 这段代码会依次打印数组中的值. 这里的最大特点就是consoleKey是个函数, 并且我们将其作为listForEach的参数传入了. 所以对于listForEach而言, for循环内部具体执行什么逻辑, 是可以由具体传入了什么函数决定的. 这里函数就是一个抽象的单元, 可以根据我们的需要进行任意的替换.</p><p>我写完这个例子后产生了一些疑问, 因为在我看来, 这就是简单的一个抽象化调用而已, 在我还没学习函数式编程语言之前, 我也经常会写这样的代码, 并且我当时觉得这样的写法也并没有简化多少. 这个问题, 我也自己在不断的考虑, 最后我觉得这是一种比较主观的问题, 不同人对于代码复杂度有不同的判断, 有些人觉得几百行的crud代码一点也不复杂, 因为分解一下, 代码内容其实就只有crud罢了; 而可能有些人则会觉得, 这些代码就像屎山一样, 难以下手.</p><p>还记得我最早接触编程的时候, 学的是c, 所以当时写的都是命令式的代码. 那么如果按照命令式的写法, 我上面的例子会怎么写呢? 如下是我的按照命令式的写法改写的例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input = [<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> list) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯? 怎么感觉命令式的写法更加的简单? 在这里确实是这样的没错. 但是没够多久, 项目经理要求先判断下元素是否为空, 这时候对于函数式编程来说, 写法是新增一个函数抽象, 然后替换我们传入的函数, 就像下面这样:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...原函数省略</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consoleKeyNotNull</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//检查是否为null</span></span><br><span class="line">    <span class="keyword">if</span>(key)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listForEach(input, consoleKeyNotNull);</span><br></pre></td></tr></table></figure><p>我们需要改的是新增一个consoleKeyNotNull函数, 以及修改传入的函数即可. 这样的写法符合软件开发的开闭原则, 我们没有去修改原来的函数代码.</p><p>相同的修改放到命令式语法上就有点棘手了, 因为你需要修改源代码, 并且如果项目经理突然变卦让你把控制去掉, 你又得自己改回去, 这种需求如果不断的堆积, 对代码的维护会造成不小的压力.</p><p>此外,由于是函数, 所以一般来说都会给函数一个命名, 所以我们在查阅这些代码的时候, 如果函数命名特别贴切的话, 会一下子提高阅读源码的速度, 我觉得这也是函数式的一个小特点</p><p>此外,我们可能还需要了解下一种说法, 那就是这种使用函数的函数, 我们一般就叫做<code>高阶函数</code>, 一个更加高大上的说法:) </p><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>函数式编程的另一个特点是, 要求函数针对同一个输入有一个相同的输出, 这个概念就和我们小时候学的方程式很类似, 比如方程<code>x + y</code>, 对于给定的输入x和y, 我们可以得出固定的答案. 函数式编程也极大的推崇这个特点. 因为这个特点可以提高我们这个函数的复用性</p><p>试想一下, 如果一个函数是纯函数, 那么任何需要用到它的地方, 都可以放心大胆的使用它, 并且有时候我们可以不对其进行单元测试, 这样对于测试来说, 相当于减少了不稳定要素, 而不稳定要素的减少, 肯定会减少代码bug的出现. 因为很多时候bug都是因为不稳定要素的过多, 导致程序员无法一口气把所有的情况都考虑到而产生的.</p><p>对于纯函数, 我能想到的例子还是很多的, 比如<code>sin(x)</code>,<code>abs(x)</code>,<code>sqrt(x)</code>, 这些函数对于我们的指定的输入, 总是会返回同一个结果. </p><p>不过个人认为完全纯函数是不可能实现的, 因为在实际的开发过程中, 我们面对的是更为复杂的业务场景, 不稳定要素非常多, 比如超时问题,网络问题等等, 所以我觉得函数式编程作为一个编程范式, 它的作用仍然没有面向对象那么重要. 但是在针对一些算法, 一些小的场景下, 使用函数式编程范式, 确实是可以提高一定的生产力</p><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>在函数式编程中, lambda表达式是我们的常见的家伙. 由于函数式编程就是一直在写函数, 所以对于一些不需要函数名的场景, lambda表达式可以发挥出简化代码, 提高可读性的作用</p><p>lambda表达式的语法也许不同语言不一致, 但是几乎都如出一辙, 下面我用java语言来演示一些:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统写法</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Anonymous"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用lambda表达式</span></span><br><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">      () -&gt; System.out.println(<span class="string">"lambda"</span>)</span><br><span class="line">    ).start();</span><br></pre></td></tr></table></figure><p>可以看到, lambda表达式的作用其实就是省略到了很多不必要的语法, 只剩下我们真正关心的东西, 比如<code>()</code>代表这个方法没有形参, <code>-&gt;</code>是lambda表达式的核心语法符号, 有表示产出的含义. 最后的<code>System.out.println(&quot;lambda&quot;)</code> 就是方法体, 由于单行, 所以这里省略了花括号</p><p>怎么样? 是不是非常简洁? 不过这只是lambda表达式的初探, 我后续会对其进行详细的说明, 本文主要阐述FP的核心概念, 并不会对具体语法做过多说明</p><p>lambda表达式为函数的编写提供了一种更易读的方式, 支持函数式编程的语言, 都有提供lambda表达式功能, 它是函数式编程之所以简洁的其中一个原因!</p><h3 id="Stream-amp-amp-将控制权交给语言-运行时"><a href="#Stream-amp-amp-将控制权交给语言-运行时" class="headerlink" title="Stream &amp;&amp; 将控制权交给语言/运行时"></a>Stream &amp;&amp; 将控制权交给语言/运行时</h3><p>最能体会到函数式编程乐趣的方式, 其实就是使用Stream.</p><p>Stream内置了大量的函数操作, 使得我们可以借助这些函数来完成各种操作, 最有名的三大函数就是map/filter/reduce</p><p>我会在后续进行Stream的总结(不过是只针对java的), 我们可以从Stream的这些函数操作中, 深刻的体会到函数式编程的魅力! 我给一个简单的Stream的例子吧:</p><p>比如我们需要随机展示 5 至 20 之间不重复的整数并进行排序, 那么传统的方式可能是下面这样的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImperativeRandoms</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">        SortedSet&lt;Integer&gt; rints = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(rints.size() &lt; <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = rand.nextint(<span class="number">20</span>);</span><br><span class="line">            <span class="keyword">if</span>(r &lt; <span class="number">5</span>) <span class="keyword">continue</span>;</span><br><span class="line">            rints.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(rints);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而函数式编程&amp;流后,代码可以变得异常的简单:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Randoms</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Random(<span class="number">47</span>)</span><br><span class="line">            .ints(<span class="number">5</span>, <span class="number">20</span>)</span><br><span class="line">            .distinct()</span><br><span class="line">            .limit(<span class="number">7</span>)</span><br><span class="line">            .sorted()</span><br><span class="line">            .forEach(n -&gt; System.out.println(n););</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么样? 这里我们借助了StreamAPI中的各种函数为我们达到了我们要做的目的, 整体代码看上去犹如读一句话一样流畅, 先ints获取数据源, 然后distinct一下排除重复, 然后我们坐下limit限制, 然后再sorted以下让其有序, 最后forEach一下, forEach的内容就是对每个元素进行打印!</p><p>总而言之, 函数式编程的实现会看上去非常的有可读性, 而传统的写法则需要对java语法有一定基础, 才有能力去编写出能用的代码. 不得不说其实这种声明式的写法很大程度上又是对开发人员技术要求的降低, 但是不代表我们不需要去了解其内部的原理. 在这里所有的操作都被移交给了运行时, 不需要我们亲自编写for循环,编写控制代码. </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对函数式编程进行一个基础性的表述, 下一章我会使用java语言, 详细的说明java的函数式编程支持语法, </p>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FunctionalProgramming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年国庆</title>
      <link href="/2019/10/02/2019-Happy-National-Day/"/>
      <url>/2019/10/02/2019-Happy-National-Day/</url>
      
        <content type="html"><![CDATA[<h2 id="感觉一团糟的杭州站"><a href="#感觉一团糟的杭州站" class="headerlink" title="感觉一团糟的杭州站 :)"></a>感觉一团糟的杭州站 :)</h2><p>又一年国庆, 今年从杭州回家, 来杭州找工作+入职已经快一个月多了, 也差不多适应了杭州的生活. </p><p>今天回家, 由于没有抢到高铁票, 只买到了普快火车, 由于我一直没有用抢票软件的习惯, 所以买完后也一直没有改签, 就这么上了.</p><p>做了快一小时的地铁后终于来到了杭州站, 也就是杭州火车站. </p><p>我放眼望去的总体感觉是, 房子老旧, 应该是用了很久的房子了. 然后我想找入口, 往四周望了几眼, 我很吃惊, 居然没有明显的路标指引, 要知道我当时的位置属于地铁出站口的那种区域, 属于中间地段, 里面充斥了各种实体商店, 五花八门.</p><p>我在里面兜了一个圈子才发现, 原来进站口在二楼.</p><p>来到二楼, 二楼的结构还算可以接受, 我很快就顺利的找到了进站口. </p><p>就当我以为后面的流程就是扫下身份证(自从可以身份证出入后就很少取票了), 就可以进站的时候, 排了好久的队突然告诉我普快必须取票才能进入. ??? 我当时瞬间黑人问号浮现在脸上..</p><p>没办法, 那就先去取票吧! 应该很快</p><p>好吧, 结果我发现是我错了, 我出来后又开始蒙蔽了, 取票在哪里呢? 一般来说取票机都不会离进站口太远. 所以我就在四周逛了一圈, 然后没找到任何取票机.</p><p>最后我跟随者一个比较大流的方向走过去, 转了2个弯, 穿过一条小型商业街, 终于看到了取票口!!!!</p><p>还好我提前了几十分钟到杭州站, 不然估计可能要换乘了!</p><h2 id="周边的同学陆陆续续都传出结婚的消息"><a href="#周边的同学陆陆续续都传出结婚的消息" class="headerlink" title="周边的同学陆陆续续都传出结婚的消息"></a>周边的同学陆陆续续都传出结婚的消息</h2><p>毕业两年了, 大家都长大了, 不得不做的事情接踵而至, 比如结婚. </p><p>还好我的父母思想比较宽松, 并没有严格要求我尽快结婚, 但是我感觉明年这个时候应该就差不多要结婚了.</p><p>说实话, 我觉得结婚压力还是蛮大的, 因为我感觉结婚就意味着要支付一笔额外的巨额费用用于结婚, 看着我自己的积蓄马上就要大出血, 我就感觉有点难受, 一时半会吃不消. 看来接下来的一年要多干点副业, 多赚点钱了… 最近一直在考虑写点工具站, 专门为一部分人使用, 然后看看能不能骗到广告费, 如果真的成功的话, 也是不小的财富(有打折的或者便宜的云机子一定要告诉我啊!)</p><p>今年在好好干一年, 看看变化, 准备准备准备, 从找个对象开始吧</p><h2 id="今年的国庆氛围比以往都热烈呢"><a href="#今年的国庆氛围比以往都热烈呢" class="headerlink" title="今年的国庆氛围比以往都热烈呢"></a>今年的国庆氛围比以往都热烈呢</h2><p>不知道是我的错觉还是咋滴, 觉得今年国庆的气氛特别热烈, 各大媒体, 微博, 朋友圈, b站, 知乎等都能看到一篇热爱祖国的新闻. 祖国近几年的发展确实可以说是蓬勃发展, 从我身边的变化来看的话. </p><p>但是也觉得存在着很多隐患, 我个人觉得最大的问题还是网络诈骗吧. 最近遇到太多人被网上的骗子骗钱, 而且数额惊人, 被骗几w的都有, 但是真正破案的却看到的不多, 有些小额被骗的, 警察多半不会立案, 只剩下被害者的哀嚎.</p><p>在举国同庆的同时, 我们也要反思这些背后的隐患, 各种社会问题的出现, 都是社会稳定发展的蛀虫, 越早解决越好.</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 国庆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面对涉及金额计算的需求,我该如何应对(二)</title>
      <link href="/2019/09/27/java-amount-calculation-2/"/>
      <url>/2019/09/27/java-amount-calculation-2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一章 <a href="https://zazalu.space/2019/09/25/java-amount-calculation/">面对涉及金额计算的需求,我该如何应对(一)? </a></p><p>我主要讲了Java层面如何做到高精度的计算</p><p>本章我们继续探讨数据库(mysql为例)中如何正确保存我们的金额</p><p>其实我们的目的很简单, 一是存储到数据库中的数据必须是能保证精度的数据类型, 而在mysql中能够保证精度的有<code>DECIMAL</code>或者<code>NUMBER</code>, 两者是一致的没有区别, 都是用字符串存储. 或者使用<code>INT</code>,<code>BIGINT</code>等, 这两个虽然是二进制存储, 但是因为不含小数, 所以不会出现精度问题, 缺点是还需要额外维护<code>scale</code>, 如果是国内, 直接除以100的做法也是常见; 二是保证可扩展性以及保证空间不要浪费, 这个其实是非常灵活的一种需求, 需要我们对自己项目所用到的情况有非常深的理解, 最后才能确定使用多少空间去存储.</p><p>事前声明: 本文只是阐述我个人的想法, 是本人通过各类网上查阅别人的解决方案后总结的成果, 并不是我自己的亲身使用经验, 所以请阅读者带有自己的思考, 多问为什么.</p><h2 id="第一种方式-使用DECIMAL存储金额"><a href="#第一种方式-使用DECIMAL存储金额" class="headerlink" title="第一种方式 - 使用DECIMAL存储金额"></a>第一种方式 - 使用DECIMAL存储金额</h2><p>网上讨论什么数据类型去存储金额做了非常多的讨论, 但是绝大部分的答案都会指向使用<code>DECIMAL</code>, 这是个非常有力的答案, 因为Mysql官方都建议我们使用<code>DECIMAL</code>来存储需要精度计算的数字数据. Mysql官方的原文如下:</p><blockquote><p>The DECIMAL and NUMERIC types store exact numeric data values. These types are used when it is important to preserve exact precision, for example with monetary data.</p></blockquote><p>原文地址: <a href="https://dev.mysql.com/doc/refman/5.7/en/fixed-point-types.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/fixed-point-types.html</a></p><p>使用DECIMAL存储金额是一种比较通用的形式, 因为很多成熟的数据库, 都使用这个关键字来作为高精度计算数据类型的名称, 它的存在本身就是为了提供准确的精度计算服务. 由于底层由字符串存储, 和<code>float</code>,<code>double</code>这种近似值数据类型有本质上的区别, 因为浮点数类型底层由二进制存储, 它无法正确显示0.1, 只能存储其近似值, 这个知识点我们在第一章也明确的进行了说明.</p><h3 id="如何使用DECIMAL"><a href="#如何使用DECIMAL" class="headerlink" title="如何使用DECIMAL?"></a>如何使用DECIMAL?</h3><p>就算我们懂得了<code>DECIMAL</code>来存储金额这件事, 我们还需要面对第二个问题, 那就是如何确定一个比较好的DECIMAL精度. </p><p><code>DECIMAL</code>有两个输入参数, 一个是精度precision, 还有一个是小数位数scale, 比如我们定义<code>decimal(19,2)</code>, 在mysql(后续内容全部已mysql为准)中它代表了19为的长度, 小数位只有2位的十进制数字. 需要注意的是这个19代表总长度,它包含了小数点.</p><p>一般来说precision我们可以定义为19就可以完全满足大部分金额的需求, 比如<code>decimal(19,2)</code>, 那么它支持的最大数额是9999999999999999.99, 这个数额差不多是9999千亿元, 注意我的单位是千亿. 如果还不够你可以加大大小 , 不过需要注意decimal最大长度是65(出自mysql官网,The maximum number of digits for DECIMAL is 65)</p><p>scale的长度定义是更加要注意的事情, 目前来看很多人喜欢定义2位小数! 但是我们作为程序员要身怀全球化开发的大志, 稍微了解下其他国家的币种, 你会发现2位是不够的, 为了减少后期需求变动导致2位不足的情况, 其实可以使用4位小数, 比如Bahraini, Jordanian, or Kuwaiti Dinars都是在使用常常有3位小数的币种的国家.</p><h3 id="Mybatis中获取写法"><a href="#Mybatis中获取写法" class="headerlink" title="Mybatis中获取写法"></a>Mybatis中获取写法</h3><p>说完了精度和小数位数的设定, 最后我们还要了解下从mysql数据库读取到java, 这个过程该如何处理, 由于国内Java常见的orm框架是mybatis, 我在这里就不聊jpa或者hibernate或者其他orm框架了, 这里只说明mybatis如何正确读取. </p><p>在mybatis中, 读取decimal类型数据有一种万能的写法, 就是<code>jdbcType=NUMERIC</code>. 如果你觉得这样看不出数据类型具体是啥, 那么你可以这样写<code>jdbcType=DECIMAL</code>, 然后java类型使用<code>java.math.BigDecimal</code>接收即可!</p><p>##　第二种方式 - 使用INT或者BIGINT存储无标度值的金额</p><p>另一种常见的方式是使用2个字段分别存储金额(类似BIgDecimal的底层原理), 一个字段使用<code>INT</code>或者<code>BIGINT</code>存储无标度值的金额, 比如18.134, 保存为18134, 这里提出<code>BIGINT</code>代替<code>INT</code>是因为可能部分场景<code>INT</code>不够你用, 而<code>BIGINT</code>基本不用担心(可以看看<a href="https://segmentfault.com/a/1190000005124246" target="_blank" rel="noopener">这篇文章</a>对这些数据类型重新回顾下).然后使用另一个字段,比如scale保存为3, 这样我们从数据库取出来后,就可以知道是18.134了. 这些操作在精度上是不存在问题的, 所以也是一种可行方案.</p><p>比较值得一提的是,如果只是针对RMB, 你甚至可以不需要保存scale, 默认在程序中做除以100的操作就行了, 也就是针对到分即可.</p><p>到此为止, 网上最流行的方案就是这两种形式, 接下来我们来探讨下到底哪种更好</p><h2 id="INT-vs-DECIMAL"><a href="#INT-vs-DECIMAL" class="headerlink" title="INT vs DECIMAL"></a>INT vs DECIMAL</h2><p>现在我们开始讨论这两种方式到底哪种更优秀</p><p>从空间上来说, INT是胜利的, 因为DECIMAL所需的空间很大</p><p>从性能上来说, 这是一个没法很好定夺的问题, 因为我一直坚持要比对性能, 必须结合实际情况做对应的基准测试, 才能得到自己的结论, 所以这里我就卖个关子, 不回答性能问题.</p><p>从开发复杂度来说, 我认为是DECIMAL简单, 因为直接封装到BigDecimal类中可以直接使用, 而INT还需要做除法操作来移动小数点位置.</p><h2 id="在JS层面如何展示"><a href="#在JS层面如何展示" class="headerlink" title="在JS层面如何展示"></a>在JS层面如何展示</h2><p>最后再来说说JS吧, 在页面上我坚持是只传String过去即可, 这样对于前端工程师来说, 他们不用担心显示出现精度问题, 因为是String的格式. 此外JS做精度计算最好移动到后台处理, 是在巴不得以, 可以使用别人的计算库比如math.js做处理, 减少我们自己编写出现精度问题的几率!</p><p>由于我个人偏后端, 所以前端展示这块不是很熟悉, 就不多扯了.</p><p>本系列到此结束</p><div id="donationPoint"><div id="licensePoint"></div></div>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java高精度计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面对涉及金额计算的需求,我该如何应对(一)?</title>
      <link href="/2019/09/25/java-amount-calculation/"/>
      <url>/2019/09/25/java-amount-calculation/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要讨论作为JavaWeb应用程序员, 当接手涉及金额计算需求的时候, 如何确保金额计算, 金额保存, 金额显示不失真! </p><p>如果你是其他语言的应用程序员, 本文内容可能不会立马对你有用, 但是相关知识的涉及在语言间的作用一般是想通的, 你也可以拿来作为参考</p><p>接下来我们开始正题</p><h2 id="先聊聊Java层面出现的精度问题是什么"><a href="#先聊聊Java层面出现的精度问题是什么" class="headerlink" title="先聊聊Java层面出现的精度问题是什么"></a>先聊聊Java层面出现的精度问题是什么</h2><p>对于刚上手Java的新人来说, 涉及数字的计算, 最容易想到的是int和double(由于float的取值范围小于double, 在不是对内存要求非常苛刻的条件下, 我们一般都是用double的), 如果整数就用int, 如果带有小数就用double.</p><p>但是很快的, 你会发现double的计算结果往往不符合真正的数学计算结果, 比如执行以下代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">0.1</span> + <span class="number">0.2</span>);</span><br></pre></td></tr></table></figure></p><p>这个结果是0.30000000000000004, 而不是0.3</p><p>这是怎么回事呢? </p><h3 id="double类型计算陷阱"><a href="#double类型计算陷阱" class="headerlink" title="double类型计算陷阱"></a>double类型计算陷阱</h3><p>如果想要理解这种现象, 我们首先要明确一个大前提, 就是计算机是如何存储<code>0.1</code>,<code>0.2</code>这些值的</p><p>对计算机原理有一定了解的话, 你一定不难理解其实这些数在计算机上真正是用二进制的形式来存储的, 不仅是这些float和double这些浮点数, int值其实也是. </p><p>这时候你可能又会冒出一个问题, 为什么同样都是二进制存储, int值的计算从来不会存在精度问题, 而float和double缺会存在.</p><p>这就要涉及到他们转换为二进制的过程中是否有截断的问题了.</p><p>float和double转换为二进制表示有一个非常致命的问题就是: </p><blockquote><p>就像十进制无法用有限位表示1/3一样, 二进制也无法用有限的位数来表示部分浮点数, 比如0.1</p></blockquote><p>下面将0.1和0.2转为2进制表示。</p><p>0.1<br>0.10 <em> 2 = 0.20 未进位 0<br>0.20 </em> 2 = 0.40 未进位 0<br>0.40 <em> 2 = 0.80 未进位 0<br>0.80 </em> 2 = 1.60 进位 1<br>0.60 <em> 2 = 1.20 进位 1<br>0.20 </em> 2 = 0.40 未进位 0<br>0.40 <em> 2 = 0.80 未进位 0<br>0.80 </em> 2 = 1.60 进位 1<br>0.60 <em> 2 = 1.20 进位 1<br>0.20 </em> 2 = 0.40 未进位 0<br>0.40 <em> 2 = 0.80 未进位 0<br>0.80 </em> 2 = 1.60 进位 1<br>0.60 <em> 2 = 1.20 进位 1<br>0.20 </em> 2 = 0.40 未进位 0<br>0.40 <em> 2 = 0.80 未进位 0<br>0.80 </em> 2 = 1.60 进位 1<br>0.60 <em> 2 = 1.20 进位 1<br>0.20 </em> 2 = 0.40 未进位 0<br>无限循环…<br>二进制表示0.1:<br>0.00011001100110011001100110011001100110011001100110011001…<br>科学记数表示：<br>1.1001100110011001100110011001100110011001100110011001… * 2^-4</p><p>可以看到二进制表示0.1 实际上是一个无限循环的二进制数, 既然是无线循环, 这就代表了无法用有限的空间去存储到计算机的存储容器上, 所以计算机必须对其进行截断, 最终导致在计算机上存储0.1的二进制数只存储了其中的23位(float)或者52位(double).</p><p>我想看到这里的你也许已经明白了float和double的计算失去精度的原理了, 不过为了延伸阅读, 我认为我们也应该对一个标准有一定的概念(你应该对我上面说的23位和52位提出疑问,为什么是23位,为什么是52位,而这些都与IEEE754二进制浮点数标准有关)</p><h3 id="IEEE754标准"><a href="#IEEE754标准" class="headerlink" title="IEEE754标准"></a>IEEE754标准</h3><p>绝大多数的编程语言都遵循了IEEE754标准进行浮点数的运算,</p><p>简单来说, 该标准定义了一个浮点数的表示方式为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">值 = 符号位 + 指数位偏移 + 尾数位</span><br></pre></td></tr></table></figure><p>而我们上文中提到的一长串二进制数据,就是存储在尾数位上的(当然会做一些必要的转换,不是原封不动的), 因为该标准规定了尾数位的长度, float是23位, double是52位, 所以超过的部分都会被四舍五入进行抹除, 从而导致了精度问题的发生.</p><h3 id="关于浮点数运算精度问题其他想说的"><a href="#关于浮点数运算精度问题其他想说的" class="headerlink" title="关于浮点数运算精度问题其他想说的"></a>关于浮点数运算精度问题其他想说的</h3><p>想必一般智商的人看我上面的总结, 已经可以非常容易理解精度问题发生的根源, 但是我还是想声明的是, 实际上这块领域还是需要有一定的数学基础, 数学不好的人可能会看的头晕, 并且网上针对这一块有很深入研究的论文存在, 我在阅读它们的时候由于数学知识匮乏,所以更深层次的东西没法进行总结,也不敢乱说.如果您有兴趣,则请自己通过搜索引擎进行更深入的探讨. 不过这也不代表我上面的描述是非真实的说法, 我上面的说法可以说是最通俗的说法来让我们理解为啥会出现精度问题</p><h2 id="Java层面使用BigInteger和BigDecimal来完成高精度计算"><a href="#Java层面使用BigInteger和BigDecimal来完成高精度计算" class="headerlink" title="Java层面使用BigInteger和BigDecimal来完成高精度计算"></a>Java层面使用BigInteger和BigDecimal来完成高精度计算</h2><p>在Java社区中, 我们已经达成了共识, 如果希望自己所做的运算不会损失精度, 可以使用BigInteger或者BigDecimal类来做运算处理.</p><p>先提出质疑是, 必须需要使用这两个类来操作吗?</p><p>答案是: 不是必须的</p><p>只不过编写JDK的大神们已经呕心沥血帮我们完成了这两个完美的大数运算类, 我们岂有不用之理? 当然如果你的能力够厉害, 你也完全可以自己来实现高精度计算类</p><h3 id="从BigInteger说起"><a href="#从BigInteger说起" class="headerlink" title="从BigInteger说起"></a>从BigInteger说起</h3><p>由于BigDecimal底层有用到BigInteger, 在BigDecimal类实现第一行就出现如下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The unscaled value of this BigDecimal, as returned by &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #unscaledValue&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #unscaledValue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger intVal;</span><br></pre></td></tr></table></figure><p>所以我们如果想了解它们的秘密的话, 还是从BigInteger说起.</p><p>我尝试着自己阅读BigInteger源码, 但是太多的数学术语还是打败了我, 代码写的简直可以堪称神级, 所以本文对BigInteger的描述是结合java doc+网上的博文+自己看了部分源码后的总结, 我会努力保证其正确性, 从而让读者对BigInteger有个基本认识, 而不是懵里懵懂</p><h4 id="首先BigInteger是什么"><a href="#首先BigInteger是什么" class="headerlink" title="首先BigInteger是什么?"></a>首先BigInteger是什么?</h4><p>官方说明是的说明是它是<code>Immutable arbitrary-precision integers.</code></p><p>意思就是说它是可变任意精度整数. 可能这种说法有些平时学习不好的同学已经开始懵逼了. 那我就举个例子来说把.</p><p>在Java的世界中, 所有基本数据类型都有取值范围, 取值范围的多少取决于它们底层可用多少位去存储数据. 比如我们常用的byte是由8位二进制数据组成, int类型是由32位数据类型组成, 更直观点, 请看下面的说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.toBinaryString(<span class="number">1231231231</span>)); <span class="comment">// 1001001011000110001100011111111</span></span><br></pre></td></tr></table></figure><p>可以看到1231231231十进制数字就是1001001011000110001100011111111的二进制数字, 只不过这里是31位,因为还有一位是符号位没有显示出来</p><p>但是现实生活中我们可能要使用更大的数去做各种计算, 这时候, java的基本数据类型不够用了怎么办, 所以就有了BigInteger. 它可以表示任意长度的十进制整数, 不过由于太长的十进制整数是不科学且无意义的, 所以BigInteger内部使用了好几个常量去专门做了一些控制. 目前来看官方文档的说明里, BigInteger可表示的范围为:<code>-2的Integer.MAX_VALUE次方 (不可兼) 到 +2的Integer.MAX_VALUE次方 (不可兼)</code>, 不可兼的意思是不包括边界值的意思. Integer.MAX_VALUE的值是2的31次方-1, 可以想象这个范围已经是超级大的! 一般的计算器都已经无法显示这个数值呢. </p><h4 id="BigInteger是如何做到可以存储任意精度的整数的"><a href="#BigInteger是如何做到可以存储任意精度的整数的" class="headerlink" title="BigInteger是如何做到可以存储任意精度的整数的"></a>BigInteger是如何做到可以存储任意精度的整数的</h4><p>俗话说, 一个人干不了, 就两个人一起干. BigInteger的底层原理抽象来看其实也符合这句俗话的道理.</p><p>一个BigInteger代表的值是使用int[]来存储的, 源码中域定义如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mag是BigInteger的magnitude, 遵照Big-endian顺序. 每个数字都有对应的一种mag的表示, 同时数字0对应的mag是空数组</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span>[] mag;</span><br></pre></td></tr></table></figure></p><p>举个例子来说, 比如你有一个数字 <code>18927348347389543834934878</code> , 那么就会分成三部分分别存储至int[]数组里, 最终底层是这样存放的<br><code>18927348 | 347389543 | 834934878</code></p><p>从这个例子中, 我们可以观察到:</p><ol><li>每组最多存储长度是9, 为什么是9? 因为2的31次方-1的数值(2147483647)对应是一个长度为10的数字, 如果采用10长度的话, 会溢出int的最大取值范围; 并且在BIgInteger的add方法内,有直接做加法运算,两个9位的相加肯定不会溢出;</li><li>由于java中数组的最大长度也是2147483647(实际大小会根据dk版本有点不同,因为部分位会被挪用去存储数组的元信息),所以最大可存储的数字长度是9*2147483647, 这是个相当可怕的长度…..肯定够你用</li></ol><p>除此之外, BigInteger还有个小点就是, 它将符号位单独拿出来表示, 源码中域定义如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BigInteger的符号位, -1是代表负的,0代表0,1代表正的. 要注意的是 如果是数字0 则这个signum也必须是0 不能是1 </span></span><br><span class="line"><span class="comment"> * (这是为了确保每个BigInteger都有唯一的表示)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> signum;</span><br></pre></td></tr></table></figure></p><h4 id="BigInteger是怎么做运算的"><a href="#BigInteger是怎么做运算的" class="headerlink" title="BigInteger是怎么做运算的"></a>BigInteger是怎么做运算的</h4><p>这个我暂时就不予乱谈, 先贴个源码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] add(<span class="keyword">int</span>[] x, <span class="keyword">int</span>[] y) &#123;</span><br><span class="line">        <span class="comment">// If x is shorter, swap the two arrays</span></span><br><span class="line">        <span class="keyword">if</span> (x.length &lt; y.length) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] tmp = x;</span><br><span class="line">            x = y;</span><br><span class="line">            y = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> xIndex = x.length;</span><br><span class="line">        <span class="keyword">int</span> yIndex = y.length;</span><br><span class="line">        <span class="keyword">int</span> result[] = <span class="keyword">new</span> <span class="keyword">int</span>[xIndex];</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (yIndex == <span class="number">1</span>) &#123;</span><br><span class="line">            sum = (x[--xIndex] &amp; LONG_MASK) + (y[<span class="number">0</span>] &amp; LONG_MASK) ;</span><br><span class="line">            result[xIndex] = (<span class="keyword">int</span>)sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Add common parts of both numbers</span></span><br><span class="line">            <span class="keyword">while</span> (yIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sum = (x[--xIndex] &amp; LONG_MASK) +</span><br><span class="line">                      (y[--yIndex] &amp; LONG_MASK) + (sum &gt;&gt;&gt; <span class="number">32</span>);</span><br><span class="line">                result[xIndex] = (<span class="keyword">int</span>)sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Copy remainder of longer number while carry propagation is required</span></span><br><span class="line">        <span class="keyword">boolean</span> carry = (sum &gt;&gt;&gt; <span class="number">32</span> != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (xIndex &gt; <span class="number">0</span> &amp;&amp; carry)</span><br><span class="line">            carry = ((result[--xIndex] = x[xIndex] + <span class="number">1</span>) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Copy remainder of longer number</span></span><br><span class="line">        <span class="keyword">while</span> (xIndex &gt; <span class="number">0</span>)</span><br><span class="line">            result[--xIndex] = x[xIndex];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Grow result if necessary</span></span><br><span class="line">        <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">            <span class="keyword">int</span> bigger[] = <span class="keyword">new</span> <span class="keyword">int</span>[result.length + <span class="number">1</span>];</span><br><span class="line">            System.arraycopy(result, <span class="number">0</span>, bigger, <span class="number">1</span>, result.length);</span><br><span class="line">            bigger[<span class="number">0</span>] = <span class="number">0x01</span>;</span><br><span class="line">            <span class="keyword">return</span> bigger;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>我没有特别看明白(菜鸡如我~), 但是我感觉其实就是分组相加, 然后有进位则做进位处理, 如果我猜测的不对, 欢迎留言</p><h3 id="BigDecimal大显神威"><a href="#BigDecimal大显神威" class="headerlink" title="BigDecimal大显神威"></a>BigDecimal大显神威</h3><p>我们前面已经说明了一些BigInteger的知识, 现在我们已经有了相当的知识储备来学习BigDecimal的实现原理了.</p><h4 id="BigDecimal是什么"><a href="#BigDecimal是什么" class="headerlink" title="BigDecimal是什么"></a>BigDecimal是什么</h4><p>BigDecimal represents an immutable arbitrary-precision signed decimal number.<br>bigdecimal表示一个不可变的任意精度有符号十进制数。</p><p>从这句话中我们可以知道的最切题的信息就是它是支持任意精度! 所以说BigDecimal是不存在double那样,在底层存储的时候把超出的位数抹掉从而导致精度问题.</p><p>BigDecimal相比于BigInteger来说,最大的区别就是它支持带小数的十进制数</p><h4 id="那么BigDecimal是怎么做到任意精度-怎么做到支持带小数的"><a href="#那么BigDecimal是怎么做到任意精度-怎么做到支持带小数的" class="headerlink" title="那么BigDecimal是怎么做到任意精度,怎么做到支持带小数的?"></a>那么BigDecimal是怎么做到任意精度,怎么做到支持带小数的?</h4><p>BigDecimal由两部分来支持数据存储:</p><ol><li>Unscaled value – an arbitrary precision integer, 一个任意精度整数, 由BigInteger作支持</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用BigInteger存储任意精度整数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BigInteger intVal;</span><br></pre></td></tr></table></figure><ol start="2"><li>Scale – a 32-bit integer representing the number of digits to the right of the decimal point, 用一个int类型存储小数位数(scale)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * int类型来存储位数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> scale;</span><br></pre></td></tr></table></figure><p>我们举个例子, 比如数字3.14, 那么其intVal就是314, 其scale就是2, 可以从下面的代码示例中同样验证这个结论</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bd = <span class="keyword">new</span> BigDecimal(<span class="string">"3.14"</span>);<span class="comment">//利用String构造器构造,后面会再讲</span></span><br><span class="line">System.out.println(bd.unscaledValue());<span class="comment">//314</span></span><br><span class="line">System.out.println(bd.scale());<span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>所以BigDecimal利用了BigInteger来支持任意精度的表示, 同时使用一个scale域来保存小数位数, 两者结合, 就可以完美的保存一个任意精度的十进制数</p><h4 id="BigDecimal的常见陷阱"><a href="#BigDecimal的常见陷阱" class="headerlink" title="BigDecimal的常见陷阱"></a>BigDecimal的常见陷阱</h4><p>本文不是API文档, 所以我不会一一列举BigDecimal的常见方法, 不过BigDecimal在使用上有一部分坑是需要我们稍加留意的.</p><ol><li>首先是不使用<code>BigDecimal(double val)</code>构造器, 为什么?</li></ol><p>我们查阅这个构造器源码, 会发现其调用了<code>Double.doubleToLongBits()</code>, 看到这里我们其实已经可以得到答案了, 为了证明我说的没问题, 下面贴出构造器调用源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BigDecimal</span><span class="params">(<span class="keyword">double</span> val, MathContext mc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Double.isInfinite(val) || Double.isNaN(val))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"Infinite or NaN"</span>);</span><br><span class="line">    <span class="comment">// Translate the double into sign, exponent and significand, according</span></span><br><span class="line">    <span class="comment">// to the formulae in JLS, Section 20.10.22.</span></span><br><span class="line">    <span class="keyword">long</span> valBits = Double.doubleToLongBits(val);</span><br><span class="line">    <span class="keyword">int</span> sign = ((valBits &gt;&gt; <span class="number">63</span>) == <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> exponent = (<span class="keyword">int</span>) ((valBits &gt;&gt; <span class="number">52</span>) &amp; <span class="number">0x7ffL</span>);</span><br><span class="line">    <span class="keyword">long</span> significand = (exponent == <span class="number">0</span></span><br><span class="line">            ? (valBits &amp; ((<span class="number">1L</span> &lt;&lt; <span class="number">52</span>) - <span class="number">1</span>)) &lt;&lt; <span class="number">1</span></span><br><span class="line">            : (valBits &amp; ((<span class="number">1L</span> &lt;&lt; <span class="number">52</span>) - <span class="number">1</span>)) | (<span class="number">1L</span> &lt;&lt; <span class="number">52</span>));</span><br><span class="line">    exponent -= <span class="number">1075</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面过长省略</span></span><br></pre></td></tr></table></figure><p>从第6行可以看到, 此构造器明确使用了<code>Double.doubleToLongBits(val)</code>返回的<code>valBits</code>来生成BigDecimal,</p><p>我们来窥探下这个<code>valBits</code>的内容,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Double.doubleToLongBits(<span class="number">0.1</span>d));</span><br><span class="line"><span class="comment">//4591870180066957722</span></span><br><span class="line">System.out.println(Long.toBinaryString(Double.doubleToLongBits(<span class="number">0.1</span>d)))</span><br><span class="line"><span class="comment">//11111110111001100110011001100110011001100110011001100110011010</span></span><br></pre></td></tr></table></figure><p>我们从第二个打印结果中看出, 获取到的二进制数据是一个有限精度的数字, 而浮点数存储0.1的时候,是一种无限循环的表示情况,这在上文中我们也提及了. 所以我们已经可以断定, BigDecimal在这里会使用一个已经失去精度的数值来生成Bigdecimal,最终导致我们打印这个Bigdecimal的时候,获得的不是0.1,而是0.1000000000000000055511151231257827021181583404541015625这样的值, 从而又产生了精度问题!</p><p>所以这就是为什么不推荐使用<code>BigDecimal(double val)</code>构造器的原因,因为它依旧会产生精度问题.</p><p>一般的, 我们可以使用<code>BigDecimal.valueOf(double val)</code>或者<code>BigDecimal(String val)</code>来构造.</p><p><code>BigDecimal.valueOf(double val)</code>内部会先调用Double的toString方法, 所以不会产生精度问题</p><ol start="2"><li>其次是谨慎使用<code>compareTo</code>和<code>equals</code>方法</li></ol><p>如果你想比较两个Bigdecimal的值大小, 使用<code>compareTo</code>, 因为它会忽略scale, 所以1.00和1.0是相等的</p><p>如果你想完全比较两个Bigdecimal的是否相同, 使用<code>equals</code>, 比如1.00和1.0通过此方法比较是不等的</p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p>本章主要讲解了java层面上如何做好高精度计算, 下一章我们会继续讨论数据库层面上以及前端层面上如何正确的进行展示</p><div id="donationPoint"><div id="licensePoint"></div></div>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java高精度计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitalk初始化评论自动生成</title>
      <link href="/2019/09/24/gitalk-issue-automatic-create/"/>
      <url>/2019/09/24/gitalk-issue-automatic-create/</url>
      
        <content type="html"><![CDATA[<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>切换到Gitalk后，存在一个问题，就是issue需要我人工干预去创建，没法自动。 </p><p>所以这时候就需要借助Github API的力量，编写一个脚本自动创建文章对应的issue。</p><p>我想这种需求应该有人比我早需要，所以搜索了下，确实由人用nodejs写了一个脚本实现了，勉强能用，我也在上面稍微改动了下符合我自己的情况，下面贴个原文地址：<br><a href="https://daihaoxin.github.io/post/322747ae.html" target="_blank" rel="noopener">https://daihaoxin.github.io/post/322747ae.html</a></p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>不过原文遗漏了一个配置点， 就是要把站点_config.yml中url属性配置成自己域名，默认的<a href="http://yoursite.com" target="_blank" rel="noopener">http://yoursite.com</a></p><p>会导致生成的sitemap.xml中的都是这个域名开头的，导致生成的所有issue都是不匹配的。</p><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>还有一个问题是，label不能超过50个字符，所以要md5下</p><h1 id="4-最终代码"><a href="#4-最终代码" class="headerlink" title="4 最终代码"></a>4 最终代码</h1><p>comment.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">"request"</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span><br><span class="line"><span class="keyword">const</span> xmlParser = <span class="built_in">require</span>(<span class="string">"xml-parser"</span>);</span><br><span class="line"><span class="keyword">const</span> YAML = <span class="built_in">require</span>(<span class="string">"yamljs"</span>);</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">"cheerio"</span>);</span><br><span class="line"><span class="keyword">const</span> md5 = <span class="built_in">require</span>(<span class="string">"md5"</span>);</span><br><span class="line"><span class="comment">// 根据自己的情况进行配置</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    username: <span class="string">"zazaluMonster"</span>, <span class="comment">// GitHub 用户名</span></span><br><span class="line">    token: <span class="string">"d234d6a7234f3b547975f59c81adc879353189ac"</span>,  <span class="comment">// GitHub Token</span></span><br><span class="line">    repo: <span class="string">"zazaluMonster.github.io"</span>,  <span class="comment">// 存放 issues的git仓库</span></span><br><span class="line">    <span class="comment">// sitemap.xml的路径，commit.js放置在根目录下，无需修改，其他情况自行处理</span></span><br><span class="line">    sitemapUrl: path.resolve(__dirname, <span class="string">"./public/sitemap.xml"</span>),</span><br><span class="line">    kind: <span class="string">"Gitalk"</span>,  <span class="comment">// "Gitalk" or "Gitment"，</span></span><br><span class="line">    baseUrl: <span class="string">"https://zazalu.space/"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> issuesUrl = <span class="string">`https://api.github.com/repos/<span class="subst">$&#123;config.username&#125;</span>/<span class="subst">$&#123;config.repo&#125;</span>/issues?access_token=<span class="subst">$&#123;config.token&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> requestGetOpt = &#123;</span><br><span class="line">    url: <span class="string">`<span class="subst">$&#123;issuesUrl&#125;</span>&amp;page=1&amp;per_page=1000`</span>,</span><br><span class="line">    json: <span class="literal">true</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">"User-Agent"</span>: <span class="string">"github-user"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> requestPostOpt = &#123;</span><br><span class="line">    ...requestGetOpt,</span><br><span class="line">    url:issuesUrl,</span><br><span class="line">    method: <span class="string">"POST"</span>,</span><br><span class="line">    form: <span class="string">""</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"开始初始化评论..."</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"开始检索链接，请稍等..."</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> websiteConfig = YAML.parse(fs.readFileSync(path.resolve(__dirname, <span class="string">"./_config.yml"</span>), <span class="string">"utf8"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> urls = sitemapXmlReader(config.sitemapUrl);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`共检索到<span class="subst">$&#123;urls.length&#125;</span>个链接`</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"开始获取已经初始化的issues:"</span>);</span><br><span class="line">        <span class="keyword">let</span> issues = <span class="keyword">await</span> send(requestGetOpt);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`已经存在<span class="subst">$&#123;issues.length&#125;</span>个issues`</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> notInitIssueLinks = urls.filter(<span class="function">(<span class="params">link</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> !issues.find(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">                link = removeProtocol(link);</span><br><span class="line">                <span class="keyword">return</span> item.body.includes(link);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (notInitIssueLinks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`本次有<span class="subst">$&#123;notInitIssueLinks.length&#125;</span>个链接需要初始化issue：`</span>);</span><br><span class="line">            <span class="built_in">console</span>.log(notInitIssueLinks);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"开始提交初始化请求, 大约需要40秒..."</span>);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 部署好网站后，直接执行start，新增文章并不会生成评论</span></span><br><span class="line"><span class="comment">             * 经测试，最少需要等待40秒，才可以正确生成， 怀疑跟github的api有关系，没有找到实锤</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            setTimeout(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">                <span class="keyword">let</span> initRet = <span class="keyword">await</span> notInitIssueLinks.map(<span class="keyword">async</span> (item) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> html = <span class="keyword">await</span> send(&#123; ...requestGetOpt, <span class="attr">url</span>: item &#125;);</span><br><span class="line">                    <span class="keyword">let</span> title = cheerio.load(html)(<span class="string">"title"</span>).text();</span><br><span class="line">                    <span class="keyword">let</span> pathLabel = url.parse(item).path;</span><br><span class="line">                    pathLabel = md5(config.baseUrl + pathLabel);<span class="comment">//中文过长所以要md5</span></span><br><span class="line">                    <span class="keyword">let</span> body = <span class="string">`<span class="subst">$&#123;item&#125;</span>&lt;br&gt;&lt;br&gt;<span class="subst">$&#123;websiteConfig.description&#125;</span>`</span>;</span><br><span class="line">                    <span class="keyword">let</span> form = <span class="built_in">JSON</span>.stringify(&#123; body, <span class="attr">labels</span>: [config.kind, pathLabel], title &#125;);</span><br><span class="line">                    <span class="keyword">return</span> send(&#123; ...requestPostOpt, form &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`已完成<span class="subst">$&#123;initRet.length&#125;</span>个！`</span>);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"可以愉快的发表评论了！"</span>);</span><br><span class="line">            &#125;,<span class="number">40000</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"本次发布无新增页面，无需初始化issue!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`初始化issue出错，错误如下：`</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sitemapXmlReader</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> data = fs.readFileSync(file, <span class="string">"utf8"</span>);</span><br><span class="line">    <span class="keyword">let</span> sitemap = xmlParser(data);</span><br><span class="line">    <span class="keyword">return</span> sitemap.root.children.map(<span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> loc = url.children.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item.name === <span class="string">"loc"</span>;</span><br><span class="line">        &#125;)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> loc.content;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeProtocol</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> url.substr(url.indexOf(<span class="string">":"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        request(options, <span class="function"><span class="keyword">function</span> (<span class="params">error, response, body</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">                resolve(body);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-操作步骤"><a href="#5-操作步骤" class="headerlink" title="5 操作步骤"></a>5 操作步骤</h1><p>每次<code>hexo d</code>后执行<code>node ./comment.js</code>即可,不过不要觉得他们的执行顺序由强约束，其实你可以随时执行<code>node ./comment.js</code>，两者没有必要关联，只不过每次你hexo d后，肯定会新增的文章需要生成评论，所以调用一次</p><h1 id="6-后续发生的问题总结"><a href="#6-后续发生的问题总结" class="headerlink" title="6 后续发生的问题总结"></a>6 后续发生的问题总结</h1><p>当执行node ./comment.js出现如下问题时,<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">internal/modules/cjs/loader.js:638</span><br><span class="line">    throw err;</span><br><span class="line">    ^</span><br><span class="line"></span><br><span class="line">Error: Cannot find module './options'</span><br><span class="line">    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:636:15)</span><br><span class="line">    at Function.Module._load (internal/modules/cjs/loader.js:562:25)</span><br><span class="line">    at Module.require (internal/modules/cjs/loader.js:692:17)</span><br><span class="line">    at require (internal/modules/cjs/helpers.js:25:18)</span><br><span class="line">    at Object.&lt;anonymous&gt; (/home/zazalu/blog/zazaluMonster.github.io/node_modules/cheerio/lib/cheerio.js:6:22)</span><br><span class="line">    at Module._compile (internal/modules/cjs/loader.js:778:30)</span><br><span class="line">    at Object.Module._extensions..js (internal/modules/cjs/loader.js:789:10)</span><br><span class="line">    at Module.load (internal/modules/cjs/loader.js:653:32)</span><br><span class="line">    at tryModuleLoad (internal/modules/cjs/loader.js:593:12)</span><br><span class="line">    at Function.Module._load (internal/modules/cjs/loader.js:585:3)</span><br></pre></td></tr></table></figure></p><h2 id="直接删除整个node-modules文件夹-重新执行npm-install解决-我猜测是node模块构建问题"><a href="#直接删除整个node-modules文件夹-重新执行npm-install解决-我猜测是node模块构建问题" class="headerlink" title="直接删除整个node_modules文件夹,重新执行npm install解决,我猜测是node模块构建问题"></a>直接删除整个<code>node_modules</code>文件夹,重新执行<code>npm install</code>解决,我猜测是node模块构建问题</h2><p>如果切换环境调用github api, token需要重新生成, 请注意</p><div id="donationPoint"><div id="licensePoint"></div></div>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gitalk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加快Github Pages服务+Hexo博客的首次加载速度解决方案</title>
      <link href="/2019/09/20/pages-hexo-accelerate/"/>
      <url>/2019/09/20/pages-hexo-accelerate/</url>
      
        <content type="html"><![CDATA[<h1 id="情况分析"><a href="#情况分析" class="headerlink" title="情况分析"></a>情况分析</h1><p>国内往GithubPages发送GET请求，很慢，第一次访问的速度在我这边透过浏览器F12工具解析大概是</p><p>建立连接（初始化，SSL等等）好几s<br>等待响应（TTFB）好几s<br>下载速度倒还行几毫秒</p><p>下载到index.html后，浏览器对html进行解析，继续请求html内的各种js，css，字体库等等等等静态资源！</p><p>然后我的网页才开始展示！</p><h1 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h1><ol><li><p>访问github很慢，是由于国外网站，而我在国内，不开代理情况下，肯定慢。所以解决方法是让网站备案然后加入CDN，但是好的CDN要钱（万一一个DDOS攻击呵呵），作为一个垃圾个人博客，没必要，暂时先不搞</p></li><li><p>将所有静态资源托管到国内服务器上，这里有两种选择：</p><ul><li><p>白嫖国内免费pages服务（我自己的骚操作）: 我发现gitee的pages支持跨域访问（目前发现只支持css,js,image资源，不支持字体库，json文件），于是可以在gitee上上传一份hexo的文件，然后在_config.yml中配置一个<code>baseUrl</code>，然后在各类模板文件中加上这个<code>baseUrl</code>配置，比如我现在是这样的：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Trusteeship:</span></span><br><span class="line"><span class="attr">    baseUrl:</span> <span class="attr">https://your.gitee.io/your.gitee.repo/</span></span><br></pre></td></tr></table></figure><p>然后在模板文档里这样搞一下(需要的地方加上前缀))：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%-</span> <span class="attr">css</span>(<span class="attr">theme.Trusteeship.baseUrl</span> + '<span class="attr">css</span>/<span class="attr">style</span>') %&gt;</span></span><br></pre></td></tr></table></figure><p>这个方法总体来看很不错，唯一缺点就是字体库，json文件没法跨域访问，导致加载失败，最后只能把这些加载失败的文件单独重新转到github pages上或者转到你别的托管服务器上了。。这过程中由于我对hexo整体代码架构也不是很熟悉，所以为了一时爽，我直接硬编码了！</p><p>最后在hexo配置文件中加入gitee的git库配置就行了，这样<code>hexo d</code>就会依次推到这两个pages上了，然后github page上的部分静态资源从gitee pages上去获取！ xswl。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repository:</span> <span class="string">'your github repo'</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">- type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repository:</span> <span class="string">'your gitee repo'</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>注意先git remote ‘gitee repo’</p></li></ul></li></ol><pre><code>- 托管到自己的服务器上：比如你搞个阿里云轻量服务器，专门搞个后台负责管理静态资源，由于服务器在国内，所以访问肯定不慢。 不过这个方法是个伪命题，你既然都有自己的服务器了，那就直接把hexo也搬过来不就好了。由于服务器花钱，我暂时不考虑。</code></pre><h1 id="说说为啥我要这么做"><a href="#说说为啥我要这么做" class="headerlink" title="说说为啥我要这么做"></a>说说为啥我要这么做</h1><p>其实回过头来看我觉得肯定有人会说我这样搞折腾，麻烦，既然用了gitee了，那就直接全部搬家搬到gitee就好了。 </p><p>但是那样的话域名的跳转，CNAME，这些东西都要改QAQ， 我想了想算了，不改已经搞定的东西了，毕竟完全没必要，而且github pages更稳定</p><p>CDN加速等我完成备案再搞</p><h1 id="存在的坑"><a href="#存在的坑" class="headerlink" title="存在的坑"></a>存在的坑</h1><ol><li><p>如果采用上面的第二种方法，当你想换主题的时候，额外的工作量会很比较大，因为你换个主题后，这个主题内的配置你要转移到新主题上，重新配！</p></li><li><p>gitee pages需要重新部署才能访问你新加的静态资源，比如访问新加入的图片，新加的css，js文件，不然直接404！ 除非你开通gitee pages pro， 不然都需要在网页上手动重新部署！ 对gitee的这种行为我只能竖一个中指.. 毕竟网站也要盈利…</p></li></ol><p>暂时就总结这些，有事先闪了！！</p><div id="donationPoint"><div id="licensePoint"></div></div>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo魔改 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>放弃Disqus, 拥抱Gitalk(基于Hexo)</title>
      <link href="/2019/09/19/use-gitalk-in-hexo-by-script/"/>
      <url>/2019/09/19/use-gitalk-in-hexo-by-script/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Disqus用起来啥都还行，就是国内访问不了太差劲了。。</p><p>最终决定改用Gitalk， 简单看下了文档， 上手还是很快的， 结合自己写的脚本， 可以做到一键开闭Gitalk功能（日后在完善成package打包到npm上供我自己更方便的使用）</p><h2 id="安装Gitalk到Hexo中"><a href="#安装Gitalk到Hexo中" class="headerlink" title="安装Gitalk到Hexo中"></a>安装Gitalk到Hexo中</h2><h3 id="修改-config-yml"><a href="#修改-config-yml" class="headerlink" title="修改_config.yml"></a>修改_config.yml</h3><p>在Hexo的<code>_config.yml</code>中添加如下配置：<br>z<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Gitalk comments config. (if use Gitalk, please close Disqus comments first)</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  clientID:</span> <span class="string">'GitHub Application Client ID'</span><span class="string">,</span></span><br><span class="line"><span class="attr">  clientSecret:</span> <span class="string">'GitHub Application Client Secret'</span><span class="string">,</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">'GitHub repo'</span><span class="string">,</span></span><br><span class="line"><span class="attr">  owner:</span> <span class="string">'GitHub repo owner'</span><span class="string">,</span></span><br><span class="line"><span class="attr">  admin:</span> <span class="string">['GitHub</span> <span class="string">repo</span> <span class="string">owner</span> <span class="string">and</span> <span class="string">collaborators,</span> <span class="string">only</span> <span class="string">these</span> <span class="string">guys</span> <span class="string">can</span> <span class="string">initialize</span> <span class="string">github</span> <span class="string">issues'],</span></span><br><span class="line"><span class="attr">  distractionFreeMode:</span> <span class="literal">false</span> <span class="comment"># 是否需要遮罩</span></span><br></pre></td></tr></table></figure></p><p>该配置中的<code>clientID</code>和<code>clientSecret</code> 需要 GitHub Application，可以在这个网站注册后获得</p><p><a href="https://medium.com/platform-engineer/understanding-java-memory-model-1d0863f6d973" target="_blank" rel="noopener">https://medium.com/platform-engineer/understanding-java-memory-model-1d0863f6d973</a></p><p>注册的时候<code>Homepage URL</code>和<code>Authorization callback URL</code>都填你的博客域名即可</p><p>下面是我的gitalk配置，还不是很理解的小伙伴可以参考下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Gitalk comments config. (if use Gitalk, please close Disqus comments first)</span></span><br><span class="line"><span class="attr">gitalk:</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  clientID:</span> <span class="string">'我的clientID'</span></span><br><span class="line"><span class="attr">  clientSecret:</span> <span class="string">'我的clientSecret'</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">'zazaluMonster.github.io'</span></span><br><span class="line"><span class="attr">  owner:</span> <span class="string">'zazaluMonster'</span></span><br><span class="line"><span class="attr">  admin:</span> <span class="string">['zazaluMonster']</span></span><br><span class="line"><span class="attr">  distractionFreeMode:</span> <span class="literal">false</span> <span class="comment"># 是否需要遮罩</span></span><br></pre></td></tr></table></figure><h2 id="编写脚本-自动注入Gitalk启动代码"><a href="#编写脚本-自动注入Gitalk启动代码" class="headerlink" title="编写脚本-自动注入Gitalk启动代码"></a>编写脚本-自动注入Gitalk启动代码</h2><p>脚本内容如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * gitalk_register.js</span></span><br><span class="line"><span class="comment"> * @description 注入gitalk内容到index.html末尾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply options with default</span></span><br><span class="line"><span class="keyword">let</span> config = _.defaultsDeep(&#123;</span><br><span class="line">&#125;, hexo.config.gitalk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(config.enabled)&#123;</span><br><span class="line">  hexo.extend.filter.register(<span class="string">'after_render:html'</span>, (htmlContent) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> scriptToInject = <span class="string">`</span></span><br><span class="line"><span class="string">    if(location.pathname == '/')&#123;</span></span><br><span class="line"><span class="string">      //首页不需要评论系统</span></span><br><span class="line"><span class="string">    &#125;else&#123;</span></span><br><span class="line"><span class="string">      var gitalk = new Gitalk(&#123;</span></span><br><span class="line"><span class="string">        clientID: '<span class="subst">$&#123;config.clientID&#125;</span>',</span></span><br><span class="line"><span class="string">        clientSecret: '<span class="subst">$&#123;config.clientSecret&#125;</span>',</span></span><br><span class="line"><span class="string">        repo: '<span class="subst">$&#123;config.repo&#125;</span>',</span></span><br><span class="line"><span class="string">        owner: '<span class="subst">$&#123;config.owner&#125;</span>',</span></span><br><span class="line"><span class="string">        admin: '<span class="subst">$&#123;config.admin&#125;</span>',</span></span><br><span class="line"><span class="string">        id: md5(location.pathname),</span></span><br><span class="line"><span class="string">        distractionFreeMode: <span class="subst">$&#123;config.distractionFreeMode&#125;</span></span></span><br><span class="line"><span class="string">      &#125;);</span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">      gitalk.render('gitalk-container');</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">    <span class="keyword">const</span> contentToInject = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"&gt;</span></span><br><span class="line"><span class="string">    &lt;script src="https://unpkg.com/gitalk/dist/gitalk.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script src="/js/md5.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;div id="gitalk-container"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;script&gt;<span class="subst">$&#123;scriptToInject&#125;</span>&lt;/script&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">    <span class="keyword">let</span> newHtmlContent = htmlContent;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="regexp">/([\n\r\s\t]*&lt;\/body&gt;)/i</span>).test(htmlContent)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> lastIndex = htmlContent.lastIndexOf(<span class="string">'&lt;/body&gt;'</span>);</span><br><span class="line">      newHtmlContent = <span class="string">`<span class="subst">$&#123;htmlContent.substring(<span class="number">0</span>, lastIndex)&#125;</span><span class="subst">$&#123;contentToInject&#125;</span><span class="subst">$&#123;htmlContent.substring(lastIndex, htmlContent.length)&#125;</span>`</span>; <span class="comment">// eslint-disable-line no-magic-numbers</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHtmlContent;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>没有lodash模块的话使用npm自己安装下.（说实话这里也不需要用到lodash，由于我代码复制过来然后自己改了点，所以保留了这个方法）</p><p>这段脚本就是在渲染完成后的html末尾加上gitalk的启动代码，非常好理解，唯一注意的地方用到了md5加密方法来加密id，防止gittalk报错. id字段不允许超过50个字符，所以迫不得已只能对location.pathname进行加密。</p><p><code>md5.min.js</code>这个js的内容在<a href="https://github.com/blueimp/JavaScript-MD5" target="_blank" rel="noopener">https://github.com/blueimp/JavaScript-MD5</a><br>把这个js下下来后放置到<code>your.github.io\themes\your-theme-folder\source\js</code>下即可</p><p>将该脚本<code>gitalk_register.js</code>放置到<code>your.github.io\themes\your-theme-folder\scripts</code>下即可， 这个文件夹下的js文件会在hexo-cli工具运行的时候自动执行(执行时机就不说明了，可以自己看官方文档)</p><p>如果仍然出现文件404问题，请自行根据自己的情况来改变路径即可</p><h2 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h2><p>试试<code>hexo g</code>,<code>hexo d</code>然后看看效果吧</p><div id="donationPoint"><div id="licensePoint"></div></div>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo魔改 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冷静对待你遇到的所有Java内存异常</title>
      <link href="/2019/09/17/java-memory-error-solution-Theoretically/"/>
      <url>/2019/09/17/java-memory-error-solution-Theoretically/</url>
      
        <content type="html"><![CDATA[<h2 id="被人说烂的Java内存模型"><a href="#被人说烂的Java内存模型" class="headerlink" title="被人说烂的Java内存模型"></a>被人说烂的Java内存模型</h2><p>Java内存模型的相关资料在网上实在是太多了,不管是过时的还是不过时的,网络上充斥的学习资料,比如各类研究Java内存模型的博文,也随着Java的发展,渐渐失去了其内容的准确性.</p><p>要在那么多网络资料中找到对Java内存模型最新最全的说法,估计最好的方式只有翻阅Oracle的文档了!(字体大小太不舒服了!)</p><p>我最近也不停的查阅和总结了不少网上的资料,不过由于类似资料实在太多,所以不打算重复的说明这个被人说烂的Java内存模型</p><h2 id="从各种OOM异常出发来零距离的理解Java内存模型"><a href="#从各种OOM异常出发来零距离的理解Java内存模型" class="headerlink" title="从各种OOM异常出发来零距离的理解Java内存模型"></a>从各种OOM异常出发来零距离的理解Java内存模型</h2><p>对于大脑来说, 大脑更喜欢问题, 而不是从陈述开始.</p><p>本文会从平时工作中可能会遇到的OOM异常出发,来一步步的深入理解我们所熟知的Java内存模型,从而哪怕可以更加理解一点这些方面的编程思想和设计精髓, 也是一个不小的进步</p><h2 id="java-lang-StackOverFlowError"><a href="#java-lang-StackOverFlowError" class="headerlink" title="java.lang.StackOverFlowError"></a>java.lang.StackOverFlowError</h2><h3 id="这个Stack是什么鬼东西"><a href="#这个Stack是什么鬼东西" class="headerlink" title="这个Stack是什么鬼东西"></a>这个Stack是什么鬼东西</h3><p>Stack是个栈, 是一种数据结构, 会占用一块内存空间</p><h3 id="Java在哪些地方会使用Stack来存储数据"><a href="#Java在哪些地方会使用Stack来存储数据" class="headerlink" title="Java在哪些地方会使用Stack来存储数据"></a>Java在哪些地方会使用Stack来存储数据</h3><ol><li><p>最常见的就是虚拟机栈, 它是专门为java Method执行服务的一块内存, 每个方法调用都会往这个栈中压入一个栈帧(stackFrame), 由于方法可以互调,迭代,所以使用栈模型来服务Java Method是很适合的一种数据结构模型</p></li><li><p>别忘了还有一个本地方法栈, 它是专门为java的底层native方法执行服务的一块内存. 然而由于native方法都是术语jdk内部的测试稳定的程序,所以作为应用java开发人员的我们,一般是不可能遇到这个层面抛出的这个异常,同时我也几乎可以判断这种方法是不会直接抛出java.lang.StackOverFlowError异常的,所以我们可以缩小我们的关注范围,把抛出这个异常的原因全部指向于虚拟机栈即可</p></li></ol><h3 id="这种异常是如何发生的"><a href="#这种异常是如何发生的" class="headerlink" title="这种异常是如何发生的?"></a>这种异常是如何发生的?</h3><p>我们知道每调用一次Java Method,就会往虚拟机栈中压入一个栈帧,在方法结束之前都不会出栈. 所以可以直接推理出在一个java线程运行过程中,如果同时调用的方法过多(比如递归的调用一个方法),就会出现这个异常</p><p>事实上,除了恶性递归或者虚拟机栈可用内存过小的情况下, 也很难触发这种异常, 所以一般来说遇到这种异常几乎是可以直接断定程序中存在恶性递归导致的.</p><p>这类问题在实际开发中遇到的并不多, 反而是在做一些算法问题的时候, 由于自己的疏忽从而引发不可预知的恶性递归</p><h3 id="一个简单的Demo复现这种异常"><a href="#一个简单的Demo复现这种异常" class="headerlink" title="一个简单的Demo复现这种异常"></a>一个简单的Demo复现这种异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main.main(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码就会报StackOverFlowError, 因为main方法会被不停的循环执行, 直到超出虚拟机栈能够承受的大小</p><h3 id="相关JVM参数"><a href="#相关JVM参数" class="headerlink" title="相关JVM参数"></a>相关JVM参数</h3><p>-Xss, 正常取值128K~256K, 如果仍然不够可以进行加大, 这个选项对性能影响比较大，需要严格的测试哦</p><h2 id="java-lang-OutOfMemoryError-Java-heap-space"><a href="#java-lang-OutOfMemoryError-Java-heap-space" class="headerlink" title="java.lang.OutOfMemoryError: Java heap space"></a>java.lang.OutOfMemoryError: Java heap space</h2><p>这个异常表示, Java程序运行过程中遭遇了内存超限问题, 根本原因是Java的堆(Heap)内存超限</p><h3 id="Java常用的内存空间对应计算机硬件是哪些组件"><a href="#Java常用的内存空间对应计算机硬件是哪些组件" class="headerlink" title="Java常用的内存空间对应计算机硬件是哪些组件?"></a>Java常用的内存空间对应计算机硬件是哪些组件?</h3><ol><li>寄存器(比如每个Java线程独享程序计数器(Program Counter Register))</li><li>RAM(也就是我们常说的内存,java中的虚拟机栈,堆内存都用的这块)</li></ol><h3 id="什么是Java的堆内存-Heap"><a href="#什么是Java的堆内存-Heap" class="headerlink" title="什么是Java的堆内存(Heap)"></a>什么是Java的堆内存(Heap)</h3><p>这就涉及了Java的运行时内存模型了~ </p><p>我就简单来说下吧~</p><p>一个JVM进程运行后, 会有一个主线程去运行我们写的Java程序, 那么每一个这种线程都拥有两大块内存空间</p><ul><li>线程共享内存空间<ul><li>堆(Heap, 所有java的对象实例和数组,jdk8后还存放了字符串常量池和类静态变量)</li><li>方法区(存放类元数据,符号引用,静态常量,jdk8后HotSpot将其从永久代移动到了Metaspace)</li></ul></li><li>线程独享内存空间<ul><li>虚拟机栈(为Java方法提供的一块内存空间,内部有栈帧组成)</li><li>本地方法栈(为Java的native方法)</li><li>程序计数器(PC寄存器,记录执行行号)</li></ul></li></ul><p>所以Java的堆内存就是JVM中设定的一块专门存储所有java的对象实例和数组,jdk8后甚至包括字符串常量池和类静态变量的内存区域</p><h3 id="这种异常是如何发生的-1"><a href="#这种异常是如何发生的-1" class="headerlink" title="这种异常是如何发生的?"></a>这种异常是如何发生的?</h3><p>如果是1.7以前, Java堆溢出的问题根源是简单的, 就是运行时存在的对象实例和数组太多了!</p><p>但是在1.8后, 由于还存放了字符串常量, 所以出现异常还有一种可能就是 interned Strings 过多导致的哦!</p><h3 id="最小复现Demo"><a href="#最小复现Demo" class="headerlink" title="最小复现Demo"></a>最小复现Demo</h3><p>执行前最好先修改下JVM参数,防止等待时间过长<br>JVM参数:<br>-Xms20m<br>-Xmx20m<br>-XX:MetaspaceSize=10m<br>-XX:MaxMetaspaceSize=10m<br>-XX:-UseGCOverheadLimit</p><p>JVM参数说明: 限制堆大小20M,方便快速报错! 由于我用的是jdk8,所以限制了元空间的大小为10m,说实话在这个情况下没啥用哈哈哈哈哈哈哈(就是觉得加上去舒服才加的,不信我说的你可以自己google)!最后一个参数-XX:-UseGCOverheadLimit这个有必要加一下. 因为我的demo程序属于那种恶意的程序,所以一次GC几乎没办法清理任何对象实例,因为他们都在被占用着! 所以必须使用这个参数来防止GC检测出我的这种恶意程序,从而正常的提示堆溢出的错误而不是GC Overhead limit exceeded错误(这个错误会在后面细讲)</p><ol><li>普通的对象实例爆掉堆内存</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Object());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>interned Strings过多爆掉堆内存(有待考证此代码的准确性,请不要盲目相信,要有自己的想法)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            list.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码说明: 这串代码会每次生成一个新的interned String, 也就是数字递增对应的String表示, 所以最终爆掉内存, 证明了是interned Strings爆掉了内存, 相同的代码在jkd1.7以前是不会报堆内存溢出的, 请注意</p><h3 id="相关JVM参数-1"><a href="#相关JVM参数-1" class="headerlink" title="相关JVM参数"></a>相关JVM参数</h3><p>-Xms : 初始堆大小<br>-Xmx : 最大堆大小</p><h3 id="如何处理"><a href="#如何处理" class="headerlink" title="如何处理?"></a>如何处理?</h3><p>查看jvm快照,分析占用内存大的对象是哪些, 然后定位到代码位置, 最后进行优化</p><p>我一般使用visualVM来查看这类问题</p><h2 id="java-lang-OutOfMemoryError-GC-Overhead-limit-exceeded"><a href="#java-lang-OutOfMemoryError-GC-Overhead-limit-exceeded" class="headerlink" title="java.lang.OutOfMemoryError: GC Overhead limit exceeded"></a>java.lang.OutOfMemoryError: GC Overhead limit exceeded</h2><p>这个异常表示您的Java程序在运行的时候, 98%的时间都在执行GC回收, 但是每次回收只回收不到2%的空间!</p><p>换句话说,其实这个异常往往是抛出java.lang.OutOfMemoryError: Java heap space异常的前兆! 因为Java程序每次都GC回收只能回收一点点内存空间,而你的程序却仍然在不停的产生新的对象实例, 这无疑导致了两种可能结果: </p><ol><li>不停的进行GC</li><li>直接超出的堆内存大小</li></ol><p>这个问题还有一些细节需要我们去掌握,我们先从下面的例子来看吧</p><h3 id="最小复现Demo-1"><a href="#最小复现Demo-1" class="headerlink" title="最小复现Demo"></a>最小复现Demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map map = System.getProperties();</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            map.put(r.nextInt(), <span class="string">"value"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码说明:  这段代码不停的往map中加入新的key-value,导致map大小不断变大! 当到达堆内存顶点的时候,GC发生, 但是清理完毕后,JVM发现清理前后的堆内存大小改变很小,不到2%; 这时候程序继续运行,继续往map中加数据!GC又发生了!又只清理不到2%! 如此不停的循环, 最后JVM得出了一个判断! 你的Java程序在占用CPU进行运算的时间里,98%的时间都特么的在垃圾回收,而每次GC居然只能回收堆内存的2%空间, 这肯定是代码存在问题,于是抛出了这个异常. 如果这个时候,你断定不是自己的代码问题, 使用JVM参数-XX:-UseGCOverheadLimit来关闭这种检查! 然后你就会发现你的程序抛出了堆溢出异常! 为什么呢? 因为堆内存不断的被占满,最终导致最后一次加入新的int的时候, 堆内存空间直接不足了!</p><h3 id="这个异常一般如何处理"><a href="#这个异常一般如何处理" class="headerlink" title="这个异常一般如何处理"></a>这个异常一般如何处理</h3><p>和堆溢出的解决方式一致</p><h3 id="相关JVM参数-2"><a href="#相关JVM参数-2" class="headerlink" title="相关JVM参数"></a>相关JVM参数</h3><p>-XX:-UseGCOverheadLimit</p><h2 id="java-lang-OutOfMemoryError-Permgen-space-jdk8已经不会出现此异常-请注意"><a href="#java-lang-OutOfMemoryError-Permgen-space-jdk8已经不会出现此异常-请注意" class="headerlink" title="java.lang.OutOfMemoryError: Permgen space  (jdk8已经不会出现此异常,请注意)"></a>java.lang.OutOfMemoryError: Permgen space  (jdk8已经不会出现此异常,请注意)</h2><p>只存在于jdk1.8以前的java程序中! 这个异常表示,永久代大小不够!</p><h3 id="什么是Permgen"><a href="#什么是Permgen" class="headerlink" title="什么是Permgen"></a>什么是Permgen</h3><p>是HotSpot在jdk1.8以前存在的一个区域,用于实现方法区</p><h3 id="什么时候会产生这个错误以及如何解决"><a href="#什么时候会产生这个错误以及如何解决" class="headerlink" title="什么时候会产生这个错误以及如何解决"></a>什么时候会产生这个错误以及如何解决</h3><p>由于是实现方法区的地方, 所以肯定是类元信息或者常量（jdk1.7后部分常量已经挪到堆中），静态常量和JIT即时编译器编译后的代码等数据太多导致大小不够</p><p>乍一看也许你会头晕! 不过没关系, 根据我两年的开发经验, 我碰到过的唯一一次Permgen space问题是因为SpringIoC容器一口气加载了过多的Bean导致的!</p><p>所以正常来说, 直接扩大这个区域的大小即可!</p><p>比如使用如下JVM参数扩大:<br>-XX:MaxNewSize=xxxm -XX:MaxPermSize=xxxm</p><h3 id="最小复现Demo-2"><a href="#最小复现Demo-2" class="headerlink" title="最小复现Demo"></a>最小复现Demo</h3><p>运行要求: jdk版本 &lt;= 1.6</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MicroGenerator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100_000_000</span>; i++) &#123;</span><br><span class="line">      generate(<span class="string">"eu.plumbr.demo.Generated"</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class <span class="title">generate</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ClassPool pool = ClassPool.getDefault();</span><br><span class="line">    <span class="keyword">return</span> pool.makeClass(name).toClass();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助了javassist来不停的加载新的class,直至爆掉永久代区域</p><h3 id="相关JVM参数-3"><a href="#相关JVM参数-3" class="headerlink" title="相关JVM参数"></a>相关JVM参数</h3><p>-XX:PermSize=xxxm<br>-XX:MaxPermSize=xxxm</p><h2 id="java-lang-OutOfMemoryError-Metaspace-since-jdk8-才有可能抛出的错误"><a href="#java-lang-OutOfMemoryError-Metaspace-since-jdk8-才有可能抛出的错误" class="headerlink" title="java.lang.OutOfMemoryError: Metaspace (since jdk8 才有可能抛出的错误)"></a>java.lang.OutOfMemoryError: Metaspace (since jdk8 才有可能抛出的错误)</h2><p>这个异常表示: Metaspace的空间不足导致OOM异常发生</p><h3 id="什么是Metaspace"><a href="#什么是Metaspace" class="headerlink" title="什么是Metaspace"></a>什么是Metaspace</h3><p>有些不太专注JVM知识的小伙伴可能对Metaspace是陌生的, 因为这玩意是jdk8开始才正式登场的一块内存区域. 它专门用于替代原来的永久代, 且存在于本地内存中, 所以它的最大内存理论就是你电脑的最大内存. 和永久代不一样的是, 它可以进行自我扩容, 直到达到规定的MaxMetaspaceSize或者到达本机的最大可用内存为止. </p><p>Metaspace接替了永久代的任务, 方法区的内容全部转移到此处(除了字符串常量池被挪到了堆中)</p><p>不过相比于永久代, Metaspace进行GC的时候, 稍微改变了一点规则, Metaspace中类元数据是否需要回收是根据类加载器死活来来决定的, 这不同于永久代的, 只要类引用消失就会被回收. 这种规则会产生一些问题: </p><ol><li><a href="https://blog.csdn.net/xyghehehehe/article/details/78820135#commentsedit" target="_blank" rel="noopener">https://blog.csdn.net/xyghehehehe/article/details/78820135#commentsedit</a></li><li><a href="https://zhuanlan.zhihu.com/p/25634935" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25634935</a></li></ol><p>所以在jdk8后使用反射,动态代理等会生成class对象的方法, 一定要小心MetaSpace是否会对其进行回收, 如果不会, 则需要进行相应的优化处理</p><h3 id="为什么要移除永久代"><a href="#为什么要移除永久代" class="headerlink" title="为什么要移除永久代"></a>为什么要移除永久代</h3><ol><li><p>方法区大小难以设定，容易发生内存溢出。永久代会存放Class的相关信息，一般这些信息在编译期间就能确定大小。但是如果是在一些需要动态生成大量Class的应用中，如：Spring的动态代理、大量的JSP页面或动态生成JSP页面等，由于方法区的大小在一开始就要分配好，因此就能难确定大小，容易出现内存溢出</p></li><li><p>GC复杂且效率低。方法区存储了类的元数据信息和各种常量，它的内存回收目标理应当是对这些类型的卸载和常量的回收。但由于这些数据被类的实例引用，卸载条件变得复杂且严格，回收不当会导致堆中的类实例失去元数据信息和常量信息。因此，回收方法区内存不是一件简单高效的事情。</p></li><li><p>促进HotSpot JVM与JRockit VM的融合。JRockit没有方法区，移除永久代可以促进HotSpot JVM与JRockit VM的融合。</p></li></ol><h3 id="最小复现Demo-3"><a href="#最小复现Demo-3" class="headerlink" title="最小复现Demo"></a>最小复现Demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> -XX:MetaspaceSize=8m</span></span><br><span class="line"><span class="comment"> -XX:MaxMetaspaceSize=8m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaSpaceOOMTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(OOMObject.class);</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//无限创建动态代理，生成Class对象</span></span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何解决这类异常"><a href="#如何解决这类异常" class="headerlink" title="如何解决这类异常"></a>如何解决这类异常</h3><ol><li><p>增大MetaSpace的最大空间大小</p></li><li><p>类似检查永久代异常一样的处理方式, 检查dump文件, 查看哪些类加载存在异常</p></li></ol><h3 id="相关JVM参数-4"><a href="#相关JVM参数-4" class="headerlink" title="相关JVM参数"></a>相关JVM参数</h3><p> -XX:MetaspaceSize=8m<br> -XX:MaxMetaspaceSize=8m</p><h2 id="java-lang-OutOfMemoryError-Unable-to-create-new-native-thread"><a href="#java-lang-OutOfMemoryError-Unable-to-create-new-native-thread" class="headerlink" title="java.lang.OutOfMemoryError: Unable to create new native thread"></a>java.lang.OutOfMemoryError: Unable to create new native thread</h2><p>这个异常表示,JVM无法再创建新的线程了!JVM能够创建的线程数是有限制的,</p><h3 id="复现demo"><a href="#复现demo" class="headerlink" title="复现demo"></a>复现demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNativeOutOfMemoryError</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;; i++) &#123;  </span><br><span class="line">            System.out.println(<span class="string">"i = "</span> + i);  </span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> HoldThread()).start();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;  </span><br><span class="line">    CountDownLatch cdl = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HoldThread</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.setDaemon(<span class="keyword">true</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            cdl.await();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><p>去用线程池!</p></li><li><p>检查代码是否存在bug在不停的生成新线程!</p></li><li><p>如果确实需要那么多线程,那就修改OS和JVM的参数设置,并且加大你的硬件内存容量!</p></li></ol><h2 id="java-lang-OutOfMemoryError-request-size-bytes-for-reason"><a href="#java-lang-OutOfMemoryError-request-size-bytes-for-reason" class="headerlink" title="java.lang.OutOfMemoryError: request size bytes for reason"></a>java.lang.OutOfMemoryError: request size bytes for reason</h2><p>如果你看到了这个异常, 说明你的OS内存不够用了, JVM想本地操作系统申请内存被拒绝, 导致JVM进程无法继续运行! 发生这个问题的原因一般是你的Java程序需要的内存容量超过了操作系统可提供给JVM的最大内存容量, 连swap内存都没了</p><h2 id="java-lang-OutOfMemoryError-Requested-array-size-exceeds-VM"><a href="#java-lang-OutOfMemoryError-Requested-array-size-exceeds-VM" class="headerlink" title="java.lang.OutOfMemoryError: Requested array size exceeds VM"></a>java.lang.OutOfMemoryError: Requested array size exceeds VM</h2><p>当你正准备创建一个超过虚拟机允许的大小的数组时，这条错误就会出现在你眼前!</p><h2 id="尾"><a href="#尾" class="headerlink" title="尾"></a>尾</h2><p>本文对java常见的OOM异常做了总结说明,同时对于涉及的Java内存模型进行了说明,希望可以在日后遇到类似问题的时候可以沉着冷静,不慌不忙的来排查问题</p><p>参考:<br><a href="https://medium.com/platform-engineer/understanding-java-memory-model-1d0863f6d973" target="_blank" rel="noopener">https://medium.com/platform-engineer/understanding-java-memory-model-1d0863f6d973</a><br><a href="https://juejin.im/post/5ca02d046fb9a05e6a086cb7" target="_blank" rel="noopener">https://juejin.im/post/5ca02d046fb9a05e6a086cb7</a><br><a href="https://zhuanlan.zhihu.com/p/25634935" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25634935</a><br><a href="https://www.zhihu.com/question/39990490/answer/369690291" target="_blank" rel="noopener">https://www.zhihu.com/question/39990490/answer/369690291</a></p><div id="donationPoint"><div id="licensePoint"></div></div>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我是个经常笑的人,但我不是一个经常开心的人</title>
      <link href="/2019/09/04/always-smail-but-not-always-happy/"/>
      <url>/2019/09/04/always-smail-but-not-always-happy/</url>
      
        <content type="html"><![CDATA[<p>本文是我不成熟的偏见, 毫无营养, 建议别看</p><h1 id="文化社会正在慢慢形成稳固"><a href="#文化社会正在慢慢形成稳固" class="headerlink" title="文化社会正在慢慢形成稳固"></a>文化社会正在慢慢形成稳固</h1><p>唯一值得肯定的是, 中国人的表面素质在稳定上升的, 这多半和九年义务教育脱不了关系</p><p>现在中国社会的青年整体基本都已经是有文化的人了</p><p>就算是没文化的人, 也会被慢慢同化, 受到大部分有文化人的影响, 也会慢慢的表现出文化人的样子, 文质彬彬, 说话礼貌</p><p>中国社会正在稳步的往高素质社会发展</p><h1 id="猪社会正在慢慢渗透"><a href="#猪社会正在慢慢渗透" class="headerlink" title="猪社会正在慢慢渗透"></a>猪社会正在慢慢渗透</h1><p>唯一值得担心的是, 九年义务教育导致社会上的所有平凡人, 会活的像同一个板子里印出来的一样的生活, 所有处事习惯, 经历几乎相似, 说的难听一点就是, 大家都活的像个猪, 被国家精心安排好了所有的路程.</p><h1 id="自媒体-社交网络导致的-评论信息爆炸"><a href="#自媒体-社交网络导致的-评论信息爆炸" class="headerlink" title="自媒体, 社交网络导致的[评论信息爆炸]"></a>自媒体, 社交网络导致的[评论信息爆炸]</h1><p>由于大家都用得上手机, 用得上网的当下, 导致了如今[评论信息爆炸]的现象, 成为了舆论的核心地</p><p>表面看上去体现了言语自由权, 但是当下我却感觉过于自由而常常觉得需要进行政府管理</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>细说mysql分页系统(入门篇, 本篇主要是网上一些方法的搜集和验证)</title>
      <link href="/2019/08/28/mysql-pagination-optimization-1/"/>
      <url>/2019/08/28/mysql-pagination-optimization-1/</url>
      
        <content type="html"><![CDATA[<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>分页优化是最常见问题之一, 针对日宜扩大的业务数据, 分页优化是数据库查询优化中的一个必经环节. 目前虽然我负责的项目日流量不大, 每天2000+订单量, 但是已经开始后怕后期的数据库查询响应速度, 由于并不是什么互联网公司, 所以在分页这块依旧停留在<code>limit</code>,<code>offset</code>上, 公司内部并没有成型的分页优化方案 ,对于几十万的数据量来说, 它们是可以忍受的, 事实上低于1s的查询速度都是我可以接受的, 但是随着数据量的加大, 特别是数据量超过100w往上走, 达到千万级别的时候, <code>limit</code>的方式则需要更多的辅料才能勉强达到不分表,同时有一个较小的查询时间. </p><p>本系列旨在研究mysql分页优化而开展的, 本篇为基础篇, 即我不会引入具体的业务场景, 而是简单的在一个千万级别的测试表上, 进行一些特别不靠谱的基准测试, 最终得出一个基本结论(干货不会很多)</p><p>部分单词含义说明:<br><code>total</code> 总数据量<br><code>pageSize</code> 每页大小<br><code>pageTotal</code> 是(total / pageSize)向上取整</p><h1 id="分页优化基础-keyset-pagination"><a href="#分页优化基础-keyset-pagination" class="headerlink" title="分页优化基础 - keyset pagination"></a>分页优化基础 - keyset pagination</h1><p>keyset pagination应该是任何数据库分页的最快解决方案, 但是无法做到跳页, 只能提供上一页,下一页功能</p><p>详情请参考:<br><a href="http://allyouneedisbackend.com/blog/2017/09/24/the-sql-i-love-part-1-scanning-large-table/" target="_blank" rel="noopener">http://allyouneedisbackend.com/blog/2017/09/24/the-sql-i-love-part-1-scanning-large-table/</a></p><h1 id="分页优化基础-Maintain-a-Page-or-Place-column"><a href="#分页优化基础-Maintain-a-Page-or-Place-column" class="headerlink" title="分页优化基础 - Maintain a Page or Place column"></a>分页优化基础 - Maintain a Page or Place column</h1><p>可以在你的表中为每行单独维护一个<code>page</code>列, 比如前100行都是<code>page=1</code>, 代表前100个数据都是第一页, 以此类推(给page加个索引)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, <span class="keyword">name</span>, address, phone</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> page = <span class="number">1</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><p><strong>[缺点]</strong>:<br>这个方案可以执行的前提:</p><ul><li><code>pageSize</code> 不变</li><li>表中的数据只增不减</li></ul><h1 id="分页优化深入-水平切分优化"><a href="#分页优化深入-水平切分优化" class="headerlink" title="分页优化深入 - 水平切分优化"></a>分页优化深入 - 水平切分优化</h1><p>根据现有业务按列分表,将用于排序的列数做最小拆分，尽量不要有大规模字符串,查询后用 in(ids)方式聚合 </p><p>实施起来复杂, 增加了不少工作量, 不建议使用</p><h1 id="分页优化的小聪明-反转-效果不明显-谨慎使用"><a href="#分页优化的小聪明-反转-效果不明显-谨慎使用" class="headerlink" title="分页优化的小聪明 - 反转 (效果不明显,谨慎使用)"></a>分页优化的小聪明 - 反转 (效果不明显,谨慎使用)</h1><blockquote><p>利用Order来反转查询, </p></blockquote><p>就拿我前面的例子来说, 我有如下查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> Merchant_1000w <span class="keyword">where</span> createTime=<span class="number">347446113</span> <span class="keyword">limit</span> <span class="number">9000000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure></p><p>直接查900 0001开始的数据, 但是我们知道表目前只有1000w条数据, 所以 这时候为何不先逆向排序, 然后从100 0000开始查呢?</p><p>我们稍微修改下sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> Merchant_1000w <span class="keyword">where</span> createTime=<span class="number">347446113</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">DESC</span> <span class="keyword">limit</span> <span class="number">1000000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>效果不是很明显, 但是普遍加快了100ms左右</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我还记得去年写过oracle的批量插入随机数据的脚本,今天补个mysql的吧</title>
      <link href="/2019/08/27/mysql-batch-insert-1/"/>
      <url>/2019/08/27/mysql-batch-insert-1/</url>
      
        <content type="html"><![CDATA[<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>银行项目一直用的oracle, 所以我回忆起来自己从来没碰过mysql的批量随机数据插入…</p><p>主要是简单记录下批量插入的方式, 会有一个优化的过程, 希望对你有点帮助哦</p><p>下面我就讲解如何插入100w条随机测试数据到mysql中</p><h1 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- drop table Merchant</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Merchant</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> auto_increment,</span><br><span class="line">    merchantId <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'10位商户编号'</span>,</span><br><span class="line">    merchantName <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'商户名称'</span>,</span><br><span class="line">    createTime <span class="built_in">VARCHAR</span>(<span class="number">12</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'创建时间'</span>,</span><br><span class="line">    <span class="keyword">constraint</span> Merchant_pk</span><br><span class="line">        primary <span class="keyword">key</span> (<span class="keyword">id</span>)</span><br><span class="line">) <span class="keyword">comment</span> <span class="string">'商户表'</span>;</span><br></pre></td></tr></table></figure><h1 id="存储引擎的配置进行优化"><a href="#存储引擎的配置进行优化" class="headerlink" title="存储引擎的配置进行优化"></a>存储引擎的配置进行优化</h1><p>可以见:<br><a href="https://blog.csdn.net/QWERDF10010/article/details/79770764" target="_blank" rel="noopener">https://blog.csdn.net/QWERDF10010/article/details/79770764</a></p><h1 id="insert语句优化"><a href="#insert语句优化" class="headerlink" title="insert语句优化"></a>insert语句优化</h1><p>先来看看最暴力的插入</p><ol><li>包含100w条数据的爆炸sql :)</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 100w条insert语句</span></span><br><span class="line"><span class="keyword">insert</span> (...) <span class="keyword">values</span> (...);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">..</span><br><span class="line">.</span><br></pre></td></tr></table></figure><p>这种形式,就算MyISAM都救不了你, 按下回车后你就可以去睡一觉了, 醒来说不定就好了,嘻嘻</p><ol start="2"><li>存储过程 写个循环100w次的插入</li></ol><p>这种其实和第一种性质一样, 也是巨慢无比的.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> batchInsert()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> <span class="keyword">num</span> <span class="built_in">int</span>;</span><br><span class="line">    <span class="keyword">set</span> <span class="keyword">num</span>=<span class="number">1</span>;</span><br><span class="line">    while num&lt;=1000000do</span><br><span class="line">    <span class="comment">-- 100w次loop</span></span><br><span class="line">    <span class="keyword">insert</span> (...) <span class="keyword">values</span> (...);</span><br><span class="line">    <span class="keyword">set</span> <span class="keyword">num</span>=<span class="keyword">num</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">//</span><br><span class="line">delimiter;</span><br></pre></td></tr></table></figure><p>看完了暴力的,就来看看怎么优化.</p><p>其实优化很简单, 有一种特别简便的方式就可以达到插入速度提升几百倍, 就是使用批量插入的功能</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> (xxx) <span class="keyword">values</span>(...),(...),(...),(...),(...) ....;</span><br></pre></td></tr></table></figure><p>你可以像上面这样, 一次插入几百条.<br>然后你就会惊人的发现, 真的很快, 100w条数据大概30多s左右(不同机器环境稍微会不同)就可以完成,由于30s左右已经是我可以接受的范围了. 所以就停手不进行下一步优化, 如果你还是有一点深入的兴趣, 可以看看<a href="https://www.jianshu.com/p/36b87cb3a05a" target="_blank" rel="noopener">这篇文章</a></p><h1 id="随机数据如何处理"><a href="#随机数据如何处理" class="headerlink" title="随机数据如何处理?"></a>随机数据如何处理?</h1><p>你可以使用sql的函数,也可以用任意高级编程语言生成sql文件, 这样你就可以接住高级编程语言的一些api去做随机数据的处理了</p><p>如果你和我一样,希望统一用sql帮我们干事, 那么目前来看<code>rand()</code>, <code>floor()</code>等函数适合你, 但是注意多一个函数就相当于sql慢一点哦 :)</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> batchInsert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu18.04设置lock-screen存在的一个坑</title>
      <link href="/2019/08/25/why-i-cannot-see-all-pics-in-pictures-panel-when-i-set-lock-screen/"/>
      <url>/2019/08/25/why-i-cannot-see-all-pics-in-pictures-panel-when-i-set-lock-screen/</url>
      
        <content type="html"><![CDATA[<p>当你在用使用ubuntu18.04的时候, 你发现背景图片(backgroud),锁屏背景图片(lock-screen)还有输入密码时候的背景图片(login-screen)是分开的,也就是说需要分开设置</p><p>而设置背景图片可以直接通过右键”Set As WallPaper”来快速修改, 但是锁屏背景图片(也就是lock-screen)最快捷的方法就是在Settings-&gt;backgroud-&gt;lock screen进行修改,</p><p>在弹出来的对话框内, 有系统自带的图片, 你也可以选择自己的图片, 但是存在一个问题, ubuntu会将你Picture根目录下的图片显示出来供你选择, 但是它会忽略由系统截图工具产生的图片</p><p>ubuntu后台会有如下日志打印:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gnome-control-center:5886): background-cc-panel-DEBUG: 00:24:13.369: Ignored URL &apos;file:///home/zazalu/Pictures/xxx.png&apos; as it&apos;s a screenshot from gnome-screenshot</span><br></pre></td></tr></table></figure><p>这个设定我觉得问题很大….而且不会做任何有效提示…. 使用者会感觉非常懵逼(比如我)</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bugs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>火焰最虚弱的那一瞬间</title>
      <link href="/2019/08/24/one-day-i-lost-all-my-Memory-but-i-just-laugh-at-last/"/>
      <url>/2019/08/24/one-day-i-lost-all-my-Memory-but-i-just-laugh-at-last/</url>
      
        <content type="html"><![CDATA[<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>Google推出新操作系统Fuchsia…<br>华为推出鸿蒙OS…<br>xxx荣获xxx…<br>…<br>..<br>.</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>我觉得人的内心确实可以比拟成一把火焰, 而公司则是一个小小火焰的集合体</p><p>有些人是火苗, 是火种.</p><p>但是很不幸的是, 我也许只是燃料</p><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>燃料存在缺点, 那就是会耗尽</p><p>燃料也有个优点, 那就是存在很多的替代品, A燃料用尽了, 可以拿B燃料换上</p><p>也许一开始系统不太适应B燃料, 会排出一些低劣气体, 但是经过一段时间的磨合, 火炬依旧会闪闪发光</p><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>“你能看到我的火焰吗?”</p><p>我瞄一眼, 我也许看错了, 以为那是光</p><p>我深看一眼, 这次我看准了, 它是一团火焰, 在大街上, 形形色色的人类看过去, 那都是不同的火焰在燃烧</p><p>有些人, 眼看着火焰就要熄灭了</p><p>这时候我看到有个人凑了过去, 我非常开心, 因为我看到了那团火焰重新冉冉发光了</p><h1 id="5"><a href="#5" class="headerlink" title="5"></a>5</h1><p>可怕, 我竟然写不出任何感受.</p><p>2019年08月24日23:08:04 晚安</p><p><img src="/images/tmpImage/dongfang.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当你不得不在SpringBoot2中使用jedis的时候</title>
      <link href="/2019/08/15/spring-boot-2-0-use-jedis/"/>
      <url>/2019/08/15/spring-boot-2-0-use-jedis/</url>
      
        <content type="html"><![CDATA[<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>当我把上一个项目的代码功能模块,原封不动的移到某银行内网的一个小项目中去的时候,发现java7不支持使用Lettuce,爆了一大堆错(汗)</p><p>看来Lettuce用了很多java8特性并且没有做兼容</p><p>所以就google下, 最偷懒的方式就是改用jedis, 虽然它是线程不安全的, 但是自己封装点控制代码也无妨</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><blockquote><p>maven配置</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;exclusions&gt;</span><br><span class="line">&lt;exclusion&gt;</span><br><span class="line">&lt;groupId&gt;io.lettuce&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;</span><br><span class="line">&lt;/exclusion&gt;</span><br><span class="line">&lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>[注意]</strong>: 建议用spring-boot-starter-data-redis, 因为看xml配置, spring-data-redis已经包含在starter里面了,别重复定义</p><p><strong>[注意]</strong>: 必须先移除lettuce依赖,不然会报错,感觉肯定是坑,因为官方给出的报错提示和解决方案根本不对应= =</p><blockquote><p>编程式配置</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function">JedisConnectionFactory <span class="title">jedisConnectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RedisStandaloneConfiguration redisStandaloneConfiguration =</span><br><span class="line">                <span class="keyword">new</span> RedisStandaloneConfiguration(hostName, port);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JedisConnectionFactory(redisStandaloneConfiguration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title">redisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String,Object&gt;  template = <span class="keyword">new</span> RedisTemplate&lt;String,Object&gt; ();</span><br><span class="line">        template.setConnectionFactory(jedisConnectionFactory());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为RedisTemplate配置序列化策略,这样我就不用自己做序列化反序列化了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）</span></span><br><span class="line">        Jackson2JsonRedisSerializer jacksonSeial = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line"></span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        <span class="comment">// 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public</span></span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        <span class="comment">// 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常</span></span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jacksonSeial.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 值采用json序列化</span></span><br><span class="line">        template.setValueSerializer(jacksonSeial);</span><br><span class="line">        <span class="comment">//使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置hash key 和value序列化模式</span></span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        template.setHashValueSerializer(jacksonSeial);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>至于序列化,你可以自己搞,也可以像我这样交给RedisTemplate去搞,它有做封装,进行下配置即可(说实话配置有够多的= =)</p><blockquote><p>使用</p></blockquote><p>在test类中试试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User userVo = <span class="keyword">new</span> User();</span><br><span class="line">    userVo.setId(<span class="number">1</span>);</span><br><span class="line">    userVo.setName(<span class="string">"hello"</span>);</span><br><span class="line">    ValueOperations&lt;String, Object&gt; operations = redisTemplate.opsForValue();</span><br><span class="line">    operations.set(<span class="string">"user1"</span>, userVo);</span><br><span class="line"></span><br><span class="line">   User cacheUser = (User) operations.get(<span class="string">"user1"</span>);</span><br><span class="line">   logger(cacheUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考</h1><p><a href="https://www.concretepage.com/questions/599" target="_blank" rel="noopener">移除lettuce坑</a><br><a href="https://www.devglan.com/spring-boot/spring-boot-redis-cache" target="_blank" rel="noopener">SpringBoot2中redis简单使用</a><br><a href="https://www.cnblogs.com/superfj/p/9232482.html" target="_blank" rel="noopener">还算不错的redis使用分享贴,我部分代码直接摘抄了</a></p>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在我眼里的mysql与redis的区别</title>
      <link href="/2019/08/14/mysql-redis-diff-in-my-eyes/"/>
      <url>/2019/08/14/mysql-redis-diff-in-my-eyes/</url>
      
        <content type="html"><![CDATA[<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>redis可以你当做nosql内存数据库用, 而mysql是我们耳熟能详的关系型数据库.</p><p>关于他们之间的区别, 你google一下, 一大堆一大堆的分析, 那些词汇看的我天花乱坠, 仿佛把redis吹上了天.</p><p>不过我发现大家好像都忘记了一个在实际开发中更容易想到的优点. 我接下来就来说说</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>和oracle不一样,mysql不存在什么序列锁,所以写代码的时候要非常小心并发问题带来的数据异常. 不过这些对于现在的java社区来说已经不成问题. spring框架对数据库的事务支持相当的优雅, 我们只需一点点配置,就可以精确的控制事务的范围,事务的级别.</p><p>但是我们退一步想,如果因为一些原因,公司需要开发自己的IOC容器,AOP框架这些玩意. 这时候,我们就没法偷懒了. 事务控制这些就必须自己写.</p><p>我前面也说了和oracle不同,oracle存在一种叫序列锁的东西,所以在编写代码的时候,做一点点的同步控制, 就可以有效防止因数据一致性问题引发的数据异常问题</p><p>直到现在为止, 最新的mysql8, 使用默认的事务级别REPEATABLE-READ , 在多线程同时执行读写的情况下,依旧会发生这类问题. 有疑问的可以自己去测试下,开两个mysql客户端,然后同时开启事务A和B, 在A事务中更新一个flag值,在B事务中flag值依旧是旧的. 这会导致代码中if判断的逻辑和业务不符.</p><p>不过这并不怪mysql, 因为mysql官方对于事务级别REPEATABLE-READ并不提供这方面的解决方案,因为它们已经有了串行化事务级别.</p><p>但是由于硬盘IO效率低, 使用串行化, 发生堵塞最后影响性能是必然的, 所以现在都是用高级语言去进行同步控制, 会比mysql自己处理性能更好.</p><p>但是redis单线程架构+内存操作速度快, 故事就不一样了, 可以说省了不少事,下一节慢慢说</p><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>上一节我吐槽了一些mysql同步控制相关的话题, 我的意思是使用mysql的时候, 为了达到完美使用的目的, 必须配合高级语言的锁机制去实现, 使得我们开发人员要多操心一些东西.</p><p>这一节我就来说说redis的一个好处, 它让我们少操心了很多事情.</p><p>redis的最大特点是它是单线程架构, emmm, 这不是重点…  </p><p>redis的最大特点是它提供了一些原子性的指令!  </p><p>那么事情就变得简单了, 有一些简单的计数器场景下, 我们对计数+1操作, 都不需要去做任何的事务控制, 同步控制.  不同的客户端同时发送递增原子性指令,比如<code>incr</code>, 到达redis后, 被redis消息队列接受,随后被redis一个个依次执行! 最后我们得到的数据也不会出错</p><p>不过这个情况是符合直接使用这些原子性指令的时候,如果你中间参杂了其他非原子性指令, 比如你先get一个数据,再做增1. 那原子性结构就被破坏了, 数据一致性问题依旧会发生 请注意哦!</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实说了半天, 我想说的就是redis提供了一些原子性指令,对于一些简单的计数器场景, 减少了我们需要的代码量去控制, 这些事情都由redis帮我们完成了</p><p><strong>[注意]</strong>: 非原子性指令依旧需要进行同步控制, 请注意, 本文只针对redis的原子性指令而言, 节省了不少业务层代码量去控制</p>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>既然自己懒得搞那就只好认真摸索别人的了-被一些人诟病的mybatis二级缓存</title>
      <link href="/2019/07/31/mybatis-level-2-cache-global-i/"/>
      <url>/2019/07/31/mybatis-level-2-cache-global-i/</url>
      
        <content type="html"><![CDATA[<h1 id="1-简单介绍"><a href="#1-简单介绍" class="headerlink" title="1 简单介绍"></a>1 简单介绍</h1><p>mybatis是javaweb开发再熟悉不过的orm框架。没有公司内部自研的orm框架的话，我见过的基本现在都走mybatis或者spring-jpa</p><p>为了加速查询，减少数据库I/O次数，我们都需要缓存这玩意来辅助我们存储一些数据在内存中，利用内存查询速度很快的特点，来让我们的读操作耗时更短。</p><h1 id="2-吐槽PerpetualCache"><a href="#2-吐槽PerpetualCache" class="headerlink" title="2 吐槽PerpetualCache"></a>2 吐槽PerpetualCache</h1><p>我最近经常听人吐槽mybatis的缓存机制（无中生有？），并会在生产上停用其缓存功能，加入额外的(分布式)缓存中间件来自定义控制系统的缓存处理。</p><p>mybatis的缓存一路走来，已经从一开始的小小的基本缓存模块，到现在已经变成了一个相当健壮的缓存模块，已经提供了自定义缓存接口，来自定义改变mybatis的缓存策略(虽然还是不够灵活)。</p><p>其一级缓存(local cache)是默认使用的，同一个sqlsession使用一个Cache实例，不同的sqlsession使用的是不同的Cache实例。故其细粒度只到sqlsession。结合了ioc容器，比如spring后，这个缓存确实几乎变成了鸡肋。因为现在编程思想趋向于模块化，功能单一化，所以在一次请求范围内，同一个sqlsession能缓存到的数据少之又少（假设不使用分布式或者单机缓存中间件）</p><p>既然一级缓存几乎团灭，那么mybatis还有什么防线呢？二级缓存(2nd cache)</p><p>mybatis的二级缓存最显著的特点是可以让不同的sqlsession共享同一个Cache实例，细粒度到达命名空间级别(namespace)，也就是说同一个Mapper内的所有curd操作会被同一个Cache管理，不管你使用的是不是同一个sqlsession。</p><p>表面上看上去可以让人发出<code>哇哦</code>的声音，但是一用起来，还是很<code>sad</code>的。</p><p>由于根据业务逻辑，代码都是分模块的，所以我们有超多个Mapper来对应不同的表结构。于是鸡肋的一点依旧发生了，A_Mapper的修改不会刷新B_Mapper的缓存数据，导致缓存数据变成了<code>dirty data</code>，╮(╯▽╰)╭真的惨</p><h1 id="3-挽救"><a href="#3-挽救" class="headerlink" title="3 挽救"></a>3 挽救</h1><p>很多人看到到这里应该也开始想放弃使用mybatis二级缓存，或者借助mybatis提供的自定义缓存接口，来改变mybatis策略，使用一些分布式缓存系统来控制mybatis的缓存。不过由于小项目是真的没必要上完整的缓存中间件的，所以默认存在的PerpetualCache还是挺香的。可是我前面也说了，二级缓存最大的毛病就是细粒度只到命名空间(namespace)，而我们正常的应用场景是需要一个全局缓存实例。那么该怎么玩呢？</p><p>查看mybatis3的文档，在cache的最角落里有一个小小的功能存在着。<code>cache-ref</code>功能。文档对它的描述真的非常短小精湛，而且是在最底下。</p><p>接下来我就说下如何使用它来实现一个简单的全局缓存实例</p><h1 id="4-实验"><a href="#4-实验" class="headerlink" title="4 实验"></a>4 实验</h1><p>本实验源码不开放了，大家看看结果就好，不懂可以回复我慢慢解答。（懒得整一份单独的代码出来！）</p><blockquote><p>先来测试下默认的二级缓存的细粒度是否是namespace</p></blockquote><p>我们执行两个Mapper方法，<br>一个是<code>LikeMapper</code>的<code>inserts</code>方法，更新方法，会刷新缓存<br>一个是<code>MessageMapper</code>的<code>selects</code>方法，查询方法，会利用到<code>LikeMapper</code>中的表数据进行查询<br>两者在不同的namespace中，所以<code>inserts</code>方法的执行不会刷新另一个方法所在的缓存空间</p><p>OK，接下来我按<code>selects</code>-&gt;<code>inserts</code>-&gt;<code>selects</code>的顺序来执行，我们的预期目的是：第二次<code>selects</code>方法依旧从缓存中取数据</p><p>下面是日志打印，<br><img src="/images/tmpImage/mybatis_level_2.png"></p><p>第二次selects的打印可以看出，依旧会从缓存中获取数据验证了，确实默认的二级缓存细粒度是只到namespace的</p><blockquote><p>使用cache-ref来使得两个Mapper使用同一个Cache实例</p></blockquote><p>在LikeMapper中如下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;LikeMapper&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--选择一个Namespace作为主namespace，其余Mapper全部使用cache-ref引用此Cache--&gt;</span><br><span class="line">&lt;cache/&gt;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></p><p>在MessageMapper中如下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;LikeMapper&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;cache-ref namespace=&quot;LikeMapper&quot;/&gt;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></p><p>随后，我们在按顺序执行一次刚刚的方法，下面是日志打印<br><img src="/images/tmpImage/mybatis_level_2_global.png"></p><p>可以看到，第二次select依旧执行了sql语句，证明了不同namespace的Mapper都使用了同一个cache</p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p>通过cache-ref可以间接的实现全局缓存实例的效果，从而解决目前常常遇到的一类缓存数据脏读问题而不得不抛弃mybatis二级缓存功能的现象</p><div id="donationPoint"><div id="licensePoint"></div></div>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在SpringBoot中使用运行时参数注入到多例Bean中的一个简单解决方案</title>
      <link href="/2019/07/26/hot-to-use-runtime-param-to-init-a-prototype-bean-in-spring/"/>
      <url>/2019/07/26/hot-to-use-runtime-param-to-init-a-prototype-bean-in-spring/</url>
      
        <content type="html"><![CDATA[<h1 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h1><p>在某些情况下，我希望我的Bean是多例的(大部分正常情况下Bean单例足矣)，因为这个Bean有一个状态变量，每次我希望它在new的时候可以初始化为不同的值，这个值取自运行时。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>直接采用set的方式？ 不可行，由于IOC容器高度管理化，想在Spring框架下做如此open的操作是不行的，因为你能操作的只是代理类罢了。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol start="0"><li>为你的Bean创建一个带参构造器(用于赋予运行时参数)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Bean</span><span class="params">(String args1, String args2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.field1 = args1;</span><br><span class="line">    <span class="keyword">this</span>.field2 = args2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在你的控制器层获取IOC容器(调用非默认注入方法的途径)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ApplicationContext applicationContext;</span><br></pre></td></tr></table></figure><ol start="2"><li><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactory.html#getBean-java.lang.String-java.lang.Object...-" target="_blank" rel="noopener">借助BeanFactory的getBean(String name,Object… args)</a></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">applicationContext</span><br><span class="line">    .getBean(<span class="string">"bean"</span>,</span><br><span class="line">    args1,</span><br><span class="line">    args2));</span><br></pre></td></tr></table></figure><h1 id="支持版本"><a href="#支持版本" class="headerlink" title="支持版本"></a>支持版本</h1><p>Spring 4+</p><h1 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h1><p>Spring对于这一块的支持代码不够优雅，或者说有更好的方式，只不过我没发现？</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bugs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算相关产品扫盲_概念说明</title>
      <link href="/2019/07/14/what-is-cloud-service-1/"/>
      <url>/2019/07/14/what-is-cloud-service-1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-域名-Domain-Name"><a href="#1-域名-Domain-Name" class="headerlink" title="1 域名 Domain Name"></a>1 域名 Domain Name</h1><p>就好比人类更容易记忆住画面内容而不是文字内容一样，ip地址的”图形化”表示方式就是域名(早期最常见的顶级域名.com,有关域名的分级请自行查阅)</p><p>域名是要有域名系统(DNS)才能正常运作的,域名系统负责解析域名并转换为ip地址</p><p>根据地域的不同，域名注册后可能还需要(中国内陆)</p><ol><li>域名实名认证(备案的前提)</li><li>域名备案(用于访问国内服务器是必须的,不然会被国内DNS拦截)</li></ol><blockquote><p>为什么需要实名认证,为什么需要备案</p></blockquote><p>如果发现你的网站违法，那么可以立即把你的网站网线”拔了”，减少对社会的”伤害”</p><blockquote><p>为什么我的域名不需要备案，就只完成了注册,实名认真和解析就可以正常使用</p></blockquote><p>因为你的域名解析到的是大陆境外服务器，那些是不需要备案的，毕竟政府没法管这些</p><h1 id="2-数据集成"><a href="#2-数据集成" class="headerlink" title="2 数据集成"></a>2 数据集成</h1><p>大数据相关，简单来说，就是系统化的数据存储方式，提供数据存储，数据计算，数据展示等相关功能(我不太熟悉,但是扫下盲感觉够了。。)</p><h1 id="3-云效-alibaba"><a href="#3-云效-alibaba" class="headerlink" title="3 云效(alibaba)"></a>3 云效(alibaba)</h1><p>很像公司内部的项目管理系统，可以提需求，提优化，提bug，然后显示进度等等，把项目开发整成一个标准的流水线，然后大家有一个管理后台可以加快项目开发速度。同时它附带了各类”流水线“开发工具。 </p><p>先把它当做一个公网上比较好看美观实用安全的项目管理系统吧。。。</p><h1 id="4-云数据库"><a href="#4-云数据库" class="headerlink" title="4 云数据库"></a>4 云数据库</h1><p>由于部署数据库以及运维的成本是比较高的，很多公司可能不想在上面花费太多资源，所以随着云计算的发展，云数据库的成熟方案也是越来越多。相比于自己花时间花精力去搞这些，确实找个云数据库会更靠谱，毕竟人家还提供集群，读写分离，优秀的备份方案等等</p><h1 id="5-专有网络"><a href="#5-专有网络" class="headerlink" title="5 专有网络"></a>5 专有网络</h1><p>可以看成是一个专属私有云计算平台</p><h1 id="6-Elasticsearch-（系统数据量上了10亿、100亿条）"><a href="#6-Elasticsearch-（系统数据量上了10亿、100亿条）" class="headerlink" title="6 Elasticsearch （系统数据量上了10亿、100亿条）"></a>6 Elasticsearch （系统数据量上了10亿、100亿条）</h1><p>现如今用Elasticsearch做搜索服务器是不错的选择，我用过一段时间，体验上查询确实很快，但是Elasticsearch服务在搭建过程中(从原始数据库做数据导入)，要花很久时间去构建，不知道是不是我姿势问题、</p><p>构建完毕后，做一些查询那个速度肉眼可识别的快呢。</p><p>适合场景：全文搜索</p><h1 id="7-云服务器ECS"><a href="#7-云服务器ECS" class="headerlink" title="7 云服务器ECS"></a>7 云服务器ECS</h1><p>我们常说的云服务器单元就是这个了，包含了大量的IT基础设施。</p><h1 id="8-轻量应用服务器"><a href="#8-轻量应用服务器" class="headerlink" title="8 轻量应用服务器"></a>8 轻量应用服务器</h1><p>ECS的简约版，做了一点封装，用起来更方便，对新手更友好一点，适合用于个人博客等小型网站。</p>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript操作浏览器cookie容易发生的Path问题</title>
      <link href="/2019/07/13/javascript-setCookie-path/"/>
      <url>/2019/07/13/javascript-setCookie-path/</url>
      
        <content type="html"><![CDATA[<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>cookie已经是熟的不能再熟悉的东西，常常用于一些B和S会话管理的场景</p><p>JavaScript提供了一些好用的cookie api供我们使用(我自己测试用的原生的，你如果使用的是别的js库操作，比如npm上的库，那么和本文无关)，比如<code>document.cookie</code></p><p>我们在使用的时候，最关注的是key和value，但是可能会忽略几个比较重要的东西，下面讲</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>cookie按照host和path进行了分类，默认的path是当前web访问路径，那么如果你在不同路径下操作cookie，就会发生生成了好多份key和value相同的拷贝，这是因为它们的path不一样，导致cookie删除api执行逻辑和你的预期不符导致</p><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>最简单的方法是指定path，我认为不错的写法是指定path为<code>/${ApplicationContext}</code>路径即可,或者干脆点指定为<code>/</code>，因为host每个网站是不同的，所以不会影响到其他站点cookie</p>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库中的时区转换</title>
      <link href="/2019/07/12/database-timestamp-timezone-notice/"/>
      <url>/2019/07/12/database-timestamp-timezone-notice/</url>
      
        <content type="html"><![CDATA[<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>在我接触过的项目中，存储时间基本都是使用变长字符串按照<code>yyyyMMdd</code>等类似格式存储的，而不是使用<code>datatime</code>或者<code>timestamp</code>这些数据库提供的时间类型进行存储</p><p>这样使用有好有坏，根据项目情况选择使用。</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>我长期维护的项目都是采用前者，也就是存储字符串<code>yyyyMMdd</code>。</p><p>所以最近遇到一个用了<code>timestamp</code>存储创建时间的情况，在我自己电脑的测试环境下进行单元测试的时候，我发现每次我存储的时间都会存在10多个小时的时差。 当时由于几乎没遇到过这种情况，所以我没想到原理上出了什么问题。后来才得知是<code>timestamp</code>会做时区转换。</p><h1 id="为什么要做时区转换？"><a href="#为什么要做时区转换？" class="headerlink" title="为什么要做时区转换？"></a>为什么要做时区转换？</h1><p>因为人家存的是一个时间戳(long)，显示的时候为了好看点，就按照默认时区做了转换。如果默认时区和你所在时区不一致，转换就出问题，导致每次都有时差</p><h1 id="怎么纠正这种坑"><a href="#怎么纠正这种坑" class="headerlink" title="怎么纠正这种坑"></a>怎么纠正这种坑</h1><p>很简单，修改数据库的默认时区即可。网上攻略很多，不谈了。我们要知道原理是因为时区的即可。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端分离之跨域问题以及curl在web测试上的应用</title>
      <link href="/2019/06/30/CORS-question-and-curl-use-in-web-test/"/>
      <url>/2019/06/30/CORS-question-and-curl-use-in-web-test/</url>
      
        <content type="html"><![CDATA[<p>前后端分离已经不稀奇了，今天我就稍微讲一下前后端分离后在数据对接上容易出现的跨域问题。</p><h1 id="问题何时发生"><a href="#问题何时发生" class="headerlink" title="问题何时发生"></a>问题何时发生</h1><p>发起一次http请求的时候，若源域名和目标域名(或者ip和端口不一致)不同，则目前大多数服务器都会拒绝响应此http请求。</p><p>你会遇到类似如下的http报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at ....</span><br><span class="line">No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource</span><br></pre></td></tr></table></figure><p>因为这种请求属于跨域请求，在web服务器的通用实现方式上，默认的它们被设置为拒绝跨域请求。</p><h1 id="2-通常解决方法"><a href="#2-通常解决方法" class="headerlink" title="2 通常解决方法"></a>2 通常解决方法</h1><p>于是我们第一时间想到的是开启跨域请求。</p><p>先不提开启跨域请求的风险（在javaweb的Model框架中，一般可以使用contants+javaconfig来控制测试环境和生产环境的跨域的开启和关闭）</p><p>开启跨域请求是双向的，首先在请求头中我们必须使用相关header去表示本次请求为跨域请求，其次是服务端开启跨域访问，最重要的一个header域是<code>Access-Control-Allow-Origin</code></p><p>最暴力的做法：<code>&#39;Access-Control-Allow-Origin&#39;： &#39;*&#39;</code><br>这样你的服务器就可以支持所有域名的跨域访问，接受一切</p><p>不过一般我们肯定不希望服务器暴露太多，所以可以根据自己的情况适当调整</p><p>此外，请求端(通常使我们的ajax调用端)，也需要带上跨域的相关header来供后端验证</p><h1 id="3-当被拒绝跨域的时候"><a href="#3-当被拒绝跨域的时候" class="headerlink" title="3 当被拒绝跨域的时候"></a>3 当被拒绝跨域的时候</h1><p>很多人可能都没留意到一个细节，所有POST的跨域请求，如果服务器不支持跨域，那么你的POST请求可能没有发出去就死在了摇篮里。</p><p>因为在HTTP请求规范中，POST请求之前先发送的是OPTIONS请求，用于做一些验证操作</p><p>OPTIONS请求被服务端拒绝跨域，POST请求就根本没必要发送了。</p><h1 id="4-使用curl做简单的http测试"><a href="#4-使用curl做简单的http测试" class="headerlink" title="4 使用curl做简单的http测试"></a>4 使用curl做简单的http测试</h1><p>curl是一个文件下载工具，但是我更喜欢把它当做一个功能全面的http工具</p><p>我们可以通过curl来做一些简单的http测试</p><p>这里我简单的举个例子:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST -v -d '&#123; "test": "abc123" &#125;' -H "Content-type: application/json" http://localhost:8080/MyBelfast/crew/login</span><br></pre></td></tr></table></figure></p><p>可以测试<code>http://localhost:8080/MyBelfast/crew/login</code>是否支持接受json数据</p><h1 id="5-尾"><a href="#5-尾" class="headerlink" title="5 尾"></a>5 尾</h1><p>本文提到的跨域问题会常常会在前后端开发阶段中出现，生产上是比较少的。在开发阶段，前端和后端的测试服务器往往被部署在不同的端口，这就会使得两者的http连接是跨域的</p><p>有关跨域访问的事情还远远不止本文所讲的这一些，只不过本文的问题是最容易出现的问题，也是最低级的问题</p><p>参考：<br><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-cors" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-cors</a></p>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域访问 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java乱码问题之URLEncoder和URLDecoder</title>
      <link href="/2019/06/24/JavaEncoded3/"/>
      <url>/2019/06/24/JavaEncoded3/</url>
      
        <content type="html"><![CDATA[<h1 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h1><p>关于编码，我曾经写过了2篇文章。在我个人运用来看，前两篇分享的知识已经足以去理解所有编码问题发生的根源问题。</p><p>那么为什么我今天又写了这篇文章呢？</p><p>接触过Web项目的同学，肯定对URLEncoder和URLDecoder，我们常常用这两个类来处理部分遇到的问题。</p><p>在早些时候，我个人还没理解透这块知识的时候，我以为下面的2句java表达式的背后机制是差不多的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">String encodeUrl = URLEncoder.encode(url,<span class="string">"utf-8"</span>);</span><br><span class="line">String decoderUrl = URLDecoder.decode(encodeUrl,<span class="string">"utf-8"</span>);</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">new</span> String(s.getBytes(<span class="string">"gbk"</span>),<span class="string">"utf-8"</span>)</span><br></pre></td></tr></table></figure><p>后来，我分享了 <a href="https://zazalu.space/2019/06/15/Java%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%E4%B8%80%E8%AF%AD%E9%81%93%E7%A0%B4-GBK-UTF%E7%AD%89%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A0%81/">我编码的第二篇文章</a><br>后我懂得了Stirng的那个表达式是做了如下的转换逻辑：<br>Unicode String  -&gt;  根据传入的编码规则将Unicode转换为了Bytes[]  -&gt;  使用utf-8的编码规则去将Bytes[]变成Unicode字符</p><p>总的来说String的这种方式是字符到字节再到字符的转换，其内部的Unicode字符的内容是会根据你的编码规则使用是否正确会改变的，使用的不当，结果还是乱码XS</p><p>但是在URLEncoder和URLDecoder的应用领域，它们干的事情和我对“编码”的一般理解是有区别的，下面我来细讲</p><h1 id="URLEncoder和URLDecoder"><a href="#URLEncoder和URLDecoder" class="headerlink" title="URLEncoder和URLDecoder"></a>URLEncoder和URLDecoder</h1><blockquote><p>我更愿意说URLEncoder和URLDecoder做的事情叫“字符转换”而不是“编码”，其内部包含了“编码”的操作，但不仅仅只有“编码”操作</p></blockquote><p><strong>我们先拿URLEncoder说事</strong></p><p>假设你收到一个URL数据如下<br><code>String url = &#39;http://localhost:8080/examples/servlets/servlet/镓钧?author=镓钧&#39;</code></p><p>但是带中文的URL在不同的程序解析下容易出现乱码问题最终导致数据丢失，所以为了不出现此类问题，URL规范使用utf-8（实际上不同地方规范不同，只不过现如今我们更推荐只使用utf-8）将这些中文字符转换为16进制表示的字符<br>如下所以：</p><p><code>Stirng encodeUrl = &#39;http://localhost:8080/examples/servlets/servlet/%E9%95%93%E9%92%A7?author=%E9%95%93%E9%92%A7&#39;</code></p><p>这个过程有2个要点：</p><ol><li><code>镓钧</code>二字变成了<code>%E9%95%93%E9%92%A7</code>，说明String的内容有目的的被URLEncoder转换为了其他字符</li><li><code>%E9%95%93%E9%92%A7</code>中将百分号去掉，其实就是<code>E995 93E9 92A7</code>这是<code>镓钧</code>的UTF-8的16进制表示形式</li></ol><p>所以URLEncoder做的事情按顺序可以归类为下面2点：</p><ol><li>使用类似<code>s.getBytes(&quot;utf-8&quot;)</code>的机制，将<code>镓钧</code>这个Unicode字符使用utf8解码成Bytes[]，</li><li>将Bytes[]按照每16位为单位，提升为了char[ ]，并且开头会附加上<code>%</code>，最后把这些char字符组装为新的Stirng返回</li></ol><p>就这样其实URLEncoder把你的中文字符变成了英文字符！</p><p><strong>有关URLDecoder在有了前面的介绍后就更好解释了</strong></p><p>url在送达目的地后被解码，使用URLDecoder解码，因为URLDecoder它懂得规则，所以它会把这一串URL字符中的16位进制数据去挨个匹配utf-8的码表，找到对应的字符，最后达到得到了想要的数据</p><h1 id="尾"><a href="#尾" class="headerlink" title="尾"></a>尾</h1><p>总结：URLEncoder和URLDecoder的encode方法内部包含了我们一般说的编码操作，但是实际上这个方法本身可以算是使用了String的编码API来执行的一个上层程序。我们自己也可以实现一个简单的URLEnocder。所以我以前认为的URLEncoder本身也是一种编解码API的思想是错误的！ 故特写此文进行纠正</p>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>又是一年父亲节</title>
      <link href="/2019/06/16/ToFather/"/>
      <url>/2019/06/16/ToFather/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>又是一年父亲节，正好是周日，挤点时间写一些心里话吧</p><p>首先，还是先祝老爸父亲节快乐，感谢您一路以来的支持与厚爱，祝老爸身体健康，好事成双</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>在我很小的时候，我觉得老爸很可怕，动不动就打人，所以那时候我最喜欢妈妈（笑），以前总是去义乌玩不仅仅是因为可以玩电脑，其实说白了还是小时候真的更加的粘妈妈。我记得很清楚，我初中住校的第一天，我特别想回家，那时候一个人在被窝里哭了很久，那晚上也几乎没睡着，脑子想的也几乎都是妈妈（笑）</p><p>后来到了高中，自我认知能力提高了些，我开始第一次觉得老爸没有以前可怕了。那会每周的上下学开车接送，给我们制造了不少沟通的时间，我经常不停的抛出话题然后一路聊到学校门口。</p><p>后来，老爸开始创业了，做了很多时髦的行当，想赚更多的钱。我也不知道我当时是从谁那里听到的消息，但是很神奇的事，老爸在前线的各种消息总能准时的入到我的耳朵里。不管是好消息还是坏消息。但是我总是带着非常害怕的心理在观望着，那段时间就是非常的后怕，总感觉老爸在冒很大的风险。潜移默化的，我也受到了一定的影响，我觉得我也应该加点油，刚好那会正直高三，我想这也许就是一种天意。</p><p>由于小时候基本是和奶奶一起过日子，我被很好的保护着长大，小时候就一直感觉自己是最厉害的，最强的，是最聪明的人。然后等我一点点的独立后我渐渐发现了自己是真的很普通。不过好笑的是，让我切身感受到这一点的居然是我断断续续持续了几年的恋爱经历（不是班长！），老爸可能不知道，其实我高一没开学多久，就和一个女孩子好上了，是个看上去非常文静的人。我从小就比较开朗，所以一开始是根本对她没有任何兴趣的。但是毕竟是前后座，交流还是挺多的。当我发现她居然和我一样也喜欢Animation Comic的时候，我简直就像找到了知音那样，心里活奔乱跳。年轻的我觉得这一定是上天开眼，赐予我一个如此完美的同好，我们两个经常聊那些东西到很晚。</p><p>不过好景也不长，高三毕业后，我们都各自选择了自身发展，互相也发生了一定的争吵，最后我们报考了不同的大学，我去了陕西她去了上海。我以为我们就此无缘，在我脑子里差不多忘掉那段时光之后，到了大二，命运的时钟又开始敲响。我在一个Animation Comic的同好网站上，我居然又遇到了她。由于时隔很久了，所以我们一开始就像遇到老朋友一样，互相分享自己最近的经历。可惜的是，有交流就有纠纷，那时不懂事的我，再次和她发生了较大的争吵。在那以后，我开始彻底死了心，这段故事也总算告一段落。</p><p>之后，我就常常思考这个事情，开始觉得是自己的自我意识太过于旺盛，是自己的不成熟（虽然现在也不成熟）导致了这个后果。在那以后，我也变了比较多，首先是我不喜欢发什么朋友圈消息，开始喜欢做一个透明人，其次是我对女人失去了一定的恋爱兴趣，现在就觉得有钱娶老婆才是正途。</p><p>感觉自己在这个话题上说的多了点（笑），不过希望老爸对我有更多的了解可能也是写这篇文章的初衷之一</p><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>在以前父亲节，我总是考虑这一年我又可以回报老爸什么，当然这个想法是一直没变的，总有一天我觉得我一定可以达到财务自由，然后尽情的用“金钱”的力量来回报老爸老妈，现在也天天在被这种目标催动着，行动着。只不过自己不是那么厉害，不是那么强，不是最聪明的人，现在的一切都有点让我感觉不尽如意，但唯有努力，才能让我感觉良心过得去。</p><p>今年父亲节，不知道为什么。我开始考虑自己了，我心里也开始产生了想过父亲节的想法，现在在我看来，这个也许才是一种成长。我也想做一个好父亲，我一路走来，根据自己的成长经验，感觉已经有非常多的话想讲给自己的孩子听了。为了达到这个目的，我觉得自己的首要目标还是稳定就业，然后赚大钱，有些这些我感觉什么都会好起来。</p><blockquote><p>报喜不报忧</p></blockquote><p>工作后，整天从早到晚，真的不能说是一种‘喜’。我心里仔细算了算，我后续可以给你们报的‘喜’，应该大致是这些：</p><ol><li>把工作地点切到杭州</li><li>创业成功（现在已经开始有想创业的想法，真的觉得上班是不行的，有这个想法完全是被钱驱动的，我想更多的钱，那可以让我办更多的事）</li><li>结婚（等完成1或者2后才会考虑）</li><li>生子（完成3后，顺其自然会发生的事情）</li></ol><p>所以能报的‘喜’确实越来越少，也越来越精髓。我已经不可能一点点好事情就找你们分享了，这也许可以算是给老妈一个简单的答复吧，老妈最近开始觉得我有点’阴落落‘的。那是因为我感觉有些话已经不适合现在交流了。</p><p>在接下来的日子是，是我人生的启程，我只希望你们可以默默的关注我，而不是援助我，因为我想看看一个人究竟可以走多远，必要的时候我肯定会伸出援手，所以也请老爸老妈不要担心。对我来说，现在最大的愿望就是可以看你们开心的养老。我也知道这些都握在我自己的手中。</p><p>最后，真心的祝福老妈老爸身体健康！好事成双！谢谢你们</p><h1 id="4-附录"><a href="#4-附录" class="headerlink" title="4 附录"></a>4 附录</h1><p>这是儿子的个人博客，我在上面有时候会写点生活博文（大部分写的是工作相关的），你们可以常来看看，24小时不停为你们服务^_^<br>本文章后续我会进行加密，这样就可以安全的说一点家事，不怕被别人看见了（笑）<br>评论系统的话我只对国外IP开放，所以你们没办法留言（哭）</p><p>儿子致上！</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的字符编码问题一语道破(GBK,UTF-8,ISO-8859-1)</title>
      <link href="/2019/06/15/Java%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%E4%B8%80%E8%AF%AD%E9%81%93%E7%A0%B4-GBK-UTF%E7%AD%89%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A0%81/"/>
      <url>/2019/06/15/Java%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%E4%B8%80%E8%AF%AD%E9%81%93%E7%A0%B4-GBK-UTF%E7%AD%89%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="0"><a href="#0" class="headerlink" title="0"></a>0</h1><p>如果你是纯小白，那么请先阅读<a href="https://zazalu.space/2019/04/24/%E6%88%91%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%80%BB%E7%BB%93/">我的编码总结</a>，对编码有了最基础的认识后，进行本篇文章的阅读，我可以保证你可以对Java这块会出现的编码的问题都可以自行一一解决，而且不需要借助google或者百度，全部都可以自己思考解决</p><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>我们从一个Java乱码的实例来抛出这个问题。</p><p>实例场景：</p><blockquote><p>要求使用Java读取一个 GBK 格式的文件，使用BufferedReader的readLine读取后发现控制台输出乱码</p></blockquote><p>GBK文件内容如下图所示<br><img src="/images/tmpImage/Java_Character_1.png"></p><p>在使用Java程序读取之前，我们先来分析这个文件的二进制内容，这里先向再看这篇文章的人特别强调一点，那就是分析乱码的时候，请务必从二进制出发！虽然你会发现控制台，数据库，文件的内容输出根据编码情况变来变去的，搞的你天花乱坠，但是二进制文件是万变不离其宗的！</p><p>我们使用linux的hexdump来获取二进制数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zazalu@zazalu-ThinkPad-E480:~/app/JavaProjectWithIDEA/MySpider/src/main/resources$ hd gbktest.txt </span><br><span class="line">00000000  49 61 6d be fd c9 bd                              |Iam....|</span><br><span class="line">00000007</span><br></pre></td></tr></table></figure></p><p>得到了<code>49 61 6d be fd c9 bd</code>，这是我们这个文件的十六进制表示，随后我们逐个转换为二进制如下(不足8位的我在最前面补0了，8bit = 1byte)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">49       61       6d       be       fd       c9       bd </span><br><span class="line">01001001 01100001 01101101 10111110 11111101 11001001 10111101</span><br></pre></td></tr></table></figure></p><p><strong>[注意]</strong>: 可以对照<a href="http://tools.jb51.net/table/gbk_table" target="_blank" rel="noopener">这张码表</a>来看看hexdump程序对不对，我自己对照过了，<code>君</code>是<code>befd</code>，山是<code>c9bd</code>，没问题。前面的英文直接对照ASCII码表即可，都吻合！</p><p>到这里我们就知道了<code>Iam君山</code>这句话的GBK二进制数据表示就是<code>01001001 01100001 01101101 10111110 11111101 11001001 10111101</code></p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>接下来我们使用BufferedReader的readLine来读取这个片段，来重现一种乱码出现的情况！</p><p>java程序如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"gbktest.txt"</span>);</span><br><span class="line"><span class="keyword">try</span>(BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file)))&#123;</span><br><span class="line">    String s = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">while</span> ( (s = bufferedReader.readLine()) != <span class="keyword">null</span> )&#123;</span><br><span class="line">        System.out.println(s);<span class="comment">//控制台输出 Iam��ɽ</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个程序读取gbktest.txt的内容并且打印到了标准输出上，也就是控制台上。</p><p>为了方便后续的讨论，我将这个程序在执行过程中存在的不同版本的字节流命名如下：</p><ol><li><p>gbktest.txt本身的字节流，一串GBK字节流，二进制表示如下：<code>01001001 01100001 01101101 10111110 11111101 11001001 10111101</code>，我们称它为<code>GBK流</code></p></li><li><p>BufferedReader使用readLine获得到了一串字符串据s，Java的字符串内部使用Unicode编码（内码）存储，我们称它为<code>Unicode流</code></p></li><li><p>控制台获取s的内容打印到标准输出上的字节流，由于标准输出我这边是UTF-8编码，所以我们称它为<code>UTF-8流</code></p></li></ol><p>为了理解第三节的讨论，你必须要对下面的知识点有清醒的认识</p><ol><li>java的String内部使用16位空间存储字符，也就是Unicode字符</li><li>UTF-8不会一口气转换成GBK，中间必须使用Unicode字符来过渡</li></ol><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>接下来我一步步来透彻的讲解这些代码发生了什么</p><ol><li>bufferedReader.readLine()，bufferedReader内部默认使用UTF-8编码来读取，比对Unicode表来转换字节到字符（网上可以查到），使用read，一次只读取一个字节，最后拼成一串char数组返回，所以按照它的读取规则，我们的<code>GBK流</code>会被如下解析</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">01001001 01100001 01101101 10111110 11111101 11001001 10111101</span><br><span class="line">  |</span><br><span class="line">  V</span><br><span class="line">对照UTF-8表，发现是I，然后在Unicode的总表上查阅I字符怎么表示，最终填入char[0] = &apos;U+0049&apos; 也就是&apos;I&apos;</span><br><span class="line"></span><br><span class="line">01001001 01100001 01101101 10111110 11111101 11001001 10111101</span><br><span class="line">            |</span><br><span class="line">            V</span><br><span class="line">对照UTF-8表，发现是a，然后在Unicode的总表上查阅a字符怎么表示，最终填入char[1] = &apos;U+0061&apos; 也就是&apos;a&apos;</span><br><span class="line"></span><br><span class="line">01001001 01100001 01101101 10111110 11111101 11001001 10111101</span><br><span class="line">                     |</span><br><span class="line">                     V</span><br><span class="line">    对照UTF-8表，发现是m，然后在Unicode的总表上查阅m字符怎么表示，最终填入char[2] = &apos;U+006D&apos; 也就是&apos;m&apos;</span><br><span class="line"></span><br><span class="line">01001001 01100001 01101101 10111110 11111101 11001001 10111101</span><br><span class="line">                              |</span><br><span class="line">                              V</span><br><span class="line">    对照UTF-8表，发现不对，UTF-8码表规则不允许用10开头！(UTF-8码表规则在下面附上，请自己比对)</span><br><span class="line">    针对这种情况，转换规则里存在一种机制，会把不允许的字节全部自动变成一个叫&quot;[置换字符](https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character&quot;的东西！UTF-8的置换字符为�，在Unicode总表上查出来，所以char[3] = &apos;U+FFFD&apos; 也就是&apos;�&apos;</span><br><span class="line"></span><br><span class="line">01001001 01100001 01101101 10111110 11111101 11001001 10111101</span><br><span class="line">                                       |</span><br><span class="line">                                       V</span><br><span class="line">    对照UTF-8表，和上面情况一样，发现不允许11111开头！所以char[4] = &apos;U+FFFD&apos; 也就是&apos;�&apos;</span><br><span class="line"></span><br><span class="line">01001001 01100001 01101101 10111110 11111101 11001001 10111101</span><br><span class="line">                                                |       |</span><br><span class="line">                                                V       V</span><br><span class="line">    对照UTF-8表，发现是第一个字节110开头第二个字节10开头，符合utf-8双字节表示的情况！所以一口气读取2个字节，转换成Unicode码为`U+027D`.所以char[5] = &apos;U+027D&apos; 也就是&apos;ɽ&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Unicode符号范围 | UTF-8编码方式</span><br><span class="line">(十六进制) | （二进制）</span><br><span class="line">--------------------+---------------------------------------------</span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure><p>所以综上所述，我们的String s的内容的Unicode码为<code>U+0049 U+0061 U+006D U+FFFD U+FFFD U+027D</code></p><p>这串Unicode的码就是我们读取后java底层保存的真正内容！也就是<code>Iam��ɽ</code></p><p>从这里我们其实已经得到了答案，那就是BUfferedReader的这种读取方式直接就把我们的<code>源文件流</code>内容完全变掉了，变成了一串新的东西，错就错在它读取的时候按照UTF-8的规则来转换，把本来应该双字节双字节为单位读取的二进制数据，’翻译’成了另一个样子！</p><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>那么我们现在的关键问题是，这串Unicode码能不能通过简单的方式转换为没有乱码的样子？</p><p>在网上流行的方法会让你这么做：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> String(s.getBytes(<span class="string">"ISO-8859-1"</span>),<span class="string">"GBK"</span>));<span class="comment">//这个在一些例子里可以成功实现快速转换，但是在我们这个例子是行不通的！为什么？下面解释</span></span><br></pre></td></tr></table></figure></p><p>类比到我们这个例子里，也许就是这么做<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> String(s.getBytes(<span class="string">"UTF-8"</span>),<span class="string">"GBK"</span>));<span class="comment">//输出 Iam锟斤拷山</span></span><br></pre></td></tr></table></figure></p><p>可以看到输出变成了’Iam锟斤拷山’，和我们本来的意思不一样了！所以它虽然看上去变成中文了，但是实际上依旧是乱码！下面依旧一步步来给你解释为什么会这样！</p><p>首先<code>s.getBytes(&quot;UTF-8&quot;)</code>，这个代码的意思是将字符串s的Unicode码（内码）转换为UTF-8码，返回一个byte[]，如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">由于UTF-8很多是三字节的，用二进制表示会太长不已阅读，这里就用十六进制表示下，你可以自己转</span><br><span class="line">Unicode:</span><br><span class="line">U+0049 U+0061 U+006D U+FFFD U+FFFD U+027D</span><br><span class="line"></span><br><span class="line">使用UTF-8码表翻译Unicode，得到如下二进制数据：</span><br><span class="line">01001001 01100001 11001001 11101111 10111111 10111101 11101111 10111111 10111101 11001001 10111101</span><br></pre></td></tr></table></figure></p><p>所以我们得到的byte数组内容就是<code>01001001 01100001 11001001 11101111 10111111 10111101 11101111 10111111 10111101 11001001 10111101</code></p><p>其次<code>new String(s.getBytes(&quot;UTF-8&quot;),&quot;GBK&quot;)</code>的第二个参数会用GBK的字节读取规则来转换这个byte[]，把它变成Unicode码最后存在字符串s中，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">byte[]:</span><br><span class="line">01001001 01100001 11001001 11101111 10111111 10111101 11101111 10111111 10111101 11001001 10111101</span><br><span class="line"></span><br><span class="line">先转换为GBK</span><br><span class="line">0049 0061 006D EFBF BDEF BFBD C9BD</span><br><span class="line"></span><br><span class="line">然后转换为Unicode存储至String中</span><br><span class="line">I    a    m    锟   斤   拷   山</span><br></pre></td></tr></table></figure></p><p>所以我们通过这个方式转换后，得到了输出为<code>Iam锟斤拷山</code></p><p><strong>[小节]</strong>: 所以单纯使用<code>System.out.println(new String(s.getBytes(&quot;UTF-8&quot;),&quot;GBK&quot;));</code>这种方式来教别人转换是有点误导向的。这种方式的本来意思就是用前者的编码将Unicode转换为UTF-8格式的Byte[]，然后再用GBK的码表把这个Byte数组转换为Unicode！ 这个过程的作用简直就是搞笑！这个代码也是让我哭笑不得。但是也有些情况用这个代码可以实现快速的转换，比如<code>System.out.println(new String(s.getBytes(&quot;ISO-8859-1&quot;),&quot;GBK&quot;));</code>，这是因为ISO-8859-1是8位的编码格式，它正好把一个中文对半拆分成了2个字符，由于是对半的，所以转换为byte数组的时候，结果是一样的，就可以歪打正着的还原回去了！真的哭笑不得</p><h1 id="5"><a href="#5" class="headerlink" title="5"></a>5</h1><p>本次的编码课题就到此结束了，有问题的小伙伴可以在下面评论，看不多评论是因为你没有使用科学上网工具</p><p>参考：<a href="http://tools.jb51.net/table/gbk_table" target="_blank" rel="noopener">GBK码表</a><br>参考：<a href="https://www.fileformat.info/info/unicode/char/fffd/index.htm" target="_blank" rel="noopener">Unicode字符对应所有的编码如何表示的网站，很好用</a><br>参考：<a href="https://tool.oschina.net/hexconvert" target="_blank" rel="noopener">在线进制转换工具</a><br>参考：<a href="https://zh.wikibooks.org/wiki/Unicode/%E5%AD%97%E7%AC%A6%E5%8F%82%E8%80%83/0000-0FFF" target="_blank" rel="noopener">Unicode码表</a><br>参考：<a href="https://en.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener">UTF-8码表</a></p><div id="donationPoint"><div id="licensePoint"></div></div>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu18.04安装mysql8.0.16(Community)，内附详细说明适合小白学习哦</title>
      <link href="/2019/06/14/ubuntu18-04%E5%AE%89%E8%A3%85mysql8-0-16-Community/"/>
      <url>/2019/06/14/ubuntu18-04%E5%AE%89%E8%A3%85mysql8-0-16-Community/</url>
      
        <content type="html"><![CDATA[<h1 id="0"><a href="#0" class="headerlink" title="0"></a>0</h1><p>首先mysql已经不是以前的mysql了，自从加入oracle旗下后，各类付费mysql产品已经陆续上线了。目前最新的付费企业mysql版中，居然已经支持了nosql！但是非常遗憾！这个功能在社区版（也就是免费开源版）中是不支持的！╮(╯▽╰)╭ 好吧，想白嫖nosql还是老老实实用别的把！Oracel爸爸不收钱是不可能的</p><p>今天记录安装的是使用<code>ubuntu18.04</code>安装<code>MySQL Community Edition 8.0.16</code></p><p>MySQL Community Edition就是我们最熟知的mysql啦，可以白嫖的mysql啦！</p><h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>打开mysql官方下载网页<br><a href="https://dev.mysql.com/downloads/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/</a></p><p>寻找如下的位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MySQL Community Server (GPL)</span><br><span class="line">(Current Generally Available Release: 8.0.16)</span><br><span class="line">MySQL Community Server is the world&apos;s most popular open source database.</span><br><span class="line">DOWNLOAD</span><br></pre></td></tr></table></figure></p><p>随后我们来到了下载页面，先选择我们的操作系统版本，我是<code>ubuntu18.04 64-bit</code>，如下图所示</p><p><img src="/images/tmpImage/mysql_1.png"></p><p>我刻意没有截图下面的那些各种各样的软件包，那是因为选择安装最新的8.0x，官方已经强力推荐使用包管理工具来安装了！所以我们没必要去看那些名字复杂，乱七八糟的各种安装包了！</p><p>点击推荐我们使用apt下载mysql的那个企鹅图片，我们会跳转到apt下载mysql的专栏网页。</p><p>该网页分成三个部分，第一部分介绍apt安装mysql的优点和它目前支持的版本，第二部分是一个快速开始的操作文档会教你怎么用！，第三部分是一个deb下载包<code>mysql-apt-config_0.8.13-1_all.deb</code>，可以先下好保存在本地，待会要用</p><p>下载好<code>mysql-apt-config_0.8.13-1_all.deb</code>后，你如果看不懂官方的操作文档，或者对其内部用到的东西感兴趣，那么看下面的内容是最好的！</p><h1 id="2-开始安装"><a href="#2-开始安装" class="headerlink" title="2 开始安装"></a>2 开始安装</h1><ol><li><p>为了文件摆放合理，请创建一个mysql-config-deb的文件夹，随后把你下载好的<code>mysql-apt-config_0.8.13-1_all.deb</code>移动过去，并在当前文件夹开启terminal</p></li><li><p>在terminal内输入<code>sudo dpkg -i mysql-apt-config_0.8.13-1_all.deb</code>，随后会弹出一个配置界面，除非你有特殊需求，不然直接选择<code>OK</code>即可，最后你会得到如下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(Reading database ... 224799 files and directories currently installed.)</span><br><span class="line">Preparing to unpack mysql-apt-config_0.8.13-1_all.deb ...</span><br><span class="line">Unpacking mysql-apt-config (0.8.13-1) over (0.8.13-1) ...</span><br><span class="line">Setting up mysql-apt-config (0.8.13-1) ...</span><br><span class="line">Warning: apt-key should not be used in scripts (called from postinst maintainerscript of the package mysql-apt-config)</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li></ol><p><strong>[讲解]</strong>: <code>sudo dpkg -i mysql-apt-config_0.8.13-1_all.deb</code> 这一步是使用dpkg工具运行我们的mysql-config的程序，dpkg是ubuntu这类linux系统的底层包管理工具，也负责管理.deb结果的程序包。 mysql-cofig弹出的配置界面用于选择你要安装的是什么版本的mysql以及想要安装哪些mysql插件，选择完毕后，这个工具会生成一个类似<code>source.list</code>的东西，内部记录了mysql的apt软件仓库的服务器地址，用于后续的apt工具可以正常的安装mysql，会告知apt工具应该去检索哪些软件仓库的软件包。当然这个步骤其实也可以手动来添加这些apt的相关配置，如果你对apt的软件仓库配置非常熟悉，那么可以自己尝试，或者从这篇文档开始<code>https://dev.mysql.com/doc/mysql-apt-repo-quick-guide/en/#repo-qg-apt-repo-manual-setup</code></p><ol start="3"><li><p>输入<code>sudo apt-get update</code>，apt-get就开始重新更新软件仓库服务器内的所有包文件索引，在这里使用该命令的目的是，拉取mysql的apt软件仓库的服务器上的包索引列表。<br><strong>[讲解]</strong>: apt工具是dpkg工具的上层软件，它拥有更强的包管理功能；它是利用自身软件仓库（source.list）内指定的源服务器地址内包含的包索引列表来正常的安装我们要安装的软件应用。这一步骤也正是在更新这些包索引列表，目的是添加我们刚刚引入的mysql的源软件仓库服务器内包含的包索引列表。可以把这个操作类比成电脑管家的查看更新。完成这步骤后，apt工具就会知道如何去下载安装我们的mysql了！所以这个步骤是使用apt安装mysql的关键步骤，是必须执行的哦！</p></li><li><p>输入<code>sudo apt-get install mysql-server</code>，提示是否安装选<code>Y</code>，随后apt工具会根据本地的包索引列表去下载我们的mysql-server对应的包程序！为什么apt可以自我管理怎么去安装mysql-server，我们从这条命令也没有告知他安装啥版本，但是它就会去自行安装我们的8.0x版本。这一切都归功于我们前面对apt软件仓库的配置！</p></li><li><p>等待片刻后，会弹出mysql一个小的配置程序界面，要求你输入下root用户的密码（输入2次），并且选择加密方式，8.0x使用了新的加密方式，也是官方推荐的，所以选推荐的就完事了！</p></li><li><p>看到如下输出，恭喜你安装成功！（入坑成功！）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">emitting double-array: 100% |###########################################| </span><br><span class="line">reading /usr/share/mecab/dic/ipadic/matrix.def ... 1316x1316</span><br><span class="line">emitting matrix      : 100% |###########################################| </span><br><span class="line"></span><br><span class="line">done!</span><br><span class="line">update-alternatives: using /var/lib/mecab/dic/ipadic-utf8 to provide /var/lib/mecab/dic/debian (mecab-dictionary) in auto mode</span><br><span class="line">Setting up mysql-community-server (8.0.16-2ubuntu18.04) ...</span><br><span class="line">update-alternatives: using /etc/mysql/mysql.cnf to provide /etc/mysql/my.cnf (my.cnf) in auto mode</span><br><span class="line">Created symlink /etc/systemd/system/multi-user.target.wants/mysql.service → /lib/systemd/system/mysql.service.</span><br><span class="line">Setting up mysql-server (8.0.16-2ubuntu18.04) ...</span><br><span class="line">Processing triggers for libc-bin (2.27-3ubuntu1) ...</span><br></pre></td></tr></table></figure></li><li><p>使用<code>sudo service mysql status</code>，查看mysql目前的状态，输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">● mysql.service - MySQL Community Server</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Fri 2019-06-14 11:06:40 CST; 21s ago</span><br><span class="line">     Docs: man:mysqld(8)</span><br><span class="line">           http://dev.mysql.com/doc/refman/en/using-systemd.html</span><br><span class="line">  Process: 18991 ExecStartPre=/usr/share/mysql-8.0/mysql-systemd-start pre (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 19030 (mysqld)</span><br><span class="line">   Status: &quot;SERVER_OPERATING&quot;</span><br><span class="line">    Tasks: 39 (limit: 4915)</span><br><span class="line">   CGroup: /system.slice/mysql.service</span><br><span class="line">           └─19030 /usr/sbin/mysqld</span><br><span class="line"></span><br><span class="line">6月 14 11:06:35 zazalu-ThinkPad-E480 systemd[1]: Starting MySQL Community Server...</span><br><span class="line">6月 14 11:06:40 zazalu-ThinkPad-E480 systemd[1]: Started MySQL Community Server.</span><br></pre></td></tr></table></figure></li></ol><p>mysql的安装程序真的越来越傻瓜了！因为它不仅在安装完后自动运行了mysql，同时它还把它搞成了一个service，这样就可以在开机的时候自启动了！</p><h1 id="3-其他控制命令"><a href="#3-其他控制命令" class="headerlink" title="3 其他控制命令"></a>3 其他控制命令</h1><ol><li><p>关闭mysql，这里推荐如下命令，也是官方推荐的，当然你kill进程也是莫得问题的<br><code>sudo service mysql stop</code></p></li><li><p>重启mysql<br><code>sudo service mysql start</code></p></li></ol><h1 id="4-卸载"><a href="#4-卸载" class="headerlink" title="4 卸载"></a>4 卸载</h1><ol><li><p>由于使用apt安装，所以卸载也会变得及其傻瓜式，使用如下命令即可<br><code>sudo apt-get remove mysql-server</code></p></li><li><p>有些人喜欢下一些mysql的插件来增强mysql的功能，使用如下命令卸载这些插件<br><code>sudo apt-get autoremove</code><br>或者指定包名<br><code>sudo apt-get remove package-name</code></p></li></ol><p>不知道有哪些包，先用如下命令查看<br><code>dpkg -l | grep mysql | grep ii</code></p><h1 id="5-自动安装-超傻瓜式"><a href="#5-自动安装-超傻瓜式" class="headerlink" title="5 自动安装-超傻瓜式"></a>5 自动安装-超傻瓜式</h1><p>可以写个shell脚本，把这些东西捆绑，一键执行！那就是真的超傻瓜式安装包了，我以后来填</p><div id="donationPoint"><div id="licensePoint"></div></div>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>傻子也能理解的并发编程中的原子性(Java)</title>
      <link href="/2019/06/11/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7/"/>
      <url>/2019/06/11/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>线程A对变量a和b在进行如下操作：<code>读取A-读取B-修改A-修改B-写入A-写入B</code></p><p>线程B也同样的可以对变量a和b进行上述操作</p><p>当线程A进行到<code>写入A</code>的时候，线程B是个急性子，抢占线程A，率先执行了<code>读取B</code>。</p><p>这个过程就是一种线程安全问题的一种通俗解释。</p><p>完成<code>读取A-读取B-修改A-修改B-写入A-写入B</code>这个段功能的程序在单线程下是正确的，在多线程下就因为不是<code>原子性</code>的导致其功能不正常，有时候产生非常异常的结果</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>如果线程A可以在一瞬间完成<code>读取A-读取B-修改A-修改B-写入A-写入B</code>这个过程，那么线程B就不会读取错误的b变量的数据。</p><p>这种可以让线程A“一口气”完成不会被别人打断的过程，就是符合<code>原子性</code>的一个过程</p><p>这就是<code>原子性</code></p><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>但是把所有java代码都弄成<code>原子性</code>那肯定是不可能的，计算机一个时间内能处理的东西永远是有限的。如果没法达到<code>原子性</code>那么我们就必须使用一种策略去让这个过程看上去是符合<code>原子性</code>的。这个策略最简单的就是控制代码的执行顺序，我们只需要控制线程B会在A完成<code>读取A-读取B-修改A-修改B-写入A-写入B</code>之后才会执行读取代码，这样就保证了线程安全问题不会发生了。所以有了<code>加锁机制</code></p><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>我刚刚阐述了<code>读取A-读取B-修改A-修改B-写入A-写入B</code>这个过程，必须是原子性的才能保证线程安全。</p><p>现在我们在具体一点，假设<code>读取A</code>和<code>读取B</code>以及后面的每个小操作都是原子性的，比如AtomicLong这些原子类的修改操作，它们本身的crud操作是原子的。</p><p>每个小操作都符合<code>原子性</code>是不是代表了这整个构成是符合<code>原子性</code>了呢？</p><p>显然不是</p><p>它仍然会产生线程安全问题，比如在<code>修改A</code>完成以后，失去操作原子性，所以线程B也开始执行<code>读取B</code>操作了。总之不要以为使用了线程安全类，你的所有代码就都是线程安全的！这总归都要去审查你代码的整体原子性出发的。就比如下面的例子：</p><p><img src="/images/tmpImage/原子性_1.png"></p><p>虽然它全部用了原子类来进行操作，但是各个操作之间不是原子性的，也就是说比如线程A在执行else语句里的<code>lastNumber.set(i)</code>完后，也许其他线程执行了if语句里的<code>lastFactorys.get()</code>方法，随后线程A才继续执行<code>lastFactors.set(factors)</code>方法更新factors！</p><p>从这个逻辑过程中，线程安全问题就已经发生了。它破坏了<code>读取A-读取B-修改A-修改B-写入A-写入B</code>这个整体过程，在<code>写入A</code>完成以后其他线程去执行了<code>读取B</code>，导致A和B的状态不匹配了！真的是场大灾难！</p><h1 id="5"><a href="#5" class="headerlink" title="5"></a>5</h1><p>本小节用了实例来讲述了<code>原子性</code>，从术语上直接解释什么是<code>原子性</code>是非常困难的，但是从这些示例里来说就会变的非常清晰</p>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA堆排序</title>
      <link href="/2019/06/11/JAVA%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/06/11/JAVA%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="堆排序-最大堆为例"><a href="#堆排序-最大堆为例" class="headerlink" title="堆排序(最大堆为例)"></a>堆排序(最大堆为例)</h2><p>堆排序是利用堆的特性来实现排序，经典的实现方式是采用最大堆（一种完全二叉树），“冒泡”顶端元素实现排序</p><h2 id="堆排序实现步骤"><a href="#堆排序实现步骤" class="headerlink" title="堆排序实现步骤"></a>堆排序实现步骤</h2><h3 id="1-将需要排序的数组构建成一个最大堆"><a href="#1-将需要排序的数组构建成一个最大堆" class="headerlink" title="1.将需要排序的数组构建成一个最大堆"></a>1.将需要排序的数组构建成一个最大堆</h3><p>由于完全二叉树的位置存在规律，所以完全二叉树可以由一个数组来表示，其左孩子就是2i+1位置，右孩子是2i-1，父节点位置i/2，i为数组索引。最大堆的构建就是利用这一点来实现的。下面我们展示一种将一个无序的数组转换为一个最大堆的实例</p><p><strong>[!]</strong>: 将一个无序的数组转换为最大堆有很多种方法，我这里讲的是其中一种方式也是网上和书上也流行的一种方式，也就是用<code>下滤</code>这种操作来一步步的将无序数组转换为最大堆的排序方式。其他方法还有使用<code>上滤</code>，具体可以在网上参考二叉堆（优先队列）的实现，本文不会提及太多。</p><p>我们拿下面的一个打乱的数组举例<br>int arr[] = new int[]{150,80,40,30,10,70,110,100,20,90,60,50,120,140,130}</p><p>因为（二叉）最大堆的特性，所以我们可以将其内容用完全二叉树来表示，如下图所示,可以看到数据110的节点是我们最小的可视为一棵树的单位，它在数组的位置正好是length/2 -1也就是arr[6]。</p><p><img src="/images/tmpImage/heapSort_1.png"><br>转换为完全二叉树表示后，就可以通过图解的方式轻松的探讨最大堆是怎么一步步构建出来的。下面我先贴代码，然后在代码的注释中讲解如何构建。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉堆的特性：一个根节点的左孩子在数组中的索引就是2*rootIndex +1，你可以通过观察我前面的图自己来验证这个原理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> rootIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * rootIndex + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉堆特性：右孩子=左孩子+1，你可以通过观察我前面的图来验证这个原理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> leftChild)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++leftChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否存在右孩子</span></span><br><span class="line"><span class="comment">//二叉堆特性： 验证最后一个左孩子是否是数组最后一个元素，如果不是那说明是有右孩子的</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">haveRightChild</span><span class="params">(<span class="keyword">int</span> leftChild,<span class="keyword">int</span> arrLength)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> leftChild != (arrLength - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下滤，维持最大堆性质的规则方法，请好好阅读并配合图解来理解即可</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">percDown</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> rootIndex,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (temp = arr[rootIndex]; leftChild(rootIndex) &lt; length; rootIndex = child) &#123;</span><br><span class="line">        child = leftChild(rootIndex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(child != length -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[child] &lt; arr[child+<span class="number">1</span>])&#123;</span><br><span class="line">                ++child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//和根节点交换位置完成下滤</span></span><br><span class="line">        <span class="keyword">if</span>(arr[rootIndex] &lt; arr[child])&#123;</span><br><span class="line">            arr[rootIndex] = arr[child];</span><br><span class="line">            arr[child] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前根节点树已满足条件无需下滤调整</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立最大堆</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="comment">//从arr.length/2-1开始，这是最小的根节点，相当于图中110元素数据的位置。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length/<span class="number">2</span> - <span class="number">1</span>; i &gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">        percDown(arr,i,arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>[!]</strong>: 这种构建方式构建时必须从length/2-1开始，也就是最小的根节点开始。不然会导致下滤不完全，最终得到的不会符合最大堆性质，你可以从图片中模拟这个情况的发生，比如从最顶端开始下滤，随后你会发现就有一部分元素（比如120,130,140这些元素）会被这个构建算法忽视，从而无法实现最大堆</p><h3 id="“冒泡”最大堆"><a href="#“冒泡”最大堆" class="headerlink" title="“冒泡”最大堆"></a>“冒泡”最大堆</h3><p>利用最大堆的数据结构，每次获取最小元素，转移至一个新数组（空间浪费），或者直接将最小元素转移至数组第一个位置。以此递归最终得到有序数组。</p><p>代码如下实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//将最大堆的顶端元素移动至数组最后一位，堆最大长度缩小1，循环此操作，变可以得到一个排好序的数组，这就是堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortByMaxheap</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length-<span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(arr,<span class="number">0</span>,i);<span class="comment">//array[0]也就是最大的数，移动到i处，也就是相对的末尾处</span></span><br><span class="line">        percDown(arr,<span class="number">0</span>,i);<span class="comment">//转换后arr[0]的位置变成了最小元素，其他位置都正常，所以需要对其做一次下滤操作使得最大堆性质不被破坏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line">    sortByMaxheap(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="时间复杂度分析："><a href="#时间复杂度分析：" class="headerlink" title="时间复杂度分析："></a>时间复杂度分析：</h2><ol><li>建堆的时间复杂度：O（N）</li><li>选取最大值并排序的时间复杂度是：O（logN）<br>所以总体的时间复杂度为O（NlogN）</li></ol><h2 id="算法稳定性分析："><a href="#算法稳定性分析：" class="headerlink" title="算法稳定性分析："></a>算法稳定性分析：</h2><p>不稳定，存在前后置换，所以会有后面的数据被换到前面的可能性</p>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git push大文件报错解决</title>
      <link href="/2019/06/08/git-push%E5%A4%A7%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/"/>
      <url>/2019/06/08/git-push%E5%A4%A7%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="错误描述"><a href="#错误描述" class="headerlink" title="错误描述"></a>错误描述</h1><p>git push无法上传超过100MB的文件（50MB会警告），错误log如下(部分敏感信息做了隐藏)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Counting objects: 4, done.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (4/4), 123.34 MiB | 1.83 MiB/s, done.</span><br><span class="line">Total 4 (delta 0), reused 0 (delta 0)</span><br><span class="line">remote: error: GH001: Large files detected. You may want to try Git Large File Storage - https://git-lfs.github.com.</span><br><span class="line">remote: error: Trace: 19e4cebc572e034bbb9c98400b094323</span><br><span class="line">remote: error: See http://git.io/iEPt8g for more information.</span><br><span class="line">remote: error: ***.pdf is 127.70 MB; this exceeds GitHub&apos;s file size limit of 100.00 MB</span><br><span class="line">To https://github.com/***/***.git</span><br><span class="line"> ! [remote rejected] master -&gt; master (pre-receive hook declined)</span><br><span class="line">error: failed to push some refs to &apos;https://github.com/***/***.git&apos;</span><br></pre></td></tr></table></figure></p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ol><li><p>使用git log查看所有的提交节点commit_id,我的如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">commit be7dafc20357142ff529f6d397a8452d4084a84b (HEAD -&gt; master)</span><br><span class="line">Author: zazaluMonster &lt;hejiajun1432@gmail.com&gt;</span><br><span class="line">Date:   Sat Jun 8 12:14:28 2019 +0800</span><br><span class="line"></span><br><span class="line">    test大文件提交push失败回滚</span><br><span class="line"></span><br><span class="line">commit 59083eafa73f4a1c36d31eb7dad1385017b92339 (origin/master)</span><br><span class="line">Author: zazaluMonster &lt;hejiajun1432@gmail.com&gt;</span><br><span class="line">Date:   Sat Jun 8 12:12:14 2019 +0800</span><br><span class="line"></span><br><span class="line">    update</span><br><span class="line"></span><br><span class="line">commit 2c7793bacdd323cf4c0f91eefd8950980c402602</span><br><span class="line">Author: zazaluMonster &lt;hejiajun1432@gmail.com&gt;</span><br><span class="line">Date:   Thu Jun 6 16:37:41 2019 +0800</span><br><span class="line"></span><br><span class="line">    update</span><br><span class="line"></span><br><span class="line"># ...其余信息省略</span><br></pre></td></tr></table></figure></li><li><p>筛选你想要的回退到的commit节点，比如我回退到59083eafa73f4a1c36d31eb7dad1385017b92339</p></li><li><p>使用<code>git reset &lt;commit_id&gt;</code>进行回退。注意不要使用<code>git reset HEAD &lt;commit_id&gt;</code>这会导致你的工作区也回退到相应的节点，这样的话你会发现刚写的东西就没了（可以补救，也就是在使用reset回退到最新的commit节点）</p></li><li><p>使用<code>git status</code>你会发现一切都重新从你修改本地文件之后，add之前开始了</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bugs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu18.04配置shadowsocks客户端</title>
      <link href="/2019/06/06/ubuntu18-04%E9%85%8D%E7%BD%AEshadowsocks%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>/2019/06/06/ubuntu18-04%E9%85%8D%E7%BD%AEshadowsocks%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="下载shadowsock客户端"><a href="#下载shadowsock客户端" class="headerlink" title="下载shadowsock客户端"></a>下载shadowsock客户端</h2><p>有两种shadowsocks客户端供你选择</p><ol><li>图形化界面的版本 Shadowsocks-Qt5 ，本文不介绍图形化界面客户端配置，<br>参考<a href="https://github.com/shadowsocks/shadowsocks-qt5/wiki" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-qt5/wiki</a></li><li>命令行客户端，用包管理工具下载，分两种，一种python实现，一种c实现的，本文介绍python的，想要c的<br>参考<a href="https://github.com/shadowsocks/shadowsocks-libev#installation" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-libev#installation</a></li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用Ubuntu高级包管理工具apt安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install python-pip</span><br><span class="line">pip install git+https://github.com/shadowsocks/shadowsocks.git@master</span><br></pre></td></tr></table></figure></p><h2 id="配置网络连接文件"><a href="#配置网络连接文件" class="headerlink" title="配置网络连接文件"></a>配置网络连接文件</h2><p>创建配置文件<code>/etc/shadowsocks.json</code>，路径随意，不想思考就装etc路径下，这样就符合linux文件系统目录规范放置方式；如果是etc的话，注意root权限</p><p>格式如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"服务器 IP 或是域名"</span>,</span><br><span class="line">    <span class="attr">"server_port"</span>:端口号,</span><br><span class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"密码"</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"加密方式 (chacha20-ietf-poly1305 / aes-256-cfb)"</span>,</span><br><span class="line">    <span class="attr">"fast_open"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="启动shadowsocks-python版客户端"><a href="#启动shadowsocks-python版客户端" class="headerlink" title="启动shadowsocks python版客户端"></a>启动shadowsocks python版客户端</h2><p>sslocal（ss提供的一个proxy工具）已一个守护进程启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># sslocal是python客户度命令，-c是使用配置文件启动，-d是作为守护进程启动，start是启动。具体使用-h指令获取帮助信息</span><br><span class="line">/usr/local/bin/sslocal -c /etc/shadowsocks.json -d start</span><br></pre></td></tr></table></figure></p><p>关闭：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># sslocal是python客户度命令，-c是使用配置文件启动，-d是作为守护进程启动，start是启动。具体使用-h指令获取帮助信息</span><br><span class="line">/usr/local/bin/sslocal -c /etc/shadowsocks.json -d stop</span><br></pre></td></tr></table></figure></p><p>或者你直接kill进程也可以，使用<code>ps -aux | grep sslocal</code>就可以找到进程</p><p><strong>[!]</strong>: 建议使用守护进程启动，如果不使用守护进程启动，那么这个工具就会一直在terminal页面挂起，实时的打印log。一旦关闭terminal，它也就异常退出了，代理功能就没法持续稳定的运行。</p><h2 id="全局代理-（选填项）"><a href="#全局代理-（选填项）" class="headerlink" title="全局代理 （选填项）"></a>全局代理 （选填项）</h2><p>打开ubuntu系统的设置 -&gt; 点击Network -&gt;点击Network Proxy设置 -&gt; 选择Manual -&gt; 在socks Host一栏输入 127.0.0.1，端口1080即可</p><p><strong>[!]</strong> 全局代理指的是所有网络请求全部走这个代理，如果你不需要这样，，那就跳过这个步骤。</p><h2 id="浏览器配置（Chrome例子）"><a href="#浏览器配置（Chrome例子）" class="headerlink" title="浏览器配置（Chrome例子）"></a>浏览器配置（Chrome例子）</h2><p>由于我不想要全局都用一个代理，我更希望shadowsocks只是帮我上国外网站，所有我只限定浏览器使用shadowsocks。</p><h3 id="下载Proxy-SwitchyOmega扩展工具"><a href="#下载Proxy-SwitchyOmega扩展工具" class="headerlink" title="下载Proxy SwitchyOmega扩展工具"></a>下载Proxy SwitchyOmega扩展工具</h3><p><strong>[!]</strong> 不依赖工具你也可以手动，但是切换代理起来麻烦，所以直接推荐使用扩展工具</p><p>Proxy SwitchyOmega 可以轻松快捷的帮我们切换浏览器的代理设置</p><p>Proxy SwitchyOmega 的下载安装，如果你能打开chrome应用商店，那么直接输入Proxy SwitchyOmega即可安装</p><p>如果你没法打开chrome应用商店，可以在github该扩张工具项目的release下找到下载源，下载crx文件即可<br>github release地址：<a href="https://github.com/FelisCatus/SwitchyOmega/releases" target="_blank" rel="noopener">https://github.com/FelisCatus/SwitchyOmega/releases</a></p><p>嫌麻烦不想自己找，用下面这个，目前（2019-06-06）最新版本<br>下载地址：<a href="https://github.com/FelisCatus/SwitchyOmega/releases/download/v2.5.20/SwitchyOmega_Chromium.crx" target="_blank" rel="noopener">https://github.com/FelisCatus/SwitchyOmega/releases/download/v2.5.20/SwitchyOmega_Chromium.crx</a></p><p>下载好后，将.crx文件拖入<code>chrome://extensions/</code></p><p><strong>[!]</strong> 最新版chrome直接拖入crx文件会拒绝，解决方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">把下载后的.crx扩展名的离线Chrome插件的文件扩展名改成.zip(建议不要改成rar，有可能出现损坏)</span><br><span class="line">解压压缩文件</span><br><span class="line">在Chrome的地址栏中输入：chrome://extensions/ 打开Chrome浏览器的扩展程序管理界面，并在该界面的右上方的开发者模式按钮上打勾</span><br><span class="line">在勾选开发者模式选项以后，在该页面就会出现加载正在开发的扩展程序等按钮，点击“加载正在开发的扩展程序”按钮，并选择刚刚解压的Chrome插件文件夹的位置</span><br></pre></td></tr></table></figure></p><p>全部完成后，在<code>chrome://extensions/</code>页面记得启动Proxy SwitchyOmega</p><p>启动后会在chrome的右上角（插件栏）观察到一个圆形的图标。</p><h3 id="配置Proxy-SwitchyOmega"><a href="#配置Proxy-SwitchyOmega" class="headerlink" title="配置Proxy SwitchyOmega"></a>配置Proxy SwitchyOmega</h3><p>使用之前，我们要先配置下。</p><p>可以直接使用这个配置文件来快速应用shadowsocks服务到Proxy SwitchyOmega中</p><p>配置文件下载地址：<br><a href="https://home.shadowsocks.ch/dl.php?type=d&amp;id=74" target="_blank" rel="noopener">https://home.shadowsocks.ch/dl.php?type=d&amp;id=74</a></p><p>点击 “Proxy SwitchyOmega” &gt; “选项” &gt; “导入/导出” &gt; “从备份文件中恢复” </p><p>配置文件的内容：填写不同种代理设置而已，该配置文件帮你配置了四种模式，<br>[直接连接]， 不使用代理<br>[系统代理]， 使用系统默认代理，如果你没配过系统默认代理，那么就想到与直接连接<br>[Shadowsock]， 使用配置好的代理(127.0.0.1:1080)<br>[自动切换] ， 可以在所有上述模式中自动切换，已达到完成网页访问的目的（不推荐）</p><h3 id="使用Proxy-SwitchyOmega"><a href="#使用Proxy-SwitchyOmega" class="headerlink" title="使用Proxy SwitchyOmega"></a>使用Proxy SwitchyOmega</h3><p>点击圆形图标，选择Shadowsock模式你就发现能够上Google，youtube等网站了（注意先启动shadowsocks客户端服务）</p><h2 id="开机自启动"><a href="#开机自启动" class="headerlink" title="开机自启动"></a>开机自启动</h2><p>我们希望不是每次自己调用启动命令来启动shadowsocks，而是开机可以自己启动。那么需要配置一个自定义的ubuntu开机启动服务，我们使用Systemd来完成这项任务</p><ol><li><p>创建文件sudo vim /etc/systemd/system/shadowsocks.service</p></li><li><p>文件内容填写如下（我已我自己的为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks Client Service</span><br><span class="line">After=network.target</span><br><span class="line">After=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">#Type=simple</span><br><span class="line">Type=forking</span><br><span class="line">User=root</span><br><span class="line">ExecStart=/usr/local/bin/sslocal -c /etc/shadowsocks.json -d start</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></li></ol><p>重点是填写ExecStart那里，把我们的启动指令填进去</p><p><strong>[!]</strong> shadowsocks.json的路径填你自己的，如果你安全按照本配置文档来一路做过来的话，就可以直接使用上面的内容</p><p><strong>[!]</strong>: Service模块的Type必须使用forking，因为指令<code>/usr/local/bin/sslocal -c /etc/shadowsocks.json -d start</code>执行完后不会一直运行，创建完守护线程后很快会退出，最后Service发现指令已经执行完，于是service就也退出了。但是sslocal这时的守护线程是挂载在service上的，所以service退出，守护线程立马也kill了。这就导致最终你的sslocal没开启，就和走了一次片场一样。所以必须要规定Type=forking，因为forking模式下，Service会将自己的所有守护线程移交给os，那就没问题了，sslocal会在os下继续运行！</p><ol start="3"><li>让配置文件生效</li></ol><p><code>systemctl enable /etc/systemd/system/shadowsocks.service</code></p><ol start="4"><li>重启看看效果即可</li></ol><h2 id="有关Systemd管理的指令介绍"><a href="#有关Systemd管理的指令介绍" class="headerlink" title="有关Systemd管理的指令介绍"></a>有关Systemd管理的指令介绍</h2><ol><li><p>当你因为某些原因要修改shadowsocks.service的内容，比如字母打错了。修改完后必须调用<code>systemctl enable /etc/systemd/system/shadowsocks.service</code>来使其重新生效</p></li><li><p>sslocal提供log打印到文件的功能，使用-help查看具体帮助就可以翻阅到如何使用了</p></li><li><p>启动（关闭）service服务，使用指令<code>systemctl start(stop) shadowsocks.service</code> </p></li></ol><div id="donationPoint"><div id="licensePoint"></div></div>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>番茄工作法的有用论</title>
      <link href="/2019/06/05/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95%E7%9A%84%E6%9C%89%E7%94%A8%E8%AE%BA/"/>
      <url>/2019/06/05/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95%E7%9A%84%E6%9C%89%E7%94%A8%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>在大学的时候，听说过番茄工作法，不觉得好用所以没怎么使用这种工作方式。<br>现在过了好多年，最近开始用起了这个方法。<br>以前我自己可以埋头学习，1个小时以上，但是现在不行，因为现在我的生活需要关注的东西太多了。所以我至少需要每隔一段时间就回复QQ消息，回复微信消息，甚至回复其他的社交媒体消息。<br>同时出于做善事的目的，我已经接触了不少刚上大学的软件学生，给予了他们一些自己的学习经验和总结，平时也会去回复他们的问题。<br>种种因素导致我发现我现在的注意力容易分散，每过一小段时间，我就会想着有没有什么事情我还没有交待。这种不知道什么时候养成的习惯，前段时间困扰了我挺久，直到我想到了番茄工作法。</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>番茄工作法对于我这种情况可以说是如鱼得水，我真正的第一次感受到了这确实是一种可以广而告之的工作方式。<br>25分钟不长不短，足以让我写完一段比较复杂的工作任务，剩下的5分钟可以对这25分钟的工作做一次回顾，就好比自己写完一串代码后，翻回去看一看写的整体怎么样。这5分钟的整理对自己的一个心理疏通可以起到很重要的作用。因为你输出了一定程度的工作结果而不去检查的时候，你的内心就会开始起怀疑心，总感觉心里不太踏实。<br>这5分钟也完全可以拿去刷刷qq和微信，推特。看看此时此刻其他人在干什么，会产生极强的社交存在感。</p><p>不过唯一的问题就是5分钟也许太短，一下子就过去，不过这个就因人而异了。目前对我来说5分钟刚好。</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>番茄工作法还有一个特点就是，时间到的时候会有一次提示音。这让我一瞬间会联想到了小时候的下课铃声。所以番茄工作法本身就非常切合我们从小就养成的生活习惯。有时候一个难以解决的问题，与其不停的埋头研究，还不如利用番茄工作法，达到身心的平衡，你会发现你的脑子转起来会比平时更稳定，更有逻辑性</p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>以后抽空再试试别的番茄工作法并写一篇分享文章也不错，今天先到这</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人性的混乱</title>
      <link href="/2019/05/29/%E4%BA%BA%E6%80%A7%E7%9A%84%E6%B7%B7%E4%B9%B1/"/>
      <url>/2019/05/29/%E4%BA%BA%E6%80%A7%E7%9A%84%E6%B7%B7%E4%B9%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>最近事情太忙，所以有好几天没写博客了。但是今天，我在网上无意间看到了一篇视频，视频是一个北京老师针对目前很多学生”死学习“，“假努力”的现状的批判，最后抛出观点：我们作为一个普通人，首先要学会的是明确目标，然后展开行动。虽然有些地方我不是非常理解和认同老师的观点，但是也是确确实实的触动了我，引起了我个人的思考。我个人文化水平不高，只是一个普通的大学生，看的人性相关的书也不多，所以只能算是个小白。但是我看完视频后，非常想写一篇这方面方向思考的文章，虽然我可能表达有问题，理解有问题，但是我觉得我真的非常有必要记录下我对于这方面的到底是怎么考虑的。</p><p>现在是个信息时代，是个提倡言论自由的时代，我也最讨厌洗脑这个概念。所以在我还不是非常明确某个结论的时候，我不想这篇文章被太多的人看到。我写这篇文章是有另外自己的目的的，那就是写给自己的父母看看。因为从今往后我们还要生活很长一段时间，所以交流是不可避免的。不交流那是一种自我否定，自我逃避。但是现在迫于环境的压力，我和父母的交流越来越少，能说的话也越来越少了。这让我感觉很惋惜，所以我想写一点文章，不是专门给大众看的，而是专门写点东西给父母看，向父母阐述自己的内心想法，好让他们对我有更加深刻的了解，以免父母做出各种奇奇怪怪的举动，我甚至不希望在我人生的发展阶段，让父母来干涉过多，所以我要做的首先，那必须是让父母理解我，知道我，这样他们就不会盲目的做出一些出乎我意料的举动，这样我也可以更好的规划未来的发展。</p><p>我会尽量用比较通俗的语言来说明我想说的话题，而不是用一些父母看都看不懂的术语来增加阅读难度。因为我不喜欢“代沟”这个词，我希望我可以与任何年龄的人进行深层次的沟通，从而获得我想要的东西，为了达到这个目的，我觉得我必须学会把话讲的通俗易懂。</p><p>那么接下来还是回到主题，从谈“死学习”“假努力”来讲述一些我认为不合理的社会现象</p><h2 id="从我的童年经历开始谈“死学习”“假努力”"><a href="#从我的童年经历开始谈“死学习”“假努力”" class="headerlink" title="从我的童年经历开始谈“死学习”“假努力”"></a>从我的童年经历开始谈“死学习”“假努力”</h2><p>回想我初中时，班主任经常说我虽然各方面都干的不错，但就是缺乏自主性。我一度自信满满的觉得老师肯定不会说我坏话，因为我把各方面的事情都处理的还算不错，所以我听到老师说我没有自主性的时候，我很惊讶，到现在还记忆犹新。在高三那年，也许是我人生最努力的那段时间里，我也一度思考过自己的自主性问题。只可惜当时没能记录下来，现在没法参考当时的自己的心情。现在大学毕业工作已经一年多了，最近忙于换工作，忙于不停复习行业基础知识以应付面试，就在这种时候，我又开始了关于自主性问题的思考。看来这个问题的解决不是一个容易事，它也许会伴随人的一生，一直思考下去。说的更加虚无一点，也许当我真正想透了这个问题的时候，我可能已经失去了做人的那种实体感也说不定。</p><p>从我小学记事开始，我的生活就没有自主性可言，那时候我最想做的事情无非就是认真完成作业，然后就是偷偷的自我娱乐，有时候听歌，有时候看电视，有时候玩玩电脑游戏。小学的我不知道为什么要学习。不过我的内心深处却明白另一个道理，我如果不好好学习，那么肯定会挨骂，会惨不忍睹。因为我小时候，身边的亲人都提倡一种观念，那就是一定要好好读书，将来才有出息。虽然这个原则换到现在大部分70，80年代当家长的情况下，依旧没有改变。<strong>好好读书，将来才有出息</strong>这句话没错，我从大局观的角度出发，这句话真的一点问题都没有。不过，这句话会产生一种奇怪的后果，这种后果是在我自己的亲身经历上证明了的，那就是会让小孩子觉得，<strong>如果不读书，就会打屁屁，就会被父母骂的很惨</strong>，这应该是我意识到要学习的第一个原因。在潜移默化之中，我慢慢的就把<strong>好好读书，将来才有出息</strong>的真正概念给偷换掉了。然而为什么我会歪曲对好好读书这句话的含义呢？我后来仔细想了想，也许是因为见识太浅的缘故吧。眼见为实耳听为虚，这是每个人都懂的道理。虽然家长们拼命的和你说，读书怎么怎么好，读书将来就有大出息（或者说赚钱），但是小学的我无法理解。小学的我没有亲眼见证一个读书好的人，最后有出息；小学的我从来都是道听途说，“你看别人家的某某某，多有出息”；正因为我内心有这种想法，所以导致我对于“学习”是一种观望的态度，我没有迫切的希望自己去学习。但是最终我还是老老实实开始了小学初中高中，是因为抚养我长大的爸爸妈妈告诉我，学习是好的，他们让我去学习，我不想被骂，所以我努力学习。我是听了自己认为最亲近的人的话，才去学习的。而不是因为学习可以有出息，才去学习的。</p><p>刚刚我思考了自己为什么要”学习“，结论是非常露骨的，因为这个结论不是那种光明的，不是那种高尚的。而只是单纯的因为<strong>如果不读书，就会打屁屁，就会被父母骂的很惨</strong></p><p>针对这个结论，我想了很多，我一直想一直想，反复的想，甚至到最后开始有点自我矛盾，自我混乱。<br>我曾想，可能是我不想让父母失望？没有那么简单</p><p>不过幸运的是，我在中华字典里找到了可以描述这种结论发生原因的词。那就是<strong>危机感</strong></p><h2 id="”假学习“”假努力“背后的危机意识"><a href="#”假学习“”假努力“背后的危机意识" class="headerlink" title="”假学习“”假努力“背后的危机意识"></a>”假学习“”假努力“背后的危机意识</h2><p>人是一个具有危机感的生物，而不同的人对于危机感的感觉是不一样的；一个人危机感的强弱，或多或少的决定了他一生的下限。意思就是说至少危机感强的人肯定在社会上混的不差（除去那些已经抛弃危机感的人）。</p><p>我为什么学习？我小时候每天晚上一回家，第一件事情就是做到自己的位置上，然后打开我的作业本，开始静悄悄的做作业。我最怕的也是最希望的就是奶奶进来给我送吃的，不是说吃的有多好吃，而是因为自己在好好学习的样子能够被奶奶发现。因为我知道奶奶的一些行为习惯，奶奶习惯在父母面前说我的一些情况，所以我最希望的就是奶奶进来，然后看到我好好做作业的样子，然后去给我的父母打小报告，说我在好好写作业。而为什么说我也最怕奶奶进来给我送吃的呢？因为我有时候也会开小差，小时候特别喜欢听音乐，或者QQ和同学聊天,或者玩游戏机，我怕奶奶突然进来，然后发现我在做其他事情。如果这些事情被父母知道了，那肯定就会挨骂，从而我的生活质量肯定就会下降，而那是我不允许发生的事情。</p><p>这些内心描写，其实全都是因为<strong>危机感</strong>在作祟。也许当时的我还没有意识到<strong>危机感</strong>，但是我的本能告诉我，驱使着我努力在亲人面前表现一个比较好的自己。父母给了我居住的环境，父母给了我吃的穿的，我生怕我表现的不够好，导致自己在社会中处于一种比较危险的位置，甚至可能导致最后没得吃没得穿，如果没得吃那就直接导致了我个体的存亡问题。我这么说也许会非常的不人道，因为父母给孩子的一切，也是基于父爱和母爱。但是父爱和母爱怎样伟大，世界上仍然有很多养不起孩子的人，抛弃自己的孩子。我尊重父爱和母爱，它们都是人内心的本能，是一种原动力，这我从养一些小宠物中有点感同身受，虽然我还没有孩子。但是爱是对于有故事的人来说的，而<strong>危机感</strong>是一个刚出生的婴儿都懂的道理，就像小时候的我一样。</p><p>一名北京老师在视频里说，现在的孩子太多的是”假学习“”假努力“，看上去学习很用功，但是实际上却成绩一般。这些问题的缘由我认为都可以用<strong>危机感</strong>去解释。因为我自己以前就是这样的，所以我猜测这些孩子的学习动力可能也是因为<strong>危机感</strong>。他们的学习动力就是<strong>危机感</strong>，只不过他们的<strong>危机感</strong>比一般人要强烈，所以看上去非常拼命，因为他们非常清楚，如果不做到这份上，那么可能会失去自己目前所拥有的一切，可能父母不会给自己买好吃的买好看的，或者可能会剥夺玩手机玩游戏的机会，或者出去和小伙伴玩耍的机会等等。只不过他们不明白，这种靠<strong>危机感</strong>来驱使的学习，不是自主的，只是本能驱使的。我敢断言，如果某一天突然告诉他们，自己的父母要出国出差10多年，但是会远程提供生活补助资金，那么这些孩子将会彻底的从<strong>危机感</strong>中解放出来，因为威胁他们的直接源头不在了，他们会处在一个真空的环境中，不被检测，不被施压，他们可以做自己想做的事情而且不需要担心没法活下去，因为父母会为自己提供远程生活补助资金。这些孩子爱父母，也依赖着父母，但是却不是完全的爱，是片面的爱，因为爱不是一个一句话就可以理解的事情，更不是一年两年就可以领悟的道理，爱只有在长年的酝酿之后才会悄悄的种在人的心里，作为人的原动力，让人变得”失去理智“。</p><h2 id="国内社会流行的”大学无用论“与”假学习“的联系"><a href="#国内社会流行的”大学无用论“与”假学习“的联系" class="headerlink" title="国内社会流行的”大学无用论“与”假学习“的联系"></a>国内社会流行的”大学无用论“与”假学习“的联系</h2><p>在中国，在中流阶层，也就是不偏好也不偏坏，不好不坏的那些人中，非常流行一种说法，那就是”高考好好考，考个好大学就轻松了“。这句话，在现在看来。它是破坏性的，是误人子弟的，因为这种说法曾一度差点毁了我的一生，并且现在还有着各种后遗症纠缠着我</p><p>首先，基于”假学习“的结论，很多孩子是被<strong>危机感</strong>驱使着去学习的，就像我小时候一样。如果把<strong>危机感</strong>比作一条狗，那么这条狗他最希望从你身上得到的是什么呢？ 我想肯定是能够给他一个狗窝，每天可以给他喂点吃的。换个说法就是，给他一套房，每天可以喂吃的，那么人生就足够了。</p><p>我想表达的意思就是：<strong>危机感可以带领我们活下去，甚至到达买房结婚这样的人生目标，但是这是危机感可以带给我们的极限，它不能带领我们走向更远</strong></p><p>在我还是高中的时候，我和好几个前辈聊天，他们几乎都表达了”高考好好考，考个好大学就轻松了“这样的意思。当时的我已经是高三，心智慢慢的成熟，不过依旧还是被这句话带歪了方向。像我这样，一路学习，被<strong>危机感</strong>驱使过来的孩子。一听到这句话，内心是真的无比高兴的。就在高三那段时间里，我变了，我变得无比努力。因为我内心深处把这句话解读为<strong>如果这次努力了，可能就再也不需要为自己的生活瞎操心了</strong>。所以我拼命一般的学习。我记得我高中的时候，一天到晚就在那里做题看书，早上甚至5点不到爬起来，晚上甚至打灯夜读。那时的我已经完全不在乎奶奶来不来检查我是否在认真做作业了，我在乎的只有考好，然后得到梦寐以求的轻松的生活环境。我还曾一度傻傻的觉得自己懂事了，不需要奶奶，爸爸妈妈的监督就能够好好学习了。然而最可笑的事，我居然会把<strong>自己不需要人管着就能够好好学习</strong>这一点当做自己懂事的一个标准。</p><p>虽然我现在还是挺感谢当时努力的自己。但是我仍然要说一句公道话，这是一种不科学的努力方式，是一种极易被破坏的学习方式，是一种典型的国内普遍存在着的，扭曲的学生学习道路。</p><p>为什么说是一种具有破坏性的学习方式？从我上大学以后我慢慢明白了这个道理。上大学后，特别是大一，因为远离父母的管制，然后每个月还有父母的生活费的供给，我可以说我活的确实很轻松，我学着我自认为很喜欢的计算机知识，在休息时间玩着我喜欢的电脑游戏，再也不怕奶奶突然进来催我写作业。我甚至还能在游戏里充点钱，从而提高我的游戏体验。在大学课程上，我小心翼翼的完成必须完成的作业与学习内容，而对于其他不太重要的课程不太关心。我那时特别喜欢“玩手机”，看一些有趣的漫画，聊一些有趣的话题（学习无关）。我还特别喜欢在下课后买一份烤串+橙汁，回宿舍边看电影边吃，最终导致了大学后我的体重开始超标，老妈开始说我胖了。然而我在大一大二过程中表现出的这种散漫的学习态度，其最终缘由我觉得还是初中老师的那句话，那就是我缺乏自主性，也就是“假学习”“假努力”。我相信了亲人口中说的“高考好好考，考个好大学就轻松了”，但是仔细想来这不是父母和我说的，而是表哥表姐说的话。所以我也明白了一个道理，作为父母，对孩子一定不能传播负面消极的思想，要永远保持给孩子输出一个正面的思想，要永远保持告诉孩子做什么是绝对正确的，就比如“学习”，要把自己用时间去证明的好道理及时的告诉孩子，不管你用什么方式，口头也好，书面也罢，总之永远不要停止交流，如果发现交流存在困难，那么最好就像我现在这样，用书面的形式去表达，把大家的思想再次统一到一个水平线上。（我认为告诉孩子学习是一件绝对正确的事情，作为父母，我认为绝对不能向自己的孩子传输不学习也没关系的话）</p><h2 id="兴趣也许可以打败危机意识"><a href="#兴趣也许可以打败危机意识" class="headerlink" title="兴趣也许可以打败危机意识"></a>兴趣也许可以打败危机意识</h2><p>我从初中到高中一直被老师诟病的缺乏自主性，直到我大学毕业才真正理解，并且付出了惨痛的代价。我经过这好几年的洗礼，至少明白了一点，我确实喜欢编程。在我高中填志愿一眼看到“软件工程”的那一瞬间，我才第一次有种为自己学习的感觉。在大学毕业后，我心里就产生了一个梦想，我一直想去实现。但是这个梦想没法转换为消费力，也就是说它可能没法赚到钱，所以我从来只字不提。但是毕竟今天聊到了这份上，那么把它搬出来也是无可奈何的。相比于赚钱糊口，这个小梦想总能在我动摇的时候给我更大的原动力去继续坚持编程。入行以后，我才懂得了这一行水太深，想做到优秀，那付出可不比做个主刀医生简单。但是非常遗憾的是，软件在国内才刚刚红火，不像医生职业那样，有非常清晰的发展方向。做编程，最好的方法只有实战，不停的实战，然后悟出其中的道理，最后达到融会贯通，才算刚刚入门。这也是一开始我没有去考研究生的一部分原因（另一部分原因是我想休息，不想继续学习，我想把我的知识化为生产力）。在随后的工作中，我虽然如愿以偿的赚到了一些钱，但是渐渐地我也发现了这行业的问题，无止境的加班，混乱的行业标准，这些都让我一度对软件这行业彻底失望。不过关键时候让我坚持过来的，不是赚钱，而是我那小小的梦想。</p><p>一旦坚持过来后，我想说的是，原本“假学习”的思想就再也不存在了，我可以坦诚的面对这一切，我甚至可以冷静的分析考研读博的好处，而不是一味的坚持实战至上的理论。我开始不关心自己身边的朋友或者亲人的孩子混的怎么怎么样，攀比的心理逐渐消失。如果他们混的很好，那么我会恭喜他们，而不是眼红他们；如果他们混的不好，那么我开始分析为什么，而不是单纯关心别人，问候别人；以前是父母带着我走，而现在是我开始自己摸索想走的路，虽然我感觉我懂的很晚，但是我觉得这一切都来得及。下一个阶段是我人生真正意义上的第二个阶段，如果你问我你的目标是什么。那么简单点来说，我想有自己的房，有自己的家；但是心灵深处，我比任何人都知道一件事，那就是房子是为了生存，是<strong>危机感</strong>驱使着我行动的第二目标。但是我的那个梦想是真正扶持着我努力的第一目标。</p><p>当然我也知道，有很多人为了赚钱，为了自己的孩子，最后可能放弃了自己的梦想，选择拥抱自己认为的，可以实现的，最快速的赚钱方式去疯狂赚钱。我也知道肯定有一大部分人在当初觉得自己的梦想可以等赚够钱了再去实现也没问题。</p><p>我不知道我在未来会不会被生活的洪流逼得也只能拼命赚钱，但是也正因为如此，我觉得我写这篇文章就更有意义。这篇文章是现阶段我心灵思考的产物，一切东西都是我真实的所想所闻。10年后的自己看到这篇文章会是什么想法呢？我很好奇。</p><h2 id="尾"><a href="#尾" class="headerlink" title="尾"></a>尾</h2><p>总体而言全篇是根据自我经历出发，阐述了当今中国小孩子“假学习”的现状，最后表达个人看法和报复的一篇文章。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客“安全”备份浅谈</title>
      <link href="/2019/05/02/hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E6%B5%85%E8%B0%88/"/>
      <url>/2019/05/02/hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E6%B5%85%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<p>前几天我写了一些自己的hexo博客备份与多环境同时使用的文章，里头记录了自己如何对自己的hexo博客进行备份的。但是我并不是一开始就喜欢备份这玩意，因为毕竟只是一个小小的博客，我个人没有意识到需要进行备份。但是后来自己换了个人电脑后，才亲身感受到备份的重要性，随后我就开始专门弄了一套完整的备份方案，该方案大部分学习借鉴了网上的大部分说法，然后实战过程中结合了自己的一些习惯，免去了一些我觉得暂时不太必要的操作，最终现在这套备份方案已经在成功的运行。最显著的成效就是你现在看到的这篇文章就是在我ubuntu电脑上写的，而前几天的文章是在macpro上写的文章！ 两者切换非常轻松便利解放双手。</p><p>但是昨晚睡觉后我就开始思考这个备份的安全性。</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>由于我的hexo本地数据目前全部备份在一个公有的git库，扔在github上，所以对外来说，我的hexo博客整体都在上面，如果有人要整体copy，那也是一个fork和clone的事情。想到这里后我突然有一点点毛骨悚然，又有点觉得自己过于多虑。毛骨悚然是因为感受到了开源的可怕，会用的人一拿走你的所有代码，就可以完完全全copy你的博客所有内容。过于多虑是因为，我的博客没人看，目前来说考虑这个问题是杞人忧天。</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>所以今天我就只是浅谈下，粗略写一下如何“安全”备份hexo博客个人数据</p><p>我的选择其实很狭窄，在我目前的可知知识看来，我有一般以下几点</p><ol><li>个人硬盘存储</li><li>保存到github的private git库</li><li>使用云盘存储</li></ol><p>从灵活性来说，最好的就是切换到github的private git库，况且现在一个人的私有库已经不收费了，真的没有什么理由不用它</p><p>但是有个问题是，在hexo博客的搭建教程里，所有库都是公有库，hexo是利用了github pages中的User pages来展示内容。那么如果转成private库，是否可以正常使用这个github pages的功能呢？我从github help上找到了一些答案，</p><blockquote><p>GitHub Pages sites are always publicly accessible when published, even if their repository is private, </p></blockquote><p>然后我就信了这句英文，事实上他确实没错！</p><p>但是当我把我的repo转成private后，我发现我的github pages自动关闭了，然后我选择重新开启，发现弹出付款页面。</p><p>后来才得知如果私有库也要同时使用github pages的话，是从Github Free转到了Github Pro，而后者是要付钱的。 </p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>从第2点可知，想白嫖走github这一条路是不行的，所以我后续要去看看有没有其他好用的git库给我用用！此文章后续会做更新</p>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修复ubuntu18.04上的问题Wi-Fi adapter not found（Realtek RTL8821CE）</title>
      <link href="/2019/05/01/%E4%BF%AE%E5%A4%8Dubuntu18-04-Wi-Fi-adapter-not-found/"/>
      <url>/2019/05/01/%E4%BF%AE%E5%A4%8Dubuntu18-04-Wi-Fi-adapter-not-found/</url>
      
        <content type="html"><![CDATA[<p>刚使用ubuntu18.04，在桌面版上想使用wifi的时候，发现显示<br><strong>Wi-Fi adapter not found</strong></p><p>这个是因为我们没有安装网卡驱动程序的缘故</p><p>所以解决此问题的关键是先明确自己电脑是什么无线网卡！</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>首先我们需明确ubuntu所使用的是什么网卡</p><p>使用命令<code>lspci</code>获取我们的network-controller信息。</p><p>我的是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(前面的大量输出省略，找到下面这一行就行)</span><br><span class="line">Network controller: Realtek Semiconductor Co., Ltd. RTL8821CE 802.11ac PCIe Wireless Network Adapter</span><br></pre></td></tr></table></figure></p><p>从中可以看出我的无线网卡是为<strong>Realtek RTL8821CE</strong></p><p>所以我们要安装的是RTL8821CE的网卡驱动程序</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>由于没有wifi，所以你目前没有网络环境，但是为了修复这个问题你必须连接上网络，这个时候你必须先准备好可以上网的有线网络(wired network)</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>打开terminal，先输入如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>先更新您的apt软件包管理工具，防止后续我们安装使用相关软件时不会报出一些神奇的错误</p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>安装下必须的一些软件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install --reinstall git dkms build-essential linux-headers-$(uname -r)</span><br><span class="line">git clone https://github.com/tomaspinho/rtl8821ce</span><br><span class="line">cd rtl8821ce</span><br><span class="line">chmod +x dkms-install.sh</span><br><span class="line">chmod +x dkms-remove.sh</span><br><span class="line">sudo ./dkms-install.sh</span><br></pre></td></tr></table></figure></p><p>上述命令会去</p><ol><li>先安装<br> git(这个不用我解释是什么了吧？)<br> dkms(DKMS是基于动态内核模块支持的可以让开发者无需使用最新的内核版本而对某个单一的内核模块做升级)<br> build-essential（携带编译必须软件包）<br> linux-header-$(uname -r)（重装当前linux内核版本的linux-headers）</li><li>将rtl8821ce的驱动程序clone至本地，相当于我们在windows下载驱动程序一个意思</li><li>进入驱动程序包文件夹</li><li>使用chmod调整相关sh脚本的权限</li><li>运行脚本dkms-install.sh，会自动将rtl8821ce驱动程序安装完毕</li></ol><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>重启ubuntu</p><p>再看看你的wifi配置，应该已经可以使用了！</p><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p>其他你可能遇到的问题</p><p>信号弱，使用关键字<code>weak signal</code>去google上搜查答案吧</p><div id="donationPoint"><div id="licensePoint"></div></div>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在我的双硬盘windows电脑上安装ubuntu18.04-Desktop-LTS</title>
      <link href="/2019/04/30/%E5%9C%A8%E6%88%91%E7%9A%84%E5%8F%8C%E7%A1%AC%E7%9B%98windows%E7%94%B5%E8%84%91%E4%B8%8A%E5%AE%89%E8%A3%85ubuntu18-04-Desktop-LTS/"/>
      <url>/2019/04/30/%E5%9C%A8%E6%88%91%E7%9A%84%E5%8F%8C%E7%A1%AC%E7%9B%98windows%E7%94%B5%E8%84%91%E4%B8%8A%E5%AE%89%E8%A3%85ubuntu18-04-Desktop-LTS/</url>
      
        <content type="html"><![CDATA[<p>在我的thinkpad电脑上安装ubuntu18.04-Desktop-LTS系统，达到windows+ubuntu的双系统环境</p><h2 id="我的电脑配置"><a href="#我的电脑配置" class="headerlink" title="我的电脑配置"></a>我的电脑配置</h2><p>Intel i7-8550U，16GB内存，双硬盘256G的SSD，1T的机械硬盘，BOOT启动模式为UEFI,磁盘分区表模式是GPT，开机进入UEFI BIOS设置按住F12，磁盘分区情况如下：</p><p><img src="https://github.com/zazaluMonster/zazaluMonster.github.io/blob/hexo/themes/hexo-theme-cactus/source/images/tmpImage/%E5%AE%89%E8%A3%85%E5%89%8D%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E6%83%85%E5%86%B5.JPG?raw=true"></p><h2 id="制作ubuntu的U盘启动盘"><a href="#制作ubuntu的U盘启动盘" class="headerlink" title="制作ubuntu的U盘启动盘"></a>制作ubuntu的U盘启动盘</h2><p>准备的材料</p><ol><li>ubuntu18.04-Desktop-LTS.iso镜像文件，在ubuntu官网就可以轻松下载</li><li>一个16GB的u盘</li><li>Rufus，一个启动盘写入软件，官网下载最近版即可</li></ol><p>打开Rufus，按照如下配置：</p><p><img src="https://raw.githubusercontent.com/zazaluMonster/zazaluMonster.github.io/hexo/themes/hexo-theme-cactus/source/images/tmpImage/%E4%BD%BF%E7%94%A8Rufus%E5%88%9B%E9%80%A0U%E7%9B%98%E5%90%AF%E5%8A%A8%E7%9B%98.JPG"></p><p>分区类型选择GPT（因为我windows用的GPT分区），目标系统类型选择UEFI（因为我windows用的就是这个启动方式）<br>文件系统选择FAT32（FAT虽然只支持最高4GB的文件大小，但是兼容性强，所以先选择这个文件系统，后面我会尝试使用NTFS）<br>簇大小我用的默认8192字节(8K)</p><p>点击开始后会弹出选择什么镜像模式写入，选择推荐的ISO镜像<br>完成后u盘启动盘就制作完成了</p><h2 id="为ubuntu准备磁盘空间"><a href="#为ubuntu准备磁盘空间" class="headerlink" title="为ubuntu准备磁盘空间"></a>为ubuntu准备磁盘空间</h2><ol><li>在windows的系统盘C盘中预留10G，用于分配/boot分区（分配多一点，以防万一，如果你的SSD不够大的话，分2G应该就足以了）</li><li>在1T的机械硬盘中分割500G作为ubuntu系统存储使用</li></ol><p>如何分割？<br>使用windows自带的磁盘管理工具，右键压缩卷，输入压缩的大小就是分割出来的磁盘空间（黑色显示未分配的部分）</p><h2 id="禁用快速启动fast-startup"><a href="#禁用快速启动fast-startup" class="headerlink" title="禁用快速启动fast startup"></a>禁用快速启动fast startup</h2><p>我暂时没做，用起来没啥区别，估计底层做了一定处理</p><h2 id="关闭Secure-Boot功能"><a href="#关闭Secure-Boot功能" class="headerlink" title="关闭Secure Boot功能"></a>关闭Secure Boot功能</h2><p>由于过去 cracker 经常借由 BIOS 开机阶段来破坏系统，并取得系统的控制权，因此 UEFI加入了一个所谓的安全启动 （secure boot） 机制。<br>但是这个机制容易导致linux系统无法顺利开机，所以需要进行关闭</p><p>关闭方式：<br>重启电脑，按住F12打开BIOS界面，在该界面找到Secure Boot，改成disabled，然后保存重启即可（不同主版也许不同，具体请自己上网查询）</p><h2 id="正式安装ubuntu"><a href="#正式安装ubuntu" class="headerlink" title="正式安装ubuntu"></a>正式安装ubuntu</h2><ol><li>插入我们u盘启动盘！</li><li>开机，按住f12！选中自己的USB设备，回车运行</li><li>选择install ubuntu</li><li>中间什么语言，键盘设定我就不做说明了，选自己喜欢的就行，最好english，可以提高自己</li><li><p>分区配置：<br> 在SSD的未分配空间分：</p><p> /boot,至少2G,我给了10G,Logical逻辑分区(因为我的boot分区放在windows的SSD盘里，而这个SSD盘已经有windows的主分区了，所以这里我们选逻辑分区即可)<br> 在HHD的未分配空间分：</p><p> /,至少15000MB，我给20G，逻辑分区（但是随后我使用后发现20G也不够用，因为一些常用软件会全部存放至<code>/opt</code>这个文件夹，比如chrome，网易云音乐等，建议多分配一点）</p><p> /swap,你电脑实际内存(RAM)的两倍，不过很多资料说基本不需要了，所以就随便给了16G，逻辑分区</p><p> /home,因为就我一个人用，所以把剩下的所有空间都放给这个用户文件夹，逻辑分区</p><p> 所有分区位置都选择从头位置开始（beginning of the space）</p><p> 最后一栏：<br> Device for boot loader installation:<br> 选择刚刚我们分配的/boot对应的那个Device，意思就是把启动程序都装到那里</p><p> 下面放2张参考图<br> <img src="https://github.com/zazaluMonster/zazaluMonster.github.io/blob/hexo/themes/hexo-theme-cactus/source/images/tmpImage/boot%E5%88%86%E5%8C%BA%E9%85%8D%E5%A5%BD%E5%90%8E%E6%88%AA%E5%9B%BE.png?raw=true" title="boot分区配好后"></p><p>  <img src="https://raw.githubusercontent.com/zazaluMonster/zazaluMonster.github.io/hexo/themes/hexo-theme-cactus/source/images/tmpImage/root%E5%88%86%E5%8C%BAhome%E5%88%86%E5%8C%BAswap%E5%88%86%E5%8C%BA%E9%85%8D%E5%A5%BD%E5%90%8E.png" title="root分区home分区swap分区配好后"></p><p> 全部搞定后点击下一步！</p></li><li>设置用户</li><li>等待安装完成，安装完成后提示重启</li><li>开机后会自动先进入UEFI界面，然后选择启动ubuntu即可</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此为止，我个人在双硬盘windows上安装ubuntu18.04-Desktop-LTS的流程已经完毕，上面所描述的步骤都是我亲手秩序的过程，最后成功安装完毕</p><p>参考：</p><ol><li><a href="http://myviewsonfoss.blogspot.com/2018/05/this-article-willshow-you-how-you-can.html" target="_blank" rel="noopener">http://myviewsonfoss.blogspot.com/2018/05/this-article-willshow-you-how-you-can.html</a></li><li><a href="https://blog.csdn.net/love666666shen/article/details/80947903" target="_blank" rel="noopener">https://blog.csdn.net/love666666shen/article/details/80947903</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客多环境同步使用</title>
      <link href="/2019/04/30/hexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%90%8C%E6%AD%A5%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/04/30/hexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%90%8C%E6%AD%A5%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>最近自己可使用的机子多起来了，一台windows，一台mac，一台ubuntu。windows我目前是纯娱乐，mac是之前大学时候常用的电脑，ubuntu是之前为了加强自己对linux系统的好感度最近才买的机子，准备未来在这个机子上做主要IT开发任务（还很年轻还能挖坑.jpg）</p><p>但是机子多了也带了一定的困扰，我其实是一个爱记录的人，之前做记录一般都是在mac上做，但是因为最近想学一些新语言的练习开发项目，mac这台电脑内存过小（仍在考虑这台仍可以使用但是性能已经不佳的mac该如何处理，后续如何让它起到一定价值，还在思考中），我有点用的不舒服，所以自己弄了一台16G内存来专门负责以后的学习工作兼并开发的电脑。为了方便起见，我肯定会将博客相关的全部挪到ubuntu上去做。不过一直觉得mac用起来非常舒服，估计在写一些非技术文章的时候还是会考虑打开mac来写。</p><p>所以就有了可以同时在mac和ubuntu上写博客的需求。今天就简单的写一下实现思路。</p><h2 id="hexo本地数据同步"><a href="#hexo本地数据同步" class="headerlink" title="hexo本地数据同步"></a>hexo本地数据同步</h2><p>hexo博客在不同环境想要同步使用，最关键的一点就是hexo data的同步，也就是你的那些文章，主题，配置文件。这些文件是hexo博客的自定义数据，无法从别人那里拿到，也无法从hexo官网拿到，我这里就把这些数据归类为本地数据。</p><p>当你换一台电脑，虽然可以非常简单的重新搭建hexo博客环境，但是如果不同步之前的本地数据，那么这个新搭建的hexo博客就和新的hexo博客没区别。</p><p>绕了一大圈，总结来说，想要从一台电脑转到另一台电脑，然后实现hexo博客的转移，最根本的要素就是本地数据的转移。</p><p>那么我们如何做到本地数据的转移呢？</p><ol><li>使用便携式硬盘，比如u盘，拷贝你的本地数据，然后转到新的电脑上。</li><li>使用现在流行的云端存储，那么只要有网络的情况下，不管是什么环境，你都可以轻松的同步你的hexo博客</li></ol><p>u盘这种形式我最早就用过，但是缺点有很多，最明显的缺点就是同步率低而且麻烦，只适合用于转移使用环境，比如你从一台电脑转移到另一台，并且从此不在之前的电脑上进行hexo博客使用<br>所以将hexo本地数据云备份是最好的办法，它不仅可以让我们实时的进行本地数据同步，并且可以有网络的机子上快速搭建，无需考虑其他u盘等什么麻烦的要素。</p><h2 id="hexo本地数据云端管理实现思路"><a href="#hexo本地数据云端管理实现思路" class="headerlink" title="hexo本地数据云端管理实现思路"></a>hexo本地数据云端管理实现思路</h2><p>上小节我谈到，最好的hexo本地数据管理方式是云端管理，那么如何这个云端管理如何运行呢？它的整体架构是怎么样的呢？</p><ol><li><p>选择一款好用的云端存储软件，目前来看最切合的还是github，因为hexo博客的view层数据本身就是存在github上的，然后通过gitpage.io去展现的。使用github提供的远端git库，我们就可以很方便把hexo博客运行和本地数据统一管理起来。</p></li><li><p>将本地数据存至远端git库，这一步其实也完成了hexo本地数据备份的功能，具体操作可以见“hexo备份之路”</p></li><li><p>每次在本地想写文章的时候，先进行git远端库和本地库的数据同步操作（git pull），让本地数据和远端git库一致，并且始终已远端git库作为自己父类数据，本地的数据只看成子类数据，每次在本地完成新文章编写后，将最新的数据提交到远端git库（git push），实现父类数据的更新。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总而言之，hexo多环境同步使用的核心思路就是</p><ol><li>云端存储本地数据</li><li>每次更改前先将从云端同步数据到本地，每次更改完后将本地数据提交到云端</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>虽然思想很简单，但是还是说一些注意事项</p><ol><li><p>git相关代码会产生较多而且固定化，建议使用shell脚本，将所有命令整合成一个语句</p></li><li><p>由于使用了git，所以要遵守代码管理软件的通用规则，那就是必须先更新再提交，以免造成云端数据问题</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo备份之路</title>
      <link href="/2019/04/25/hexo%E5%A4%87%E4%BB%BD%E4%B9%8B%E8%B7%AF/"/>
      <url>/2019/04/25/hexo%E5%A4%87%E4%BB%BD%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>前阵子，我的hexo博客丢失源文件，吃了没有备份的源文件的苦头，所以现在我的hexo博客已经加上了备份机制，使其更加健壮了，本文将记录如何方便的进行hexo备份</p><p>适用hexo版本 4.x<br>查阅此文档前，您必须保证您已经阅读完毕hexo的官方文档，并且已经实际操作过，不然阅读以下的文字会让你理解上有点困难</p><h2 id="hexo备份步骤"><a href="#hexo备份步骤" class="headerlink" title="hexo备份步骤"></a>hexo备份步骤</h2><ol><li><p>在一个新的文件夹(A文件夹)内使用git去clone你的github上的远程hexo库(yourgitname.github.io)，完成后A文件夹内会出现一个clone后的git库文件夹(yourgitname.github.io),点击进入后，里面是hexo用于生成网页的文件结构，而非hexo本地源文件。</p></li><li><p>打开浏览器，进入自己的github，为自己的远程hexo库建立一个分支，最好名为hexo，并将其设为默认分支（方便我们后续提交）。随后我们需要在这个分支内创建一个.gitignore文件。因为新版本hexo在执行<code>hexo init</code>等一系列建站脚本后，会在本地已经为你创建了一个.gitignore文件了，其文件内容就是我们想要的，将其内容复制到刚刚我们新创建的.gitignore文件内并上传至hexo分支即可（如何创建分支自行百度）</p></li><li><p>hexo分支准备完成后，我们就可以在我们cmd界面使用<code>git checkout  hexo</code>将分支切到hexo分支，然后将我们的hexo源文件复制到这里，复制完成后将这些文件一并上传至远程hexo分支即可。到此就完成了hexo备份。现在我们就可以在本地的hexo分支环境下直接写新文章，写完后上传hexo分支，最后使用<code>hexo d</code>，让hexo脚本自动将生成后的文件上传至master分支。最后github上的hexo库的2个分支就完美的呈现它们的价值了，hexo分支内可以看到我们的本地源文件，master分支上就保存着<code>hexo d</code>对应的那些文件用于直接排版我们的网页</p></li><li><p>以防万一，我们最好在本地也对我们的源文件进行归档备份</p></li></ol><h2 id="后续每次写完新文章后需要执行的shell指令"><a href="#后续每次写完新文章后需要执行的shell指令" class="headerlink" title="后续每次写完新文章后需要执行的shell指令"></a>后续每次写完新文章后需要执行的shell指令</h2><ol><li>git add <newfile></newfile></li><li>git commit -m “备份”</li><li>git push origin hexo</li><li>hexo g</li><li>hexo d</li></ol><h2 id="加入gitee后的新增操作指令-2019-9-24"><a href="#加入gitee后的新增操作指令-2019-9-24" class="headerlink" title="加入gitee后的新增操作指令 2019.9.24"></a>加入gitee后的新增操作指令 2019.9.24</h2><p>我目前把自己的博客在gitee pages上也弄了一份，目的是为了借助下gitee在国内访问比较快的优点。</p><p>所以现在要额外备份gitee的版本</p><p>如果是新的机子,按顺序做如下操作即可</p><ol><li>安装git和hexo</li><li>git init  +  git remote add origin ‘github repo url’ + git remote add gitee ‘gitee repo url’</li><li>git pull origin hexo 把hexo文件全部拉取过来</li></ol><p>到这里为止我估计环境就ok了，那么每次写完新文章如果想顺便做备份的话，其shell指令就如下:</p><ol><li>git add <newfile></newfile></li><li>git commit -m “backup”</li><li><ul><li>git push origin hexo</li><li>git push gitee hexo</li></ul></li><li>hexo g</li><li>hexo d</li><li>node ./comment.js #用于自动化初始化gitalk的issue，不一定每次都要执行</li></ol>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019我的个人电脑机械硬盘问题引发的故事</title>
      <link href="/2019/04/24/2019%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E8%84%91%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98%E9%97%AE%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%95%85%E4%BA%8B/"/>
      <url>/2019/04/24/2019%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E8%84%91%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98%E9%97%AE%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%95%85%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p>最近一直用着的MBP，突然机械硬盘出现问题，导致部分数据丢失，其中就包括了我的博客源文件。最早开发我自己博客的时候，写了一大堆自定义css和js文件，且当时没有良好的打包备份思想，导致今天让自己跳进坑里。</p><p>hexo博客源文件丢失后，唯一能找回的数据只剩下github上，每次deploy的时候上传的那些文件。</p><p>但是那些是模版技术在本地执行后生成好的完整的html文件，打开一看，自然里面排版异常难看，想把自己的数据找回着实不易。</p><p>最后自己干脆把网页显示后上的文字通通复制到本地，然后在本地重新初始化了hexo相关配置，经过了几个小时的奋斗，总算把自己的博客内容失而复得。虽然那些看上去好玩的css和js不见了，但是现在想来，那些东西都是没有啥参考意义的乱码罢了，故舍弃之。转而从新选择了一个风格简单的主题作为今后的blog主打风格。同时也转移了live2d看伴娘的模块（觉得唯一值得保护的一个模块）。</p><p>因为不想再吃源代码丢失的苦痛，这次使用了备份分支，专门将本地源文件也上传至github，今后就可以放心了</p><p>差不多就这些,后续可能会针对hexo博客备份专门写一篇操作文档进行记录</p>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用JavaSeurity进行数字签名(二)</title>
      <link href="/2019/04/24/%E4%BD%BF%E7%94%A8JavaSeurity%E8%BF%9B%E8%A1%8C%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-%E4%BA%8C/"/>
      <url>/2019/04/24/%E4%BD%BF%E7%94%A8JavaSeurity%E8%BF%9B%E8%A1%8C%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>在上一章中，我们使用JavaSeurityAPI对dsaSignFile文件进行了一次数字签名，并且将其数字签名以及公钥都保存到了本地硬盘的相应文件中。作为发送方，我们通过各种“交通”手段，将这三个文件一一发给了接收方。在本章我们就来展示接收方如何使用这三个文件，对数字签名进行验证，最终确定dsaSignFile的确实是由发送方发出的</p><blockquote><p>什么是验签</p></blockquote><p>接收方获取到原数据文件，公钥文件，数字签名文件后，使用这三个文件便可以完成验签。验签的基本流程简单来说如下</p><ol><li>使用公钥文件将数字签名还原为散列值A</li><li>使用加签时相同的算法获取原数据文件的散列值B</li><li>对比A和B是否一致，若一致便说明数字签名正确，该文件确实是发送方发出，而不是由别人篡改后发出的</li></ol><blockquote><p>JavaSeurity进行验签</p></blockquote><p>1.使用公钥文件获取公钥<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PublicKey <span class="title">getPubFromPubFile</span><span class="params">(File pubFile)</span> <span class="keyword">throws</span> IOException, NoSuchAlgorithmException, InvalidKeySpecException </span>&#123;</span><br><span class="line">        <span class="comment">//从文件中获取公钥字节数据</span></span><br><span class="line">        FileInputStream keyfis = <span class="keyword">new</span> FileInputStream(pubFile);</span><br><span class="line">        <span class="keyword">byte</span>[] encKey = <span class="keyword">new</span> <span class="keyword">byte</span>[keyfis.available()];</span><br><span class="line">        keyfis.read(encKey);</span><br><span class="line">        keyfis.close();</span><br><span class="line">        <span class="comment">//先将公钥字节数据转换为key specification，只有key specification才能使用KeyFactory转化为PublicKey Object</span></span><br><span class="line">        <span class="comment">//key specification你可以理解为密钥的一种格式，是密钥字节数据的升级</span></span><br><span class="line">        X509EncodedKeySpec pubKeySpec = <span class="keyword">new</span> X509EncodedKeySpec(encKey);</span><br><span class="line">        <span class="comment">//使用KeyFactory，通过key specification获取PublicKey Object</span></span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        PublicKey pubKey = keyFactory.generatePublic(pubKeySpec);</span><br><span class="line">        <span class="keyword">return</span> pubKey;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>2.使用数字签名文件获取数字签名字节数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] getSignatureBytesFromSignFile(File signFile) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        FileInputStream sigfis = <span class="keyword">new</span> FileInputStream(signFile);</span><br><span class="line">        <span class="keyword">byte</span>[] sigToVerify = <span class="keyword">new</span> <span class="keyword">byte</span>[sigfis.available()];</span><br><span class="line">        sigfis.read(sigToVerify);</span><br><span class="line">        sigfis.close();</span><br><span class="line">        <span class="keyword">return</span> sigToVerify;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>3.使用原数据，公钥，数字签名字节数据验证正确性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">verifySignature</span><span class="params">(PublicKey publicKey,File dataFile,<span class="keyword">byte</span>[] sigToVerify)</span> <span class="keyword">throws</span> NoSuchAlgorithmException, InvalidKeyException, IOException, SignatureException </span>&#123;</span><br><span class="line">        <span class="comment">//这次我们使用公钥初始化签名器</span></span><br><span class="line">        Signature sig = Signature.getInstance(<span class="string">"SHA1withRSA"</span>);</span><br><span class="line">        sig.initVerify(publicKey);</span><br><span class="line">        <span class="comment">//将原数据导入签名器</span></span><br><span class="line">        FileInputStream datafis = <span class="keyword">new</span> FileInputStream(dataFile);</span><br><span class="line">        BufferedInputStream bufin = <span class="keyword">new</span> BufferedInputStream(datafis);</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> (bufin.available() != <span class="number">0</span>) &#123;</span><br><span class="line">            len = bufin.read(buffer);</span><br><span class="line">            sig.update(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        bufin.close();</span><br><span class="line">        <span class="comment">//使用签名器进行验证</span></span><br><span class="line">        <span class="keyword">boolean</span> verifies = sig.verify(sigToVerify);</span><br><span class="line">        <span class="keyword">return</span> verifies;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>4.前三步整合为一个验签程序如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">verifySign</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException, IOException, InvalidKeySpecException, SignatureException, InvalidKeyException </span>&#123;</span><br><span class="line">        String pubKeyDataFileUrl = <span class="string">"src/test/resource/pubKeyData"</span>;</span><br><span class="line">        PublicKey publicKey = getPubFromPubFile(<span class="keyword">new</span> File(pubKeyDataFileUrl));</span><br><span class="line">        String signDataFileUrl = <span class="string">"src/test/resource/signData"</span> ;</span><br><span class="line">        <span class="keyword">byte</span>[] sigToVerify = getSignatureBytesFromSignFile(<span class="keyword">new</span> File(signDataFileUrl));</span><br><span class="line">        String dsaSignFileUrl = <span class="string">"src/test/resource/dsaSignFile"</span> ;</span><br><span class="line">        <span class="keyword">boolean</span> verifies = verifySignature(publicKey,<span class="keyword">new</span> File(dsaSignFileUrl),sigToVerify);</span><br><span class="line">        System.out.println(<span class="string">"signature verifies: "</span> + verifies);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>存在的隐患</p></blockquote><p>到目前为止，使用Java进行加签验签的过程已经全部测试完毕了，但是在我们的这个流程中存在一个隐患。那就是我们不能确保接收方获得的公钥文件是正确的。</p><p>打个比方，如果发送方在发出原数据，公钥文件，数字签名文件后，被中间人拦截。中间人为了达到自己的目的，篡改了原数据的内容，并且使用自己的私钥重新生成了一份新的数字签名文件，并且把公钥文件也替换为自己的公钥文件。然后将这三个文件再发送给接收方。接收方的验签过程并不会报错，从而导致接收方将错误的信息信以为真。</p><p>为了避免这样的情况发生，目前的解决方法之一就是使用数字证书。一个数字证书是由国际上公认的机构进行颁发，每个数字证书中包含了发送方的公钥，以及一个该证书内容的数字签名。接收方则在本地密钥库中寻找该数字证书所对应的公钥数据，如果存在，则使用它解开这个数字证书，随后拿到发送方的公钥。这个过程中最终我们的信任方是计算机本地存储的受信任的根证书列表，只要保证它的正常运作，那么就不会发生被人篡改的情况</p><blockquote><p>小节<br>java的数字签名练习就到此结束了。本来我还想着写一下RSA加解密，但是发现其实在流程本质上和数字签名是一致的，所以就不浪费时间重新赘述了</p></blockquote><div id="donationPoint"><div id="licensePoint"></div></div>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> signature </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用JavaSeurity进行数字签名(一)</title>
      <link href="/2019/04/24/%E4%BD%BF%E7%94%A8JavaSeurity%E8%BF%9B%E8%A1%8C%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-%E4%B8%80/"/>
      <url>/2019/04/24/%E4%BD%BF%E7%94%A8JavaSeurity%E8%BF%9B%E8%A1%8C%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>Hello,my blog.好久不见.由于最近项目有些地方有涉及到数字签名,RSA加解密,数字证书等东西.虽然对其不太了解,也没有过多的影响到自己的开发,但是抱着一颗好奇的心,对其相关知识进行了网上冲浪,现在对自己所看到的相关资料,进行自我整理以及消化.在这一章,你将了解到[什么是数字签名] [什么是公钥私钥] [JAVA如何生成公钥私钥进行数字签名]</p><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><blockquote><p>数字签名何时诞生? </p></blockquote><p>1976年，Whitfield Diffie 和 Martin Hellman 两人第一次提出了数字签名的概念，当时虽然他们并没有现成的方法去得到数据的数字签名，但是他们推测可以使用相关数学函数去进行计算获取 到数字签名，这个方案是可行的。随后不久， Ronald Rivest, Adi Shamir, 和 Len Adleman便研究出了RSA算法，这是一个可以生成数字签名的算法(虽然当时RSA算法得到的数字签名被公认为还是不安全的)最后第一个可以为指定数据生成数字签名的软件包诞生， Lotus Notes 在1989年将其发布。</p><blockquote><p>数字签名是什么</p></blockquote><p>简单来说，数字签名就是使用公认可靠的签名算法，使用公钥加密技术，生成一段数据的一串散列值。比如<code>hello,zazalu</code>这串数据的数字签名就类似于<code>BE459576785039E8</code>，我们可以将这一串值理解为非常难以破解的东西。</p><blockquote><p>数字签名的用武之地在哪里</p></blockquote><p>我用一个生活中的简单例子来做个比喻.</p><p>当我们收到自己爱人的来信时，激动不已的你急忙打开并且进行阅读。在这个简单的环节中，人的大脑其实自动帮你做了一个简单的验签的过程，你在看到那些熟悉的字体，熟悉的称呼或者一个简单的暗号后，你就为潜在的认为这封信确实是你的爱人写的，因为只有你熟悉他(她)的写法，只有你才知道暗号的含义。</p><p>数字签名其实起到的就和“暗号”“写法”这类东西类似，都是用来证明发件人确实是你爱人用的。在没有数字签名之前，我们在网上收到一封重要文件，虽然系统提示你发件人为A，但是并不代表真的是A，有可能是B正好偷偷用A的电脑发的也说不定。总而言之，在没有数字签名的时候，你无法确定发件人是谁。而数字签名就是起到证明发件人确实是A的作用的东西。</p><blockquote><p>数字签名如何生成？</p></blockquote><p>在前面，我有说到，数字签名是使用公认可靠的签名算法，使用公钥加密技术，为数据生成一串散列值。那么具体是怎么样的呢？</p><p>首先我们来简单说明下公钥加密技术，目前我们常用于数字签名的公钥加密技术有两种，一个是RSA，还有一个是DSA。不过在进行数字签名这方面，他们的行为在语言描述上是一致的，这里也就不做区分说明。</p><p>不管是RSA还是DSA算法，他们都需要两个密钥，一个叫公钥，一个叫私钥。使用加密算法前，我们需要先使用相关算法库，生成一对密钥对，使用公钥加密的信息只能由私钥进行解密</p><p>是的，由于公钥是公有的，谁都能获取，所以按逻辑上来说，我们不应该使用私钥进行加密。但是我们却可以利用这一点来验证这串数据是由谁加密的，因为私钥是保密的。我使用私钥生成一串数字签名，那么只要使用我的公钥解析数字签名并且使用相同算法比较数据的散列值，如果是一样的，就说明这个数据就确实是由我发出的，不会有假。这也就说明了数字签名的有效性，可靠性。</p><blockquote><p>参考</p></blockquote><p>上面几节，不知道讲没讲明白，但是我已经把我自己的理解全部整理了一遍，如果您还是不理解，不妨可以试试下面链接，都说明的不错</p><ol><li><a href="https://security.stackexchange.com/questions/66392/why-should-i-sign-data-thats-already-encrypted" target="_blank" rel="noopener">https://security.stackexchange.com/questions/66392/why-should-i-sign-data-thats-already-encrypted</a></li><li><a href="https://docs.oracle.com/javase/tutorial/security/apisign/step3.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/security/apisign/step3.html</a></li><li><a href="https://www.jianshu.com/p/090e35989501" target="_blank" rel="noopener">https://www.jianshu.com/p/090e35989501</a></li></ol><h2 id="JAVA如何生成数字签名"><a href="#JAVA如何生成数字签名" class="headerlink" title="JAVA如何生成数字签名"></a>JAVA如何生成数字签名</h2><blockquote><p>获取RSA密钥对的接口方法getRSAKeyPair</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> KeyPair <span class="title">getRSAKeyPair</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException</span>&#123;</span><br><span class="line">    <span class="comment">//获得一个密码随机数生成器(用于密钥生成),使用SecureRandom以及SHA1PRNG </span></span><br><span class="line">    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(<span class="string">"RSA"</span>);<span class="comment">//获得密钥生成器,java语言使用KeyPairGenerator</span></span><br><span class="line">    <span class="comment">//SHA1PRNG意思便是使用SHA1密码散列函数,来生成伪随机数,PRNG = pseudo random number generator  </span></span><br><span class="line">    <span class="comment">// 有兴趣的同学可以进行深入研究, 这里不会探讨此问题        </span></span><br><span class="line">    <span class="comment">//我们的示例使用SHA1,当然你也可以试试SHA-2，SHA-3       </span></span><br><span class="line">    SecureRandom random = SecureRandom.getInstance(<span class="string">"SHA1PRNG"</span>);</span><br><span class="line">    <span class="comment">//初始化1024位密钥生成器       </span></span><br><span class="line">    keyGen.initialize(<span class="number">1024</span>,random);        </span><br><span class="line">    <span class="comment">//生成公钥私钥      </span></span><br><span class="line">    <span class="keyword">return</span> keyGen.generateKeyPair();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用我们刚刚生成的密钥对去生成指定文件的数字签名,getFileSignature接口参数,file为你指定的文件,keypair为你使用getRSAKeyPair生成的密钥对</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Signature <span class="title">getFileSignature</span><span class="params">(File file,KeyPair keyPair)</span> <span class="keyword">throws</span> NoSuchAlgorithmException, InvalidKeyException, IOException, SignatureException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(file == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取一个签名器,注意：生成密钥对的时候使用的是什么非对称加密算法和什么散列函数,String参数就填写对应"XXXXwithXXX"</span></span><br><span class="line">        <span class="comment">//e.g. DSA密钥对,使用SHA1PRNG,则为"SHA1withDSA"</span></span><br><span class="line">        Signature dsa = Signature.getInstance(<span class="string">"SHA1withRSA"</span>);</span><br><span class="line">        <span class="comment">//使用私钥初始化签名器,注意：请不要使用公钥初始化,只有私钥才能用来生成数字签名</span></span><br><span class="line">        PrivateKey priv = keyPair.getPrivate();</span><br><span class="line">        dsa.initSign(priv);</span><br><span class="line">        <span class="comment">//使用签名器的update方法将要进行签名文件的数据导入到签名器中(光看api就感觉很类似导入的感觉,所以就这么说明了,如有违和的地方请指正)</span></span><br><span class="line">        dsa = updateDsaSignture(dsa,file);</span><br><span class="line">        <span class="comment">//获取数字签名</span></span><br><span class="line">        <span class="keyword">return</span> dsa;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将文件数据导入至签名器中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dsa 签名器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file 需进行签名的文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Return</span>: dsa 数据导入完毕的签名器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Creator</span>: hejj</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Signature <span class="title">updateDsaSignture</span><span class="params">(Signature dsa,File file)</span> <span class="keyword">throws</span> IOException, SignatureException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        BufferedInputStream bufin = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bufin.read(buffer)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            dsa.update(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        bufin.close();</span><br><span class="line">        <span class="keyword">return</span> dsa;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>把数字签名和公钥保存到本地</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveSignature</span><span class="params">(File signFile, Signature signature)</span> <span class="keyword">throws</span> IOException, SignatureException, NoSuchAlgorithmException, InvalidKeyException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(signFile == <span class="keyword">null</span>)&#123;</span><br><span class="line">            signFile = <span class="keyword">new</span> File(<span class="string">"../resource/signFile"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(signFile.exists())&#123;</span><br><span class="line">            signFile.delete();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            signFile.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputStream sigfos = <span class="keyword">new</span> FileOutputStream(signFile);</span><br><span class="line">        sigfos.write(signature.sign());</span><br><span class="line">        sigfos.close();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">savePublicKey</span><span class="params">(File pubKeyFile, PublicKey publicKey)</span> <span class="keyword">throws</span> NoSuchAlgorithmException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pubKeyFile == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pubKeyFile.exists())&#123;</span><br><span class="line">            pubKeyFile.delete();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pubKeyFile.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] key = publicKey.getEncoded();</span><br><span class="line">        FileOutputStream keyfos = <span class="keyword">new</span> FileOutputStream(pubKeyFile);</span><br><span class="line">        keyfos.write(key);</span><br><span class="line">        keyfos.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>将所有接口整合，运行起来的demo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signFile</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException, InvalidKeyException, IOException, SignatureException </span>&#123;</span><br><span class="line">    MyRsaDsaUtil rsaDsaUtil = <span class="keyword">new</span> MyRsaDsaUtil();</span><br><span class="line">    <span class="comment">//获取密钥对</span></span><br><span class="line">    KeyPair keyPair = rsaDsaUtil.getRSAKeyPair();</span><br><span class="line">    <span class="comment">//获取文件签名(请先预创建自己的rsaSigndFile文件)</span></span><br><span class="line">    String signFilePath = URLDecoder.decode(MyRsaDsaUtil.class.getResource(<span class="string">"../resource/rsaSignFile"</span>)</span><br><span class="line">            .getFile(),<span class="string">"utf-8"</span>) ;</span><br><span class="line">    Signature signature = rsaDsaUtil.getFileSignature(<span class="keyword">new</span> File(signFilePath),keyPair);</span><br><span class="line">    <span class="comment">//保存文件签名 保存后才能发送给别人哦</span></span><br><span class="line">    String signDataFileUrl = <span class="string">"src/test/resource/signData"</span> ;</span><br><span class="line">    String pubKeyDataFileUrl = <span class="string">"src/test/resource/pubKeyData"</span>;</span><br><span class="line">    rsaDsaUtil.saveSignature(<span class="keyword">new</span> File(signDataFileUrl),signature);</span><br><span class="line">    rsaDsaUtil.savePublicKey(<span class="keyword">new</span> File(pubKeyDataFileUrl),keyPair.getPublic());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>本章我们先从数字签名的基础知识讲起，随后用了实际代码例子进行了练习，现在我们应该都已经学会了使用java生成某个文件的数字签名！</p><p>在下一章中，我们将作为文件接收者，去验证这个数字签名是否正确，从而完成一整个使用数字签名验证发件人有效性的整个流程。</p><div id="donationPoint"><div id="licensePoint"></div></div>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> signature </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo next主题自定义css格式切换</title>
      <link href="/2019/04/24/hexo-next%E4%B8%BB%E9%A2%98%E8%87%AA%E5%AE%9A%E4%B9%89css%E6%A0%BC%E5%BC%8F%E5%88%87%E6%8D%A2/"/>
      <url>/2019/04/24/hexo-next%E4%B8%BB%E9%A2%98%E8%87%AA%E5%AE%9A%E4%B9%89css%E6%A0%BC%E5%BC%8F%E5%88%87%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>当我每次想要进行自己的hexo next博客的外观变更的时候,每次都需要去修改配置文件,会非常的麻烦,而且容易忘记.所以自己稍微研究了下,做了一些bat批处理文件,用于控制博客的页面外观(css)的自动转换.比如新年的时候,就切换到新年的配置文件.</p><p>本文档主要就是简单记录下,防止自己未来忘记了,强烈建议其他阅读者不要读此文档，大概率你看不懂写的什么东西</p><blockquote><p>适用版本<br>hexo版本：3.3.9<br>nexT版本: 5.0.0<br>可能最新的版本不符合本文档的描述，若你使用的是别的主题，使用举一反三的思考方式，其实也是类似的</p></blockquote><h2 id="hexo-nexT主题自定义css配置文件"><a href="#hexo-nexT主题自定义css配置文件" class="headerlink" title="hexo-nexT主题自定义css配置文件"></a>hexo-nexT主题自定义css配置文件</h2><p>nexT主题自定义css配置文件路径: <code>themes\next\source\css\_custom\custom.styl</code></p><p>修改custom.styl中文件内容 重新部署hexo后即可看到修改后的css效果.</p><h2 id="创建css格式切换临时文件夹"><a href="#创建css格式切换临时文件夹" class="headerlink" title="创建css格式切换临时文件夹"></a>创建css格式切换临时文件夹</h2><p>在themes\next\source\css_custom下 可以自行创建一个css格式切换文件夹</p><p>比如我创建的就是<br><code>themes\next\source\css\_custom\themes</code></p><p>目前我在其中放置了两个版本的css配置文件</p><p><code>custom_new_year.styl</code><br><code>custom_normal.styl</code><br>分别对应新年版本css配置文件和普通版本的css配置文件</p><h2 id="创建bat批处理文件"><a href="#创建bat批处理文件" class="headerlink" title="创建bat批处理文件"></a>创建bat批处理文件</h2><p>使用批处理文件 其功能是可以将custom_*.styl文件移动到<code>themes\next\source\css\_custom</code><br>下并且重命名为custoom.styl即可<br>这个批处理文件就是将css切换为新年模式的一个很简单的bat脚本.</p>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017俺の年终总结</title>
      <link href="/2019/04/24/2017%E4%BF%BA%E3%81%AE%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
      <url>/2019/04/24/2017%E4%BF%BA%E3%81%AE%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>终于迎来了学业生涯结束后的第一个春节!非常感谢自己踏在这样美好的人生转折点上,这一年里,我有欢笑也有泪水(虽然我已不记得上一次哭是什么时候了哈哈),这一年里我完成了许多事,也做砸了许多事;这一年里我告别了许多人,我也认识了许多人;这一年里我见识到了许多事,也对社会的很多事感觉失望.2017注定对我而言注定是特殊的,有太多值得我去记录和分享的东西在那里!在这个安静的傍晚时光里,就让我全部一点点的记录下来吧!</p><h2 id="先从毕设开始说吧"><a href="#先从毕设开始说吧" class="headerlink" title="先从毕设开始说吧"></a>先从毕设开始说吧</h2><p>2017年的开头,就先从毕设说起吧.2017年上半年基本都在为毕设忙碌了.身为西电软件学院的一名普通学生,毕设自然而然是要做一个软件作为自己毕业的答卷! 我不是一个非常优秀的学生,成绩也一般般,对软件稍有兴趣但是大学四年也是经常东张西望,真正学到的东西很少,基础知识非常不扎实.所以当时就”抢”到了一个比较简单的毕设题目<code>香水在线购物网站</code> 这几年Web技术一直发展和传播的非常好,学习方便,不牵涉大量后端知识光做一个前端壳子的话,这个题目作为毕设题目真的非常适合<strong>普通学生</strong>呢!(苦笑) </p><ol><li>没要求放到互联网上</li><li>不需要考虑后台各类优化</li></ol><p>总的来说就是,你不需要考虑很多东西,毕设老师虽然会在你答辩的时候提出各种优化问题,但是其实只要你懂,能说出个一二来,毕设老师是不会在项目代码检查的时候刻意去检查这些东西的,因为他们也明白光靠一个人去做一个在线购物网站,在没有现有代码框架的基础上,基本不可能让一个大四学生在半年内完成(准确来说是4个月左右,除非是大佬!大佬请带带我…),所以整个毕设的过程,基本就会围绕着前端展开!页面做的好看,就像媳妇领进门,后续的优化就会慢慢去磨合,慢慢去优化,毕设老师们也会<strong>放你一马</strong>(最主要的就是答辩的时候你一定要懂得说出来,如何优化!要blabla一大堆!让毕设老师觉得,恩,这小伙子(姑娘,不错)</p><p>西电毕设才不会那么随便</p><p>虽然前面我自说自话了一大堆所谓的<strong>毕设通关宝典</strong>,但是我还是要为我校说点好话的.西电不是一个985,也可算是一个211学校.不算很好的学校,也不算很差的学校.在我看来,我们西电的学生大部分都是好学生,一个个怀揣着自己的梦想.大学是自由的,如何度过,老师不会来管你,学校规定的那些任务以及要求,只要你不要浪过头,就都可以完成.在我认识的同学里面,有一直玩游戏的,也有一直钻研自己的东西的,也有学霸天天好好上课学习的,当然大部分都是完成正常课程同时业余时间玩自己的业余活动的同学居多的.</p><p>但不管怎么样,不同的人也都在大四那年迎来了自己不同的结局.学习好的都找到了薪资更高的工作,奔赴北上广深,为自己的梦想不断前行.不怎么优秀但是为人脚踏实地的同学,也都能找到一份不错的工作;学习不太好,平时不太学习本专业知识的,最后也都会有自己的想法,去走不同的路.</p><p>如果说大学前三年在学习知识,那么可以说大四就是在体验一份浓浓的人生咖啡.担任毕设老师中,也有不少非常不错的老师,在毕设期间,用他们的一言一行,传达给我们各种各样的人生技能和专业技能.让我受益匪浅.(<strong>曾老师</strong>就是我特别崇拜的一名毕设老师,当时他担任我的毕设老师,我也特比感谢可以在大学的最后一个阶段,遇到他,遇到这么好的一个老师)</p><h2 id="手游的那些事"><a href="#手游的那些事" class="headerlink" title="手游的那些事"></a>手游的那些事</h2><p>先是感叹国内acg文化的茁壮发展，大概几年前,国内的宅er还要死要活翻墙去玩岛国的<strong>舰队collection</strong>,和自己的老婆相隔一个国度,还经常遇到<strong>猫</strong>危机(舰队collection连接服务器失败会弹出一只猫的画面)</p><p>没想到过了不到几年,国内的宅er就有了很多国产老婆可以玩了~</p><p><strong>少女前线</strong>就是一款枪械拟人的游戏,把不同的枪械变化为一个萌萌的妹子,然后宅er可以带着她们前往前线进行战斗,体验到美少女战斗的舒爽快感(反正我们就是喜欢小姐姐!)</p><p>虽然我是不太喜欢这类游戏的,因为他们一般都会比较肝,特别耗时间去玩,不过当时由于其游戏性还不错(比舰娘要好玩),游戏剧情设置较合理,也是吸引我玩了一段时间.这款游戏还是在我无聊的时光里带给我了不少欢乐.虽然后来参与工作后,就不怎么玩,不过我也会偶尔去看看这游戏,真心希望官方可以好好的做好这个游戏,给这类游戏一个满意的答卷.而不是三分热度,捞一笔就跑路.</p><p>本来以为这个小节我能讲很多,但没想到真正写的时候,缺没有什么值得讲的东西.</p><ol><li>我才不会讲我曾借助按键精灵写了一个按键脚本,在电脑上无限刷5-4.</li><li>我才不会讲我曾因为剧情发展到关键时候,发帖说了”AR-15请千万不要出事”这些话语.</li><li>我才不会讲半夜睡不着,是各个枪娘陪伴着我度过不眠之夜.</li></ol><p>好吧,要说的真的不多呢,这小节就到此为止吧! 祝愿少女前线可以在2018年能红红火火.</p><h2 id="就业"><a href="#就业" class="headerlink" title="就业"></a>就业</h2><p>过了毕设那段时光后,便马不停蹄的前往了自己的工作单位进行相关工作.</p><p>真正觉得自己还不够努力,但却有点无可奈何</p><p>当时校招的时候,由于害怕一线城市的就业压力大,所以选择了二线城市的一个公司工作.<br>虽然工资在同行里不算很高,不过公司提供吃住方面都很不错,所以我很快就适应了工作岗位.</p><p>一开始,我参与了公司的尝试性项目,这个项目主要是新人试水项目,简单来说就是看看你这人的能力怎么样.因为面试的过程中,有太多的包装,根本不知道招进来的人到底有多少能耐.所以我们公司都会有这类尝试性项目,专门丢给新人做,然后综合评估新人的代码能力,处理能力,团队沟通能力.</p><p>幸运的是,我的工作表现貌似非常不错,那段时间生活就只有工作和休息,放弃了自己爱玩的游戏,放弃了自己爱看的动漫,全身心的投入到工作中去.</p><p>程序员加班是难免的,更简单的说,21世纪加班都是不可难免的.初创公司就不说了,很多大公司应该也用经常加班加点干活.个人认为加班加点有部分是项目本身有问题,有部分也是自己的问题.一般来说,如果你很优秀,你完全可以写出非常易扩展和维护的代码,而降低自己返工的次数和时间.有时候需求是不明确的,这种时候就需要有一定的开发经验,去提前预见到一些需求,并且提前完成它.如果能做到这样的话,我想加班加点也一定会减少的.</p><p>工作虽然重要,但是生活还是要继续</p><p>在经过一段时间的拼命工作后,我也开始慢慢放慢自己的节奏,我更喜欢每天可以有时间去学习学习新技术,看看一些编程书籍,一些写的不错的博客,来提升自己的眼界.</p><p>因为很多时候,我们的工作范围时很小的,这对自我的提升可以说是很小的.所以经常去看看别的技术,可以起到润滑剂的作用,让自己保持一定的鲜度,也会让自己工作更顺心.</p><h2 id="对2018的祈祷"><a href="#对2018的祈祷" class="headerlink" title="对2018的祈祷"></a>对2018的祈祷</h2><p>来年我希望自己可以做到更多的事情</p><ol><li>遇到自己喜欢的老婆</li><li>对自己要求高点,少玩游戏,多读书!</li><li>工作要更加勤勤恳恳,认真对待!</li><li>如果允许的话,想着可以找个杭州的工作!</li><li>希望爸爸妈妈老去的更慢些!而自己要强大的更快些!</li></ol>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学的日子(二)</title>
      <link href="/2019/04/24/%E5%A4%A7%E5%AD%A6%E7%9A%84%E6%97%A5%E5%AD%90-%E4%BA%8C/"/>
      <url>/2019/04/24/%E5%A4%A7%E5%AD%A6%E7%9A%84%E6%97%A5%E5%AD%90-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>好久不见，我的博客。离上次写博客，已经有很长一段时间过去了，这段时间之间自己刚毕业，刚迈入工作岗位，每天拼命的工作，生活不是很安定，和以前的大学生活差距很大，自然而然就没什么心情写写博客了。可能是因为想倾诉的东西很多吧，有太多的东西想倾诉给某人听，不过自己身边并没有那么适合的人，所以我最终还是找回自己的博客，将自己想说的都说给我自己的博客听。</p><p>这次我想回忆回忆自己的大学学习生活。</p><p>我是一名普通的西安电子科技大学软件学院的学生，我今天就想好好的说一说我自己在大学的学习故事。</p><h2 id="西电有一个很好的软件IT氛围"><a href="#西电有一个很好的软件IT氛围" class="headerlink" title="西电有一个很好的软件IT氛围"></a>西电有一个很好的软件IT氛围</h2><p>大二左右的时候，自己打开qq和微信就可以看到很多人拉队友，参加各种竞赛，增加自己的能力和经验，自己身边也不乏各种编程大神，当我还只会使用windows的时候，人家都已经熟练的使用着ubantu了。每次做软件的大作业的时候，我总会花一两礼拜的时间，泡在图书馆里，学习编程知识，然后边问那些大神们，边完成自己的软件大作业。没有他们，我都不知道自己模拟制作的那些聊天室，web网站(基本处于玩玩的那种程度吧)能不能按时完成呢。我非常感谢自己可以很幸运的遇到他们，能够在他们提供的帮助下，一次次的完成老师布置的软件大作业，不会被老师挨骂，同时也会有那么一点点小小的成就感，毕竟程序的完成，都是我自己一个个代码敲出来的，虽然其实现方式和代码总体架构和设计上完成不能看就是了，基本处于做完就废的那种感觉。我也非常感谢他们不断的在我身边熏陶着一些编程新闻，让我至少在聊软件的时候，可以多说几句我知道的东西。现在很多人认为学软件是不错的选择，不过我还是善意的提醒一句，如果你真的喜欢敲代码，那么我不介意你去学，如果你只是单纯的想找一份比较好的工作，那么我觉得软件这一行业是不适合你的。</p><h2 id="贵在坚持"><a href="#贵在坚持" class="headerlink" title="贵在坚持"></a>贵在坚持</h2><p>大一大二的时候，都是在上编程的基础课程，基本没有自己真正去敲代码的经验，所以自己真正接触代码的时间应该要从大三开始吧。大一大二平平庸庸的过了两年后，我慢慢的察觉到在大学里，按时完成老师布置的作业真的是远远不够的。我不知道985的学校是怎么样的，反正我觉得现在内陆的大学，因为看重毕业率，在大学学习，非常自由，老师不会给太难的任务，导师不会给太多的约束，完全就属于放养的状态。那么我们这些从小就按部就班，一步一步走过来的人呢，就会感觉没有了明确的目标，学习的劲头也没有以前足，加上有些人本身也并不喜欢软件这个专业。差不多到了大三，可以明显的看出我们这批人开始行动了起来，有的开始认真学习自己的专业知识，有的开始另求后路。大三这一年最辛苦的应该就是这些人了，他们每天应该看上去都像一个拼命三郎，每天都在准备的去翻越眼前的大山。我差不多也是这个时候开始喜欢泡图书馆，每天上完课，就回去图书馆看书学习，也是那个时候把自己的Mac系统用了起来，卸载了原来的windows。自从开始用Mac系统后，就开始慢慢的喜欢捣鼓自己的东西，因为Mac系统玩不了很多流行的游戏，自然而然我的时间就更多的花到了自己喜欢的地方去了。这些时间，有些我用来逛自己喜欢的博客，看看他们的生活和技术博文；有些我用来捣鼓Mac系统的使用，使得它更加的适合我平时的学习和使用；还有一些时间我就用来看看视频，发发弹幕，修身养性了。软件编程，我们经常会碰到一些奇奇怪怪的问题，这是因为我们现在大部分的程序员都是在使用软件巨人们帮我们打好的”地基”上面进行开发，由于我们对这些”地基”了解程度不够，没有好好的看文档，也没有好好的去理解深层的原理；有时候一个问题，可能会麻烦你好几天也没有个解决方法。这很考验一个人的坚持能力，如果你坚持了，说不定你成功了。做软件的，如果你真喜欢，那么不管发生什么事情，都请静下来，一个个的去解决眼前的问题，在解决完以后，自己要花点时间去思考，去总结，才能有所收获！</p><h2 id="大学-玩"><a href="#大学-玩" class="headerlink" title="大学==玩?"></a>大学==玩?</h2><p>至少在我小时候居住的环境下，都流行着一种不好的风气，就是高中好好念，上个好大学，在大学里就可以不用像高中那样拼命学习。正如我现在的导师所说，你现在努力过头，不给自己一个喘气的机会，你怎么保证自己可以一直这种状态工作下去呢？没错，现在很多小孩子，从小学，初中到高中，特别是高三，更是把自己的全部都豁了出去，就像这是自己一生中最后一次拼搏一样，有些努力的身体出毛病，有些则努力的自己的心理也开始扭曲。所以一旦毕了业，就会非常想好好休息休息，而因为之前拼搏太久，可能那三个月一点点的假期是远远不够的。所以自然而然，到了大学，我们开始追求自由的生活，不再那么努力，不再那么的看重学业，感觉自己的未来明朗清晰，把大学按部就班的读好，就可以找个好点的工作，然后开始自己的后半生。那么往往这样的结果是不好的。有句话说得好，出来混总有一天要还的。大学才是我们人生中最重要的时刻，你如何利用好你的大学时光，才能真正的决定你的未来。</p><h2 id="大四的那点小事"><a href="#大四的那点小事" class="headerlink" title="大四的那点小事"></a>大四的那点小事</h2><p>西电软院，每年大三暑假都会安排一次实训，和一些软件公司合作，安排我们这些娃子去他们那里实习，实习的内容都是做一个模拟的项目，几个人一个小组进行正常的工作。我认为这是非常好的，甚至比有些自己找的实习机会更加的有帮助。如果在看这篇文章的同学正好是我校友而且也是软院的学生的话，如果你正在烦恼实习怎么办的话，强烈建议你不用花时间去找个自己不喜欢的单位，然后在那里面实习，而是参加学校安排的实训，重点不是看你去哪里实习，而是要看你在实习的时候做了什么。实训的时候如果你想着水过去，那么也就水过去了，因为毕竟只是实训，项目经理不会过来骂你，说你完成的不好，完成的不对。所以还是那句话，自己要严格要求自己。大三实训完接着就是大四的上半学期，各大公司都会过来学校校招，这是一个丰收自己的学习成果的阶段，机会都是留给有准备的人的。但是要进好公司，比如腾讯，阿里，那么你估计需要大量的努力和一点点好运。同时我也推荐你们能进到互联网公司而不是传统IT行业。虽然互联网公司对技术要求高，但是对你来说，可以算是一个很好的平台，站得越高，看得越远。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>感觉自言自语的很久，也算是对自己的大学生活的学习过程有了一个小总结，日后可以自己看看.</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回忆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>踩坑的Bug总集</title>
      <link href="/2019/04/24/%E8%B8%A9%E5%9D%91%E7%9A%84Bug%E6%80%BB%E9%9B%86/"/>
      <url>/2019/04/24/%E8%B8%A9%E5%9D%91%E7%9A%84Bug%E6%80%BB%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>主要纪录我面向Google编程失败后自己解决的部分值得纪录问题，为LTS版本，长期更新</p><h2 id="Java-Exceptions"><a href="#Java-Exceptions" class="headerlink" title="Java Exceptions"></a>Java Exceptions</h2><hr><h3 id="1-java-lang-NoSuchMethodError-com-mchange-v2-async-ThreadPoolAsynchronousRunner"><a href="#1-java-lang-NoSuchMethodError-com-mchange-v2-async-ThreadPoolAsynchronousRunner" class="headerlink" title="1.java.lang.NoSuchMethodError: com.mchange.v2.async.ThreadPoolAsynchronousRunner."></a>1.java.lang.NoSuchMethodError: com.mchange.v2.async.ThreadPoolAsynchronousRunner.</h3><p>第一次遇到这种java异常，看字面意思，找不到这样的方法的错误。</p><p>哇 当时看到这个错误 第一个反应就是 我是不是没导这个jar包？ 然后我排查了一次jar包后发现，明明就有，所以我就非常的无奈，一边吐槽着垃圾Eclipse 一边无奈的各种网上搜解决方案</p><p>很显然，大部分回答都是，checkout your jar！ </p><p>但是我检查了jar包 然后海点进去检查了此jar包的对应的此方法，都是存在的 </p><p>同时我也没有使用maven 不存在maven方面的问题 </p><p>所以我就开始心急如焚，因为我发现自己解决不了这个问题 面向google编程也即将失效</p><p>就在我快要崩溃的时候，看到有一个人说，会不会是jar包冲突？</p><p>我瞬间就反应过来，还真说不定。因为我搭建这个项目的时候，跟着教程无脑导入了大量的jar包，也许就是这个问题</p><p>于是，我使用了eclispse的类搜索功能。我一搜ThreadPoolAsynchronousRunner。。</p><p>发现居然有两个结果</p><p>好吧 同名类。。。。</p><p>于是我删除了其中一个。。。</p><p>运行后 异常消失，一切正常。</p><h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>在java项目中导入jar包乱导入 没有自己去一个个分析每个包的作用导致的jar包冲突的问题。 就好比现实中，有病乱投医，什么药都吃。也表示我吗以后着手做事情的时候，一定要把自己的工具的作用了解清楚再做后续的事情。</p><h2 id="Mysql-Exception"><a href="#Mysql-Exception" class="headerlink" title="Mysql Exception"></a>Mysql Exception</h2><hr><h3 id="1-the-right-syntax-to-use-near-“xxx”"><a href="#1-the-right-syntax-to-use-near-“xxx”" class="headerlink" title="1.  the right syntax to use near “xxx”"></a>1.  the right syntax to use near “xxx”</h3><p>当你看到sql报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to &gt;your MySQL server version for the right syntax to use near &apos;desc, name) &gt;values (2, &apos;Test town desc.&apos;, &apos;Test town&apos;)&apos; at line 1</span><br></pre></td></tr></table></figure></p><p>类似这样的错误</p><p>第一反应便是 你使用了mysql的保留字作为了你的数据库表名或者列名</p>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bugs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自由软件许可证杂谈</title>
      <link href="/2019/04/24/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E8%AF%81%E6%9D%82%E8%B0%88/"/>
      <url>/2019/04/24/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E8%AF%81%E6%9D%82%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<p>昨天刚回浙江老家，在家里闷着无聊的时候，无意间瞄到了shadowsocks的Apache自由软件许可证，一时觉得很好奇，脑海里没有这方面的了解，就开始在网上看起了这方面的知识。于是乎是到了该总结的时候了。</p><p>我仅会在此文章讨论下计算机软件的相关话题，即不会讨论别的事物的版权等问题，顶多会用别的东西来做个比方。</p><h3 id="还是从copyright说起"><a href="#还是从copyright说起" class="headerlink" title="还是从copyright说起"></a>还是从copyright说起</h3><hr><p>在我国，copyright就是著作权或者说版权的象征<sup id="fnref:freesw-1"><a class="footnote-ref" href="#fn:freesw-1" rel="footnote">1</a></sup>，比如小说，音乐，美术，甚至配音作品（cv一般都是在一个事务所下工作的，所以很多cv的配音版权可能都是归属于一个事务所里，但是这个是纯属我自己的猜测，我暂时也不想再上网去看看有关这方面的知识，我只知道必须一个cv配一个角色，那么除非这个cv无法继续进行配音工作，不然不能让别的cv来代役）</p><p>你也许觉得你的作品如果不发表到公共领域就不会受到著作权的保护，其实不然。其实只要你完成了一个作品，并且具有独创性，那么你就享有者著作权的保护。</p><p>我们经常可以在一些网站的底部看到copyright xxxx-xxxx by xxx .这些字样就表明了作者在声明自己的著作权，同时如果你再不经过作者同意的情况下对作品进行转发，分发，修改或者销售，就会受到法律的制裁。</p><p>一般来说一个拥有著作权的作者有权对自己的作品如果用语商业用途后对要使用自己作品的商人收取部分著作费。这些费用是支持和鼓励作者保持一个良好的创造力的方法。毕竟人都是这样，有奖励才会有动力继续做。（做自己喜欢的事情，本身就是一种奖励，所以我们都喜欢无私的为自己喜欢的事情做贡献）</p><p>那么为什么还会有copyleft机制呢？如果说copyright是为了使得人类的创造力能够源远流长，不会乱流，那么copyleft的出现岂不是“助纣为虐”，帮助那些非法使用者们非法的使用别人辛辛苦苦的制作出来的作品。</p><h3 id="copyleft和free-software"><a href="#copyleft和free-software" class="headerlink" title="copyleft和free software"></a>copyleft和free software</h3><hr><p>其实copyleft的出现是和“自由软件”<sup id="fnref:freesw-2"><a class="footnote-ref" href="#fn:freesw-2" rel="footnote">2</a></sup>息息相关的。现在我们可能见到的比较多的就是“开源”“open source”这样的字样，比如我们的android系统就是（部分）开源系统，有很多大牛投入其中，并且研究出了很多类似android的衍生系统。</p><p>软件是开源的，代表我们可以阅读源代码，但其实并不意味了我们可以对其进行任意的修改，复制，或者用着其他用途，开源的软件，依然享有著作权，你可以看到大大的copyright声明贴在最下方，或者一个项目的项目说明书之类的地方。</p><p>那么，我说的自由软件和copyleft的关系呢？其实copyleft就是专门为自由软件而存在的。“自由软件”其实就是不仅“开源”而且“do what you want to do！”。可能说成做任意你想做的说法不是很合适，至于为什么不是很合适，我会在下文继续说明。</p><p>是copyleft的软件，那么就是自由软件，您可以在获取这个软件后，对该软件进行任意的修改，分发，或者改进软件后使其变成更优秀的软件，但是你必须要让这个派生作品也是一个copyleft的软件，即自由软件，不能让其变成一个私有软件或者专有软件从而让使用这软件的人们感觉不自由，或者处于不自由的状态。</p><p>如果说一个软件不是一个自由软件，那么也许就会像一个垄断一样，全世界只有你一个公司知道这个软件的源代码，你的用户对你的软件会产生极大的依赖性，从而导致你可以任意收取你想要的费用，使得你的财产越做越大！</p><p>但是如果说全世界只剩下私有软件或者专有软件，那么我们作为用户的权利就会微乎其微，因为用户无法知道自己所使用的软件，是否在正确的工作。（我相信在看的读者，一定看到过一些恶意软件的新闻，比如在后台自动收集该台电脑的各项记录或者数据等，这种在背后做的恶意软件的产生和肆意妄为，都是因为用户对源代码的未知）</p><p>从上述观点中，我们不难看出，如果赋予一个软件copyleft，那么这个软件就会是安全的，而且是可以健康成长的！而不会使得这个软件被不正当的人群拿去使坏，除非他们不怕坐牢。</p><p>不过我们也从前面的讨论中发现，也许只是一个copyright或者copyleft无法适应软件的各方面变化需求，比如你有一个copyleft的软件，但是却希望别的人可以拿去自由使用，甚至可以拿去使用做商业用途或者做出闭源这样的做法。一般来说，用户可以通过询问作者，来获取这方面的权限，但是如果用户多，问得多，就会对作者的生活感到很大的困扰。所以就有了自由软件许可证书。目前有很多自由软件许可证书，比如GNU GPL，GNU LGPL，BSD，MIT，Apache许可证等。不同的许可证有不同的对该自由软件的要求。不过关于自由开源许可证的内容，我放到下一节来讲</p><h3 id="自由开源许可证"><a href="#自由开源许可证" class="headerlink" title="自由开源许可证"></a>自由开源许可证</h3><hr><p>其实copyleft的创始人也是GNU项目的创始人，所以GNU的证书都是copyleft的，和Apache开源许可证一对比，最大的差别就是，GNU GPL等证书用户修改后不能闭源，要继续保持开源，即继续作为一个自由软件为社区社会作出贡献。</p><p>你能看到现在的很多软件，都会有一个copyright说明，同时还有一个自由开源许可证的保护。copyright保护了作者的著作权，而自由开源许可证则保护了软件的自由。如果一个软件没有说明自己是基于哪个自由开源许可证的，那么该软件就是基于我们的著作权保护法，你不能随意对作品进行复制，分发，修改或者改进。自由开源许可证就像是软件的保护法，保护着软件的各项行为。</p><p>而关于各类许可证的作用，在网上则有很多说明文档，我这里就不重复赘述，但是也并无妨碍我说一下很常见的许可证，比如Apache自由开源许可证。这个许可证的要求是很低的，它不要求修改后的源代码必须开源，但是它要求修改过的文件，必须放置版权说明。</p><h3 id="尾语"><a href="#尾语" class="headerlink" title="尾语"></a>尾语</h3><p>我估摸着想讲的好像都已经讲完了。我写这篇文章的目的主要还是在于，防止自己再未来看到许可证的时候不会一脸呆滞，至少我了解过这方面的知识，我知道这些许可证和版权的区别！</p><hr><p><li id="fn:freesw-1">[1]可参见<a href="https://en.wikipedia.org/wiki/Copyright" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Copyright</a><a href="https://en.wikipedia.org/wiki/Copyright" target="_blank">&#8617;</a></li></p><p><li id="fn:freesw-2">[2]可参见<a href="https://fsfs-zh.readthedocs.io/zh/latest/" target="_blank" rel="noopener">https://fsfs-zh.readthedocs.io/zh/latest/</a><a href="https://fsfs-zh.readthedocs.io/zh/latest/" target="_blank">&#8617;</a></li></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bugs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet的总结</title>
      <link href="/2019/04/24/Servlet%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2019/04/24/Servlet%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>一篇对JavaWeb的Servlet的个人理解（2019-06-24 对本文进行了一定修改，追求下时效性）</p><a id="more"></a><h2 id="什么是Servlet"><a href="#什么是Servlet" class="headerlink" title="什么是Servlet"></a>什么是Servlet</h2><hr><p>servlet是运行在web服务器上的小型Java程序（即服务器端的小应用程序），servlet通常通过HTTP接收和响应来自web客户端的要求</p><p>我所熟知的是关于httpservlet的使用。不要觉得知道了http servlet，但是却不知道https的相关使用。其实https只是http的一层安全包装而已，底层使用的还是一样的东西。所以并没有https servlet这个说法</p><p>本文不会阐述servlet的使用。因为会使用和懂是两码事，比如你知道枪如何使用，但是你知道枪的内部运行原理吗？</p><p>所以本节将努力的将Servlet的工作原理解释清楚，希望学习web开发的读者也可以用心去理解，虽然不需要你去掌握，但至少理解是必要的。</p><h2 id="Tomcat基本知识"><a href="#Tomcat基本知识" class="headerlink" title="Tomcat基本知识"></a>Tomcat基本知识</h2><hr><p>对于学习web开发的我们来说，tomcat那是再熟悉不过的东西了。简单来说，tomcat就是一种servlet容器，就好比手枪，手枪有很多种，tomcat就像一种手枪，里面装的“子弹“就是我们要讲的servlet。这小节我会阐述下什么是tomcat，tomcat怎么样，tomcat能干什么</p><p>作为web开发人员来说，知道tomcat，那么肯定也知道apache。</p><p>Tomcat现在是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目。由Apache、Sun 和其他一些公司及个人共同开发而成。</p><p>Tomcat的特点</p><ul><li>免费，开源，清凉，很适合我们学习人员的使用。</li><li>它内含了一个单独的Http服务器，它也可以被视作一个单独的Web服务器。但是如果说只是将Tomcat用于单独的web服务器，那么在一些有速度和事务处理有要求的情况下来说是不利的，他没有其它完备的web服务器功能那么牛逼，比如（Apache服务器？）所以Tomcat常常会讲其中的Servlet引擎配合其它web服务器使用。</li><li>Tomcat实现了对Servlet和JavaServer Page（JSP）的支持，所以Tomcat内部有一个Jsp编译器（Jsper模块），用以将JSP编译成一个Servlet。这里就不得不说JSP的九大隐含对象了，request，response，pageContext，session，application，config，out，page，exception</li></ul><p>Tomcat简单来说就是可以作为一个简易的web服务器，你可以将你的站点放置在Tomcat上，由Tomcat进行管理。</p><h2 id="Tomcat的总体架构"><a href="#Tomcat的总体架构" class="headerlink" title="Tomcat的总体架构"></a>Tomcat的总体架构</h2><hr><p>讲完了Tomcat的一些基本知识，接下来说说Tomcat的总体架构</p><p>一个好的软件是需要非常模块化的，tomcat也不例外，我们先了解了Tomcat的总体架构，那么再对其中的一部分一部分进行分析，我想作为一个web开发人员，你掌握了这些，也可算是合格的一员了。</p><p>先给出一张tomcat容器模型图<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image001.gif"></p><p>可以看到一个tomcat下可以有很多个Service服务。</p><p>Service可以说是一个接口，实现它的标准类是StandardService<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image002.png"><br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image003.png"></p><p>所以说一个Service服务，其实就是一个StandardService的实例进程。</p><p>那么我们可以说说一个StandardService在干嘛呢？从上图的方法名就可以知道，比如setContainer,setServer,addConnector（这些Container和Connector后面会重点讲，先别急）<br>这些方法其实可以说是对Container和Connector等相关初始化工作</p><p>是的，Service其实就是Container和Connector的一个外部包装，专门负责Container和Connector之间的管理。比如一个Connector要将request和response传递给Container，就是需要Service的帮忙。</p><p>那么Service由谁来管理呢？ 233，也许你会脱口而出，“由tomcat管理”。哈哈，tomcat其实只是一个名字而已，真正管理Service的肯定也是代码呢。</p><p>细心的同学应该会发现，之前有一个setServer方法，那么Server是谁呢？ 我想聪明的你肯定猜到了，对Server就是管理Service的。Server类中有一个addService方法，用于添加Service。</p><p>ok，说到这里，我想大家应该对Server和Service有了大致的了解，那么接下来就来说说有关Service内部的事情。</p><hr><p>我们知道Service里面包含有Container和Connector，简单来说Connector是负责接收浏览器的发过来的 tcp 连接请求<br>，然后将其信息封装为Request和Response，将其传递给Container处理（在一个子线程中执行Container，主线程依旧等待新的tcp请求）</p><p>ok，我想大家应该知道Container和Connector之间的关系了吧，那么接下来说说Connector是如何工作的</p><p>Tomcat5 中默认的 Connector 是 Coyote，这个 Connector 是可以选择替换的.（至今也仍然在使用Coyote，此外是可以替换的，也说明了Tomcat模块化很好。是的，模块好真的很不错！其实减轻了不少开发人员的负担，可以更好的分配工作）</p><h6 id="首先呢Connector如何接受tcp请求？"><a href="#首先呢Connector如何接受tcp请求？" class="headerlink" title="首先呢Connector如何接受tcp请求？"></a>首先呢Connector如何接受tcp请求？</h6><p>嗯，交给Socket呗，不多讲了</p><h6 id="其次呢Connector是如何管理多个请求的？多线程体现在哪里？"><a href="#其次呢Connector是如何管理多个请求的？多线程体现在哪里？" class="headerlink" title="其次呢Connector是如何管理多个请求的？多线程体现在哪里？"></a>其次呢Connector是如何管理多个请求的？多线程体现在哪里？</h6><p>你可以理解为一个while循环，检测一个信号量，如果有请求来了，会改变这个信号量，从而进入while循环内部，然后就会进行一次有关操作了。</p><p>同时主线程继续等待，等待新的请求进来。</p><h6 id="Connector如何处理一次请求的"><a href="#Connector如何处理一次请求的" class="headerlink" title="Connector如何处理一次请求的"></a>Connector如何处理一次请求的</h6><p>Connector处理一次请求，靠的是两个类的运作，HttpConnector和HttpProcessor</p><p>HttpConnector用于等待新的请求，有新的请求后，就会转交给HttpProcessor处理，HttpProcessor的process方法，会将tcp请求的信息封装为对应的Request和Response实例</p><p>最后这个Request和Response就会转递给Container，而转递的任务就是之前讲的Service的工作了。</p><hr><p>理解了Connector的工作原理后，我们就来讲讲Container的工作原理吧</p><p>我们还是先来看看container容器的内部模型图</p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-servlet/image002.jpg"><p>可以看到一个Container内部有Engine，Host，Context还有Wrapper。ok，还是简单之上，我们其实不需要了解的很细，只要知道其每个部分都在干什么就行了</p><h6 id="Engine容器"><a href="#Engine容器" class="headerlink" title="Engine容器"></a>Engine容器</h6><p>首先一个Container里有一个Engine容器，这个容器比较简单，它只定义了一些基本的关联关系，初始化和它相关联的组件，以及一些事件的监听。一个简单的Servlet，也许根本不需要Engine这一层的管理</p><hr><h6 id="Host容器"><a href="#Host容器" class="headerlink" title="Host容器"></a>Host容器</h6><p>从英文单词上看就知道，host代表主机，不过host容器可以有多个，所以如果对web开发比较熟悉的人，应该就知道了，host其实就代表虚拟主机的意思。对，所以说其实一个host容器就代表一个站点哦！ 比方说，我想再建立一个站点，但是我不需要再去找一个web服务器重新设置我的站点，我只需要建立一个虚拟主机，虽然url看上去不一样，但是其实请求都是有同一个container再处理数据哦。</p><hr><h6 id="Context容器"><a href="#Context容器" class="headerlink" title="Context容器"></a>Context容器</h6><p>Context代表Servlet的Context，它具备了Servlet运行的基本环境，理论上只要有Context就能运行Servlet了。简单的Tomcat可以没有Engine和Host。</p><p>所以简单来说，Context用于管理Servlet！</p><hr><h6 id="Wrapper容器"><a href="#Wrapper容器" class="headerlink" title="Wrapper容器"></a>Wrapper容器</h6><p>Wrapper 代表一个 Servlet，它负责管理一个 Servlet，包括的 Servlet 的装载、初始化、执行以及资源回收。Wrapper 是最底层的容器，它没有子容器了，所以调用它的 addChild 将会报错。</p><p>所以说一个Context容器里可以有很多个Wrapper，我们每次在web.xml中注册一个Servlet的时候，就会相应的建立一个Wrapper哦</p><hr><h2 id="Servlet的工作原理"><a href="#Servlet的工作原理" class="headerlink" title="Servlet的工作原理"></a>Servlet的工作原理</h2><hr><h5 id="Servlet的初始化流程"><a href="#Servlet的初始化流程" class="headerlink" title="Servlet的初始化流程"></a>Servlet的初始化流程</h5><p>我们之前有提到Context容器就是Servlet的居住地，里面的Wrapper就代表一个Servlet。（ps：Wrapper只是一层Servlet的封装，为了将Servlet和tomcat分开，因为tomcat是tomcat，而servlet则是另一个领域模块，意思就是说，也许今后会有更厉害的servlet改装版本，然后这个改装版本就可以直接装入wrapper类中，体现了低耦合，高内聚）</p><p>要执行一个Servlet的相关方法前，我们肯定要先实例化Servlet，由Context容器来实例化Servlet，那么我们就先从Conetxt的初始化讲起</p><p>Context容器的初始化可以看两大部分</p><p>1.ContextConfig 的 init 方法将会主要完成以下工作：</p><ul><li>创建用于解析 xml 配置文件的 contextDigester 对象</li><li>读取默认 context.xml 配置文件，如果存在解析它</li><li>读取默认 Host 配置文件，如果存在解析它</li><li>读取默认 Context 自身的配置文件，如果存在解析它</li><li>设置 Context 的 DocBase</li></ul><p>2.ContextConfig 的 init 方法完成后，Context 容器的会执行 startInternal 方法，这个方法启动逻辑比较复杂，主要包括如下几个部分：</p><ul><li>创建读取资源文件的对象</li><li>创建 ClassLoader 对象</li><li>设置应用的工作目录</li><li>启动相关的辅助类如：logger、realm、resources 等</li><li>修改启动状态，通知感兴趣的观察者（Web 应用的配置）<br>子容器的初始化</li><li>获取 ServletContext 并设置必要的参数</li><li>初始化“load on startup”的 Servlet</li></ul><p>这其中是很复杂的，但是我现在主要任务是让大家理解总体脉络，细节部分也不是我们应该掌握的</p><p>既然Context容器的初始化工作完了，那么接下来就要解析一个web应用了。我们知道一个web应用的一个重要的配置文件叫web.xml。所以说，接下来Context容器就会去解析web.xml文件，有Servlet就想应的调用wrapper的相关方法，初始化，创建Servlet等。所以说 Context 容器才是真正运行 Servlet 的 Servlet 容器。一个 Web 应用对应一个 Context 容器。</p><h6 id="Servlet实例"><a href="#Servlet实例" class="headerlink" title="Servlet实例"></a>Servlet实例</h6><p>上文所讲的，我们就已经做完了所有Servlet的初始化工作，接下来我们就要在应用启动的时候，实例化对应的Servlet了。Tomcat在实例化Servlet的时候，是按照有需求再实例化的逻辑的。不过其实这样是不好的，因为如果一个servlet的内容过去庞大的话，在初始化的时候就会需要大量的时间，那么这个初始化时间对于使用这个wen应用的客户来说就是一个blank的盲等待，过场的等待会让客户很生气的，毕竟电脑上的等待10秒，相当于等地铁30分钟呢。所以说，我们要尽量设置load-on-startup属性，这个属性设置后，Context容器就会在Tomcat启动的时候对相应的Servlet进行一次实例化</p><p>Servlet实例化的工作由Wrapper完成，Wrapper简单的调用Servlet的init方法，对Servlet进行初始化。（当然这里还可能初始化的是一个jspServlet，不过道理一样，不多说了）</p><hr><h2 id="Servlet的体系结构"><a href="#Servlet的体系结构" class="headerlink" title="Servlet的体系结构"></a>Servlet的体系结构</h2><hr><img src="https://www.ibm.com/developerworks/cn/java/j-lo-servlet/image010.jpg"><p>从上图可以看到，和Servlet有关的类有ServletRequest，ServletResponse，ServletConfig，ServletContext</p><p>Request和Response我们就不多说了，这个学过Servlet的使用后就一定会接触的</p><p>ServletConfig，可以说是具有这个Servlet的相关配置信息的类</p><p>而ServletConetxt，则有这个Servlet所寄居的Contetx容器的相关信息，具体信息都请查阅相关API接口</p><hr><h2 id="Servlet如何工作"><a href="#Servlet如何工作" class="headerlink" title="Servlet如何工作"></a>Servlet如何工作</h2><hr><p>一个请求到来后，如何知道这个请求要去哪个Servlet里进行相关操作呢？</p><p>这个分配去向的任务很简单</p><p>将url解析，映射到对应的Container容器，Container容器获取到的request里带有mappingData属性，这个属性是mapper类根据这次请求的 hostnane 和 contextpath 将 host 和 context 容器设置到 Request 的 mappingData 属性中的。所以request进入到Conetxt容器里时候，就会知道自己该去哪个wrapper里了！</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Servlet的所有工作流程已经总结完毕，有对其中部分不理解的地方，可以对这个部分进行google的关键字搜索了解更多的知识！</p><p>参考：</p><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-servlet/</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/</a></li><li><a href="http://www.tqcto.com/article/web/51385.html" target="_blank" rel="noopener">http://www.tqcto.com/article/web/51385.html</a></li></ul><hr><h2 id="后续补充"><a href="#后续补充" class="headerlink" title="后续补充"></a>后续补充</h2><hr><p>Servlet的核心基础内容，可以在我的icloud云上看我以前写的笔记</p><p>下面介绍一些Sevlet的最新技术变化，虽然我们现在javaWeb的开发早已经不直接使用Sevlet了都用MVC框架代替，但是MVC框架底层依旧还是在操作我们的Servlet，所以关注一下是没有坏处的，有助于理解Web的MVC框架背后实现原理</p><hr><p>Servlet 3.0 新特性介绍，基于jdk 1.6（）</p><ol><li><p>异步处理支持，原本的Sevlet是堵塞的，有了异步处理支持后，可以使用Servlet的官方API来做到异步处理支持。当然使用你自己实现的异步处理也完全没问题</p></li><li><p>新增的注解支持，比如@WebServlet，@WebInitParam等等，都是为了简化xml配置文件为目的的</p></li><li><p>可插性支持，引入了称之为“Web 模块部署描述符片段“的 web-fragment.xml 部署描述文件，这个文件放置在Jar包的META-INF 目录下。为什么说是可插性支持呢？因为你可以自己写一堆Servlet文件，就可以把他们打包起来，然后把它们的xml配置信息写到web-fragment.xml里，生成一个jar包。这个jar包就可以插到任何Servlet的程序中被正常使用了，jar包内的servlet配置不需要重新写到当前项目的xml中，Servlet3.0会自动扫描jar包内的 web-fragment.xml</p></li><li><p>ServletContext 的性能增强</p></li><li><p>HttpServletRequest 对文件上传的支持，使用</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Part getPart(String name)</span><br><span class="line">Collection&lt;Part&gt; getParts()</span><br></pre></td></tr></table></figure><p>就可以轻松获取文件数据，Part还提供了一些好用的api，方便你处理这些文件，不过form表单仍然要求是 multipart/form-data的</p><p>Servlet 3.0 的新特性参考：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet30/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-servlet30/index.html</a><br>Servlet 3.0 的新特性参考：<a href="https://www.cnblogs.com/davenkin/p/async-servlet.html" target="_blank" rel="noopener">https://www.cnblogs.com/davenkin/p/async-servlet.html</a></p><hr><p>Servlet 3.1 新特性介绍，jdk1.7</p><ol start="0"><li><p>编程式配置，使用java代码的格式来配置web.xml，一种现在流行的配置方式，继承javax.servlet.ServletContextListener接口，还可以使得这个Java配置类可插拔</p></li><li><p>Non-blocking I/O,<br>非堵塞的I/O，在使用I/O进行网络数据读取的时候，加入了几个回调函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onDataAvailable - 在数据没有阻塞，已经完全准备好可以读取的时候调用。</span><br><span class="line">onAllDataRead - 所有数据读取完成后调用。</span><br><span class="line">onError - 请求中发生错误的时候调用。</span><br></pre></td></tr></table></figure></li></ol><p>这样我们就可以在回调函数里，开启I/O进行读取，这样就不会堵塞当前线程的执行</p><p>参考：<a href="https://www.cnblogs.com/davenkin/p/async-servlet.html" target="_blank" rel="noopener">https://www.cnblogs.com/davenkin/p/async-servlet.html</a></p><ol start="2"><li>支持HTTP protocol upgrade mechanism </li></ol><p>客户端可以发起握手协议的升级，最常见的从HTTP / 1.1 升级到HTTP/2 甚至WebSocket </p><p><a href="https://cloud.tencent.com/developer/section/1189838" target="_blank" rel="noopener">https://cloud.tencent.com/developer/section/1189838</a></p><hr><p>Servlet 4.0新特性介绍，jdk1.8</p><p>主要是实现了对HTTP/2的全面支持</p><ol><li><p>服务器推送</p></li><li><p>全新的URL映射匹配方式</p></li></ol><p>参考：<a href="https://www.ibm.com/developerworks/cn/java/j-javaee8-servlet4/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-javaee8-servlet4/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的字符编码总结</title>
      <link href="/2019/04/24/%E6%88%91%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%80%BB%E7%BB%93/"/>
      <url>/2019/04/24/%E6%88%91%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>刚开始接触mac osx这类系统的时候，使用default的zip解压，很容易出现乱码问题。每次我使用默认设置解压一个压缩文件的时候，如果这个文件来自一个中国人的windows电脑的话，十有八九肯定是乱码，想都不用想！ 一开始我还没有使用［The Unarchiver］这款软件的时候，用着各种不爽，出现次数多了，火气就起来了（信不信我砸了你，就是这种感觉）</p><p>不过，生气归生气，还是要研究下为什么会出现这种问题的！所以，随后我查阅了好多网上的资料，也看了一些写的比较好的blog学习了下，算是将困扰我很久的字符编码问题给解决了（弄懂一个东西后还真是感觉心情舒畅啊＝v＝）</p><p>其实mac是一直采用utf-8的字符编码，而一般我们中文环境下的windows系统是采用gbk作为默认的字符编码的（现在应该最新的是gb18030，全称叫China National Chinese）。看到这里如果没能反应过来乱码和这两个东西有什么关系的话，没关系，因为接下来我就回来解释下为什么了！</p><h2 id="先从二进制说起"><a href="#先从二进制说起" class="headerlink" title="先从二进制说起"></a>先从二进制说起</h2><hr><p>我们都知道，计算机里使用的都是二进制码，即0，1这两个数字。我们常说的一个字节（byte），其实代表了一个八位（bit）的二进制数字。比如数字32，我们就可以很容易的得出它的二进制表示，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">0010 0000</span><br><span class="line"></span><br><span class="line">1 * 2^5 = 32;</span><br><span class="line">//有关进制之间的互相转换，这个我就不在这里提及了，网上搜一大堆呢，自己学去</span><br></pre></td></tr></table></figure><p>可以看到十进制数32，刚好可以由一个八位的二进制数表示（其实只要六位，前两位的0都没有用到，不过八位刚好凑成一个字节的长度，所以我这里这么说）<br>所以我们在电脑上看到的数字32，在计算机来看，按照上面的这里换算编码的话，就是0010 0000这一串东西了。</p><h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><hr><p>ASCII码是比较简单的一种编码，它就是用八位的二进制数来表示一些字符的，我们可以知道一个八位的二进制，可以有2^8种，即256种。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000 0000</span><br><span class="line">0000 0001</span><br><span class="line">0000 0010</span><br><span class="line">0000 0100</span><br><span class="line">0000 1000</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">1111 1111</span><br></pre></td></tr></table></figure><p>–<br>从0000 0000到1111 1111，256种情况，可以分别代表256种字符。</p><p>不过，当时这玩意就是做给英文操作系统用的，哪里需要256种，128种其实就够了。所以ASCII码的第一位都是0，这样就把种数变成了128种。</p><blockquote><p>控制字符</p></blockquote><p>ASCII的前32个加上第127个，代表的都是控制符号，这些符号主要用于一些特殊情况，我们作为使用者是不怎么会用到的，这里不会细讲，真的很想了解的同学，please google一下</p><blockquote><p>可显示字符</p></blockquote><p>既然前32个都用来作为控制符号用，那么其他的当然是为我们所用了，比如26个个英文字母，abcdefg…..都有对应的ASCII码。（对于程序员来说，知道A是65，a是97，应该是比较重要的哦＝v＝）</p><p>不管怎么说，ASCII码，这货能干的活仅限于美国佬的computer。如果说要用它来表示我们博大精深的中文汉字，256种哪能够呢。哈哈哈哈</p><p>所以我们接下来来讲讲和中文汉字编码有关的字符编码方式</p><h2 id="Unicode字符编码"><a href="#Unicode字符编码" class="headerlink" title="Unicode字符编码"></a>Unicode字符编码</h2><hr><p>再说中文汉字的字符编码之前，先说说Unicode这个字符编码吧！</p><p>把Unicode说成是一个字符编码是不对的，Unicode其实是字符编码的一个国际标准，其实现方式有很多种，比如utf-8,utf-16,utf-32。</p><p>Unicode使用了16位的二进制数，所以理论上是可以表示2^16次（65536种），这么多基本满足了各类语言对不同符号的需求。</p><p>不过有时候确实16位也不够，那么我们就32位吧，就是4个字节，2^32，这么多总可以了吧，事实上，确实是够了。</p><p>不过当变成32位的时候，又出现了一些问题，比如我们只是简单的表示一个英文字母a，我们如果用32位来表示的话，前面不都是0吗，这些有必要存储吗？没必要</p><p>所以为了让这些0可以去掉，来节省我们的存储空间，所以Unicode的实现方式就有好多种了。</p><p>接下来我们重点就来看看utf-8，这是一个互联网时代通用的unicode实现方式，如果大家都统一用utf8的话，相信乱码问题也会少很多呢</p><h2 id="utf-8"><a href="#utf-8" class="headerlink" title="utf-8"></a>utf-8</h2><hr><blockquote><p>那年我们的网站制作过程全程采用utf8真是太好了！gbk？gb18030？那是什么，我不知道，啊哈哈哈哈</p></blockquote><p>utf8的出现原因是这样的。比如我们要表示一个英文单词a的时候，只需要八位就可以了，那么使用16位的Unicode来表示，前八位不就都变成0，然而这些0是没有意义的，所以当我们仍然采用Unicode的16位进行传输一些英文单词的时候，要传输的内容不就多了一倍，而且这多出来的一倍还特么的是一堆没用的零蛋！</p><p>咳咳，所以说我们要缩短用Unicode表示的英文单词的字符长度！所以就有了utf-8</p><p>utf-8是Unicode在传输的时候使用的一种实现方式！（注意不要以为utf8是一个字符集，错！它只是encoding层次的！utf8的二进制数可以转换回Unicode形式，然后查找Unicode字符集来转译成我们看到的字符！）</p><p>下面我展示一下utf8的编码规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Unicode符号范围 | UTF-8编码方式</span><br><span class="line">(十六进制) | （二进制）</span><br><span class="line">--------------------+---------------------------------------------</span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure><p>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。<br>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下<br>的没有提及的二进制位，全部为这个符号的unicode码。</p><p>以上两点就是utf－8的规则！是不是很简单！</p><p>不过不要被其表面的简单所蒙骗了，Unicode虽然好用，不过你如果是一名web开发人员的话，就一定会在意流量问题！</p><p>如果从流量问题角度出发！如果你使用utf8，那么对于中文来说，你的流量会增加50%。因为大部分常用的中文，使用两个字节就可以表示了，如果采用utf8的话，utf8按上面的规则，一个中文字会变成3个字节，这不就多了一个字节的空间了吗！</p><p>还有另一个问题！关于现在有些网站仍在使用的gbk，这个怎么说呢，应该算是一个历史遗留问题了吧。我相信对于开发人员来说，一定更喜欢utf8，毕竟省事！（不过从流量角度出发，gbk还是有优势的！不过多出50%的流量）</p><p>在utf8后还有utf16，utf32，可以理解为是对不同情况下的utf8的拓展</p><h2 id="所以最开始说的乱码问题"><a href="#所以最开始说的乱码问题" class="headerlink" title="所以最开始说的乱码问题"></a>所以最开始说的乱码问题</h2><hr><p>mac电脑默认采用utf8，而很多中文windows系统的文件采用gbk，一个两字节，一个1～3字节，有自己的算法，所以在mac电脑上解压的zip文件默认用Unicode（USC－2）或者utf8 或者utf16le等等（大端be，小端le）来进行解压的时候，自然而然就变成了乱码了！</p>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的恋爱文字冒险游戏答卷</title>
      <link href="/2019/04/24/%E6%88%91%E7%9A%84%E6%81%8B%E7%88%B1%E6%96%87%E5%AD%97%E5%86%92%E9%99%A9%E6%B8%B8%E6%88%8F%E7%AD%94%E5%8D%B7/"/>
      <url>/2019/04/24/%E6%88%91%E7%9A%84%E6%81%8B%E7%88%B1%E6%96%87%E5%AD%97%E5%86%92%E9%99%A9%E6%B8%B8%E6%88%8F%E7%AD%94%E5%8D%B7/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=4922735&auto=1&height=66"></iframe><p>恋爱文字冒险游戏影响了我一定程度的三观，所以特意也为其专门写一篇文章</p><h2 id="《clannad》如果说你认为它只是一部galgame，那么我就要生气了"><a href="#《clannad》如果说你认为它只是一部galgame，那么我就要生气了" class="headerlink" title="《clannad》如果说你认为它只是一部galgame，那么我就要生气了"></a>《clannad》如果说你认为它只是一部galgame，那么我就要生气了</h2><hr><p>这一礼拜重新回温了一款galgame，名叫《your diary》 （cube社的甜作）</p><p>重温这款游戏的初因是9月30号晚上的一时兴起（我觉得最近自己总是一时兴起，但是真正去干好的事情却没有几个，无法彻彻底底的下定决心是我最近的一个大烦恼）</p><p>在我看来，一部好的galgame真的可以改变一个人在现实生活中的处世态度和处世方式，证据就是我自己。我还记得我玩的第一部galgame的时候是高二，那时候高二暑假，临近高三，那年暑假是待在家里度过的（好像是？饿，应该没记错）我的第一部galgame名叫《clannad》，在哥哥的电脑上玩的。我对《clannad》的评价那便是</p><blockquote><p>一款玩通之后会让你怀疑人生的作品</p></blockquote><p>也许看上去我这评价是负面的，但是毫无疑问，这是我对它的一个正面的最高的评价。爱情小说和肥皂剧我都有看过几部，但是感觉其震撼人心的程度却完全不及《clannad》的十万分之一。（不过这可能也只是我的片面评价，就像初高中女生评价自己喜欢的一个肥皂剧的时候，也会说它有多么多么的感动，不过我冷静的思考过后，我感觉我还是这么写比较好，首先这确实是我脑子里蹦出来的第一个想法，其次它确实是改变了我自身的各个方面，而前两者却没有）</p><p>《clannad》牵涉到了爱情，友情，最后还有亲情，包含的东西确实是很多，我跨越了一个暑假的时间去仔细的推敲每个人说的每一句话，在感叹人心复杂外，也有很多很多对自己生活的思考。正是引发了很多对自己生活的思考，所以我觉得《clannad》是超越了小说还有电视剧的一个存在。《clannad》是一部galgame，它是galgame界的一个楷模，确实是带了一个好头，让其后的galgame中也冒出了很多经典的作品（白色相簿啊还有白色相簿啊还有白色相簿啊等等）</p><p>呀，写着写着，《clannad》中的一幕幕又开始扫过自己的脑中，哎，不讲道理啊，就是这么有深度的一款galgame，不然也不会有那么多人说</p><blockquote><p>读作clannad，写作人生</p></blockquote><p>感觉再说这作的事情，自己的情绪就要不受控了，暂且停笔吧</p><h2 id="《your-diary》"><a href="#《your-diary》" class="headerlink" title="《your diary》"></a>《your diary》</h2><hr><p>所以说呢，作为大学四年最后一次国庆小长假，室友们好像也没有什么外出的安排（毕竟大二大三的时候，国庆节出去玩简直是累惨了，根本不是去看风景的，而是去看人海的吧！）好吧，我也没有什么安排，心已经沉下去了，正是整理自己足迹的时候了呢！</p><p>所以说呢，我就在自己的回忆里，抽出了《your diary》这个作品，其实我玩过的galgame不多，除了《clannad》外，其余都是被一个大佬推荐后才去玩的，所有玩的galgame可以用一个手的手指数清楚。</p><p>《your diary》是cube社的一个甜作，甜度确实可以，剧情也是蛮不错的，至少可以上台面的那种。<br>当初选的由亚线，也是被由亚的那种性格(活泼，开朗，外表小清新，声线少女)所吸引了吧。当时的自己感觉还比较雀跃的那种，自然而然是对个性开朗，活波的女孩子比较有感觉吧。当时走入由亚线后，剧情也没有令我失望，虽然最后让由亚和男主又重新团圆的设定不是很完美，不过也算是给了一个happyend（网上很多人觉得如果由亚和男主彻底分开的结局更神，不过我感觉如果真那样了，又有一批人要致郁了吧）</p><p>重新打开游戏后，一开始是想着重新重温由亚线的，重温与由亚的邂逅，让自己可以再次感受下她的温暖，勇敢面对自己的下一个阶段生活，重温下那甜甜的声音（cv满分，把握很好）剧情并不像《clannad》那么有深度，因为我不想把自己再搞的那么致郁，只是想着最后享受一次galgame的温暖，为我自己的galgame日记划上一个比较完美的句号（此处是我为自己设的flag也说不定）</p><p>令我自己惊讶的是，由亚还是当时的由亚，而我玩着玩着，却走到了学姐线里去了（与由亚完全不同的女性，话少，沉稳，端庄，黑长直，御姐音：发声位置靠后且低，头腔共鸣和胸腔配合共鸣为主，声音稳重、成熟，但很有魅力）</p><p>原来我已经开始憧憬起学姐这样的女性了吗？果然随着年龄的增长，心境自然而然的就发生了变化了呢。<br>和声音稳重、成熟的女性聊天我会更有想深聊的想法，就如同红酒一样，可以慢慢品慢慢尝。</p><hr><p>起初，我注意到学姐的时候，是剧情发展到由亚与学姐初次见面的时候，当时由亚应该是第一次与学姐见面的，但是我发现学姐的神情却不像是第一次与由亚见面。这就奇怪了，勾起了我想深究的欲望，等回过神来的时候，已经发现所有的分支选项我都选择了走入学姐线的选项。</p><p>在真正进入学姐线之前，有一个小场景是比较触动我的心的。</p><p>男主是图书馆副委员长，而学姐其实是图书馆委员长。有一次偶尔男主发现学姐在资料室的座位上靠着桌子睡着的时候，便拿自己的外套为学姐披上，防止学姐着凉。</p><p>随后学姐在当晚居然亲自上门来还外套这个事件比较关键。因为，一般来讲外套其实可以在次日上学的时候顺路还给男主然后道谢就行了。但是当时学姐并没有这么做，而是选择当晚就来还外套。</p><p>学姐自己陈述的原因是“外套里有你的学生手册”。学姐觉得，学生手册应该第一时间归还才行，因为如果老师在次日上学后要求检查学生手册的话，男主可能会遇到很多不必要的麻烦（其实一开始学姐的理由只是说，男主自己没有外套穿，第二天去上学也许会着凉，但是男主觉得这个理由还不足以学姐大晚上了还上门还外套的理由，学姐才说出了学生手册的原因，说实话，着凉的这个理由更能收拢男人的心啊）</p><p>接下来用文字的形式重现下这个场景：</p><blockquote><p>学姐：“早上还是很冷的”</p></blockquote><blockquote><p>男主：“走着走着，就会暖起来的”</p></blockquote><blockquote><p>学姐：“可是，穿这么薄的话…”</p></blockquote><blockquote><p>男主：“那么跑步就行了”</p></blockquote><blockquote><p>学姐：“出了汗的话，会着凉感冒的”（认真脸）</p></blockquote><blockquote><p>男主：“那我到时候换体育服咯”（体育服这装备那么强！？）</p></blockquote><blockquote><p>学姐：“那么，如果长峰同学被老师叫住，训斥的话…”（长峰是男主的姓，学姐没有直呼其名，也说明了两人关系还不够密切，也说明了虽然当了很久的副委员长，可是男主也没有和学姐走得很近这一点。同时也说明了学姐这个人人物的性格吧，难以接近？）</p></blockquote><blockquote><p>男主：“谁会训斥我啊，不过是没穿外套而已”（就是就是，学姐是不是想多了，我当时是这么想的）</p></blockquote><blockquote><p>学姐：“也许会被生活指导老师警告的”（日本学校的生活指导老师的威严还是很强的）</p></blockquote><blockquote><p>男主：“只要说忘记在教室之类的，就能应付过去了”</p></blockquote><blockquote><p>学姐：“但是如果还被要求拿出学生手册的话”（学姐的表情开始转变成略带沮丧的感觉）</p></blockquote><blockquote><p>男主：“这样的话，就会老老实实交出来的啊”（然后发现学生手册不在身上，哈哈）</p></blockquote><blockquote><p>学姐：“长峰同学的学生手册…在我这里噢？”</p></blockquote><blockquote><p>男主：“呃？”（男主诧异）</p></blockquote><blockquote><p>学姐：“在外套里，口袋里面…”（这句话有点意味，首先一般来说不会随便翻别人的衣服的吧？！然而学姐居然翻看了…如果说不是学姐的个人习惯的话，那么只能用学姐对男主也有一点在意这个理由来解释了）</p></blockquote><blockquote><p>男主：“…啊！”</p></blockquote><blockquote><p>学姐：“我以为你知道这个手册在哪里，但是为了确认一下，就…”</p></blockquote><blockquote><p>男主接过外套后说：“的确…是在这里呢”</p></blockquote><blockquote><p>学姐：“有其他丢了的东西吗”（这句话可以看出，学姐的心真的非常细腻啊，是我的话，还了就还了，怎么还会问这些有的没的。。。）</p></blockquote><p>学姐在这个小场景里表现是很有前辈范的，稳重，成熟，细腻的感觉透露的凌厉精致。考虑周全，思维缜密，语气稳重成熟的孩子是目前的我最喜欢的了，这也是让我决定走入学姐线的一个比较重大的原因。其实不管是学姐的第一个表面原因还是第二个的深层原因，都让我感受到人心的温暖。我在想现实生活中一定无时无刻不再发生这样的事情吧。只不过有些人不擅长把握吧。</p><hr><p>随后，顺利的靠攻略的力量，走入了学姐线后，不得不提的第二件比较触动我心的事件发生了。</p><p>但是在说明这个事件之前，有一个设定还是要说明一下的：</p><blockquote><p>由亚是给人带来幸福的神明，由亚只会出现在需要幸福的人的身边，故事的开头便是由亚突然降临至男主身边，励志要为男主带来幸福。但其实男主并不是由亚服务的第一个人类，由亚服务的第一个人类，是学姐</p></blockquote><p>所以问题就那么来了，既然由亚服务的第一个人类是学姐，那么由亚有带给学姐幸福了。照着现状来看，是没有的。（这也是为什么之前男主向学姐介绍由亚的时候会有那个奇怪的反应了）</p><p>学姐知道由亚，学姐也说过交上一个可以扯一辈子的朋友，是学姐的幸福。</p><p>但是不巧的便是，随着由亚陪伴在学姐的时光增加，学姐渐渐的将由亚放在了自己心中最高的位置，有由亚在身边就是学姐最高的幸福</p><p>但是有一天由亚突然从学姐身边消失了，为什么？</p><p>因为由亚发现，学姐所想要的幸福，居然是和自己一直生活下去</p><p>但是这对于一个神明来说，是不可能的，由亚有由亚的使命，总有一天当学姐实现愿望的时候，由亚就必须离开了。</p><p>所以说，学姐在由亚消失后的日子了，一直是非常难受的，以为自己被由亚抛弃，以为自己被幸福之神抛弃，以为自己是一个不幸的人。从此不愿意和人有过多的接触。（成为图书委员长的原因也许就是这个）</p><p>但是其实呢？由亚并没有真的离开学姐的身边，她只是将自己的形态隐藏了起来，然后一直默默的在学姐的身边守护了一年。每天都尝试着去说服学姐身边的同龄人，让他们和学姐友好相处，和学姐做做朋友。<br>由亚只是觉得，不让学姐找到别的朋友，一直拘泥于自己，是永远得不到幸福的，因为由亚知道自己总有一天会离开学姐的。</p><p>差不多就是这些原因，才导致了现在的学姐，一直认为自己是不幸的。学姐一直担心的事情便是，很少有永恒的友情，永恒的爱情。证据就是她自己的经历，友情方面便是由亚的离开，爱情方面便是自己父母的离婚。</p><p>是的。确实拿着这两个强力的证据来推翻友情和爱情，是轻而易举的事情。</p><p>对于友情，虽然我们全然不知自己和朋友们将来会怎么样，会不会因为一些事情而分离（比如毕业，就业），但是我想每个人应该都是想一只做朋友下去的，一直陪伴在朋友的身边。没有人会觉得分离是件好的事情。不过，总而言之生活不会如你所愿，分离在所难免。</p><p>而学姐就是被这个“分离”所束缚了，当时由亚的突然离开，让她不敢和男主展开进一步的交往，怕男主也会在有一天离开自己。关于这段的学姐的怕，怕，怕，可以从下面学姐向男主袒露心声的对话中看出（即攻略成功的时候）</p><blockquote><p>学姐：“不会丢下我一个人不见吧？”</p></blockquote><blockquote><p>男主：“跟你约定”</p></blockquote><blockquote><p>学姐：“不会比我先死吧？”（难为男主了，这个真不好回答啊）</p></blockquote><blockquote><p>男主：“为了学姐，我以后会注意身体的”</p></blockquote><blockquote><p>学姐：“绝对。绝对哦？”</p></blockquote><p>学姐说自己的父母离婚的理由是因为工作一直不能在一起，所以男主说“那么只要我们以后工作在一起不就行了，一起开个咖啡店怎么样？”</p><p>呀，这个作为切入点，真的很不错。虽然我不是女生，不过我感觉我都要被男主的措辞感动了。</p><hr><p>最后一个事件，我也想提一下。</p><p>学姐在确定了与男主一起携手未来后，老师们开始埋怨起学姐了。</p><p>学姐是一个超级优等生，一直是各种第一第一第一，而男主是那种成绩不怎么起眼的小角色，所以关于学姐在高三之际还进行恋爱什么的，可能会影响学业人生之类的话题</p><p>当时学姐与老师争论人生未来的时候，说的理由实在是太油说服力了。加上学姐的cv强有力的配音，感觉学姐整个人的形象油然而生，不愧是学姐。我打心里佩服。。。。。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>呼，总算是对自己的galgame经历有了一篇小小的交代总结。</p><p>虽然感觉自己没写好，没有写出自己想表达的内容。</p><p>不过，就这样吧。有这么一篇文章后，以后自己拿出来就有东西看了。我为自己的galgame日记划下一个句点，这是第一次，也是最后一次对自己体验过的galgame进行大篇幅的评价，说出来感觉心情舒畅呢～<br>嘛，小长假过去了，又要开始好好工作学习，也祝自己能够顺顺利利吧，也恭祝日本的galgame越做越好！希望国人可以更加关注下正版，自己喜欢的东西一定要给点钱买个正版支持一下哦</p><img src="http://i67.tinypic.com/2wciah2.png">]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回忆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学的日子(一)</title>
      <link href="/2019/04/24/%E5%A4%A7%E5%AD%A6%E7%9A%84%E6%97%A5%E5%AD%90-%E4%B8%80/"/>
      <url>/2019/04/24/%E5%A4%A7%E5%AD%A6%E7%9A%84%E6%97%A5%E5%AD%90-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<img src="http://i63.tinypic.com/2a8p10o.jpg"><p>这是一篇回忆自己大学时光的文章</p><blockquote><p>比起不做而后悔，不如做了再后悔。<br>                                   ——空白《游戏人生》</p></blockquote><p>不得不说，电子游戏是我大学人生中占比重比较大的一部分内容，所以我想先拿一些值得写的，自认为比较有营养的游戏。</p><p>高强度的高三结束后，顺利的来到了西电。心里当时确实是充满了对未来的幻想，想做这个，想干那么，心里想做的事真的很多很多～（标准结局：到现在有好多都没有完成～笑）</p><p>和高中不一样，大一的自主时间很多，在认认真真完成了上课，作业，报告等任务后，可以剩下很多时间自由安排。自然而然，我想好好的享受一下游戏（毕竟高中三年都没能好好玩）</p><img src="https://pbs.twimg.com/profile_images/692932156826451969/gNsHJSuZ.jpg"><h2 id="LOL"><a href="#LOL" class="headerlink" title="LOL"></a>LOL</h2><blockquote><p>那天的团灭，依然记忆犹新</p></blockquote><p>Dota，LOL，可以说它们展开了电子竞技的辉煌舞台。对一个职业的电子竞技选手，综合素质可以说是要非常强的。</p><p>我觉得这类游戏，可以锻炼一个人的以下能力：</p><ul><li>全局观念</li><li>抗压能力</li><li>团队能力（领导）</li></ul><p>对全局的掌控，是这类游戏上手的玩家应该做的第一门功课。什么时候，应该干什么。具备这一点，才能让胜利离你更近一步。毕竟这游戏的胜利方式不是取决于杀死敌对玩家操作的人物，而是拆除敌方核心建筑物取胜。如果对全局的掌控好的话，取胜的方法是有很多的，就算你们处于劣势也没关系，重点在于调配全局的动向。</p><p>在电子竞技的正式比赛上，观赛人数是不输于别的竞技类节目的。这也就让参赛选手更加想赢得比赛的胜利，向世界证明自己的实力。但是期望越大，在面临我方劣势的时候，压力也就会越大。这就是我所说的抗压能力的体现。如果在这场比赛中，你的抗压能力更好，那么很有可能你会获得最后的胜利。</p><p>最后想说的是团队能力。有一句话说得好 “这是五个人的舞台，而不是让你一枝独秀的地方”<br>是的，团队在这个游戏的份量是很大的。一般来说，五个人中会分配一个统帅全队的玩家，而到底是哪个玩家来统帅其余4个玩家，带领全队走向胜利，那么这是要由很多方面说明的，简单来说，你展示的足够优秀，那么其余的人自然会跟上你的节奏，顺从你的引导。而当我方和敌方集体交战的时候，就是所谓的”团战”。团战爆发的时候，各司其职是很重要的，中间如果出错一环，都有可能失败，让战局逆转。而如何在团战中站稳自己的位置，要说的就更多了，这里就简单的说一句，相信自己的队友！</p><p>LOL在大一还是玩的比较多的一款游戏，觉得是一款精良的游戏。要说还可以持续多久，我觉得这游戏再活5，6年应该是可以的，也许甚至更多</p><hr><h2 id="ElsWorld"><a href="#ElsWorld" class="headerlink" title="ElsWorld"></a>ElsWorld</h2><img src="http://i68.tinypic.com/2l8uu4y.png"><blockquote><p>吾乃 艾拉 韩</p></blockquote><p>这款游戏就没有那么有名了，但是其实它在韩国还是很火的一款游戏。</p><p>接触这款游戏的初衷那自然就是被一个游戏人物的人设所吸引了（上图中的妹子）</p><p>个人爱好：<br>我在2D的建模方面都是比较挑剔的，只要是有关2D的游戏，扫一脸所有人物的建模，就可以让我对这个游戏产生了一个6成的评价。其次的4成在于声优的配音工作是否理解了人物本身的性格。</p><p>而其中的一个枪兵角色，艾拉 韩，不管是在人物建模还是声优配音方面，我都给100分的评价。</p><p>人物建模依旧是ElsWorld的人物建模的团队，在这里我向他们致敬，他们还是用心在不断的创造欣赏力极佳的人物（后来的新成员希尔与露也有一种匠心巨作的感觉）</p><p>声优方面，佐藤聪美为其配音的真可谓非常的到位！那声音入耳后就觉得，艾拉是一个比较坚强，好学，但是又有点冒失的孩子，再配上自认为完美的人物建模，和技能特效（艾拉的技能特效全部设定为晚秋的红黄色，所有技能的释放都会伴有秋叶的飘落，技能“飞燕”，更是把秋叶飘落特效放大到极致，词贫的我只能已“美”来形容了）</p><p>游戏体验：<br>选好了角色，那么后面的人物就是玩这款游戏了。</p><p>可以说，中国的游戏玩家素质还是非常令人失望的（苦笑），国服的ElsWorld环境并不是很好，玩的人也不多。</p><p>不过自从官方发布了一个HA技能演示视频后，在各大视频网站上转播，国内玩家到了最峰值，我也是在那段时间认识了很多和自己有一样爱好的小伙伴们（笑）</p><p>游戏主要就是打副本性质的游戏，同时也拥有玩家对战pk的功能。</p><p>ElsWorld的玩家对战是设计的很好的。玩过毒奶粉的对战后，我就感到ElsWorld设计者在设计对战规则的独到之处。不过对战的装备还是越厉害越好，所以这一点上依旧是一个大坑。不过好在玩家不多，随便带点装备，就可以去愉快的和别人对战了～。</p><p>游戏时间：从我转向Mac OSX之前都有间断的在玩，如果你和我差不多同龄，又喜欢二次，那么可以在课余时间尝试下这游戏呢。</p><hr><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>在用了Mac OSX后，基本不玩端游了，我对自己大学阶段有关游戏的介绍也就告一段落了～不过，还真是一份不错的回忆。</p><p>呼，时间也过去挺久了，今天就写到这里吧。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回忆向 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
