<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>hexo博客“安全”备份浅谈</title>
      <link href="/2019/05/02/hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E6%B5%85%E8%B0%88/"/>
      <url>/2019/05/02/hexo%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD%E6%B5%85%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<p>前几天我写了一些自己的hexo博客备份与多环境同时使用的文章，里头记录了自己如何对自己的hexo博客进行备份的。但是我并不是一开始就喜欢备份这玩意，因为毕竟只是一个小小的博客，我个人没有意识到需要进行备份。但是后来自己换了个人电脑后，才亲身感受到备份的重要性，随后我就开始专门弄了一套完整的备份方案，该方案大部分学习借鉴了网上的大部分说法，然后实战过程中结合了自己的一些习惯，免去了一些我觉得暂时不太必要的操作，最终现在这套备份方案已经在成功的运行。最显著的成效就是你现在看到的这篇文章就是在我ubuntu电脑上写的，而前几天的文章是在macpro上写的文章！ 两者切换非常轻松便利解放双手。</p><p>但是昨晚睡觉后我就开始思考这个备份的安全性。</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>由于我的hexo本地数据目前全部备份在一个公有的git库，扔在github上，所以对外来说，我的hexo博客整体都在上面，如果有人要整体copy，那也是一个fork和clone的事情。想到这里后我突然有一点点毛骨悚然，又有点觉得自己过于多虑。毛骨悚然是因为感受到了开源的可怕，会用的人一拿走你的所有代码，就可以完完全全copy你的博客所有内容。过于多虑是因为，我的博客没人看，目前来说考虑这个问题是杞人忧天。</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>所以今天我就只是浅谈下，粗略写一下如何“安全”备份hexo博客个人数据</p><p>我的选择其实很狭窄，在我目前的可知知识看来，我有一般以下几点</p><ol><li>个人硬盘存储</li><li>保存到github的private git库</li><li>使用云盘存储</li></ol><p>从灵活性来说，最好的就是切换到github的private git库，况且现在一个人的私有库已经不收费了，真的没有什么理由不用它</p><p>但是有个问题是，在hexo博客的搭建教程里，所有库都是公有库，hexo是利用了github pages中的User pages来展示内容。那么如果转成private库，是否可以正常使用这个github pages的功能呢？我从github help上找到了一些答案，</p><blockquote><p>GitHub Pages sites are always publicly accessible when published, even if their repository is private, </p></blockquote><p>然后我就信了这句英文，事实上他确实没错！</p><p>但是当我把我的repo转成private后，我发现我的github pages自动关闭了，然后我选择重新开启，发现弹出付款页面。</p><p>后来才得知如果私有库也要同时使用github pages的话，是从Github Free转到了Github Pro，而后者是要付钱的。 </p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>从第2点可知，想白嫖走github这一条路是不行的，所以我后续要去看看有没有其他好用的git库给我用用！此文章后续会做更新</p>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修复ubuntu18.04上的问题Wi-Fi adapter not found（Realtek RTL8821CE）</title>
      <link href="/2019/05/01/%E4%BF%AE%E5%A4%8Dubuntu18-04-Wi-Fi-adapter-not-found/"/>
      <url>/2019/05/01/%E4%BF%AE%E5%A4%8Dubuntu18-04-Wi-Fi-adapter-not-found/</url>
      
        <content type="html"><![CDATA[<p>刚使用ubuntu18.04，在桌面版上想使用wifi的时候，发现显示<br><strong>Wi-Fi adapter not found</strong></p><p>这个是因为我们没有安装网卡驱动程序的缘故</p><p>所以解决此问题的关键是先明确自己电脑是什么无线网卡！</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>首先我们需明确ubuntu所使用的是什么网卡</p><p>使用命令<code>lspci</code>获取我们的network-controller信息。</p><p>我的是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(前面的大量输出省略，找到下面这一行就行)</span><br><span class="line">Network controller: Realtek Semiconductor Co., Ltd. RTL8821CE 802.11ac PCIe Wireless Network Adapter</span><br></pre></td></tr></table></figure></p><p>从中可以看出我的无线网卡是为<strong>Realtek RTL8821CE</strong></p><p>所以我们要安装的是RTL8821CE的网卡驱动程序</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>由于没有wifi，所以你目前没有网络环境，但是为了修复这个问题你必须连接上网络，这个时候你必须先准备好可以上网的有线网络(wired network)</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>打开terminal，先输入如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>先更新您的apt软件包管理工具，防止后续我们安装使用相关软件时不会报出一些神奇的错误</p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>安装下必须的一些软件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install --reinstall git dkms build-essential linux-headers-$(uname -r)</span><br><span class="line">git clone https://github.com/tomaspinho/rtl8821ce</span><br><span class="line">cd rtl8821ce</span><br><span class="line">chmod +x dkms-install.sh</span><br><span class="line">chmod +x dkms-remove.sh</span><br><span class="line">sudo ./dkms-install.sh</span><br></pre></td></tr></table></figure></p><p>上述命令会去</p><ol><li>先安装<br> git(这个不用我解释是什么了吧？)<br> dkms(DKMS是基于动态内核模块支持的可以让开发者无需使用最新的内核版本而对某个单一的内核模块做升级)<br> build-essential（携带编译必须软件包）<br> linux-header-$(uname -r)（重装当前linux内核版本的linux-headers）</li><li>将rtl8821ce的驱动程序clone至本地，相当于我们在windows下载驱动程序一个意思</li><li>进入驱动程序包文件夹</li><li>使用chmod调整相关sh脚本的权限</li><li>运行脚本dkms-install.sh，会自动将rtl8821ce驱动程序安装完毕</li></ol><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>重启ubuntu</p><p>再看看你的wifi配置，应该已经可以使用了！</p><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p>其他你可能遇到的问题</p><p>信号弱，使用关键字<code>weak signal</code>去google上搜查答案吧</p>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在我的双硬盘windows电脑上安装ubuntu18.04-Desktop-LTS</title>
      <link href="/2019/04/30/%E5%9C%A8%E6%88%91%E7%9A%84%E5%8F%8C%E7%A1%AC%E7%9B%98windows%E7%94%B5%E8%84%91%E4%B8%8A%E5%AE%89%E8%A3%85ubuntu18-04-Desktop-LTS/"/>
      <url>/2019/04/30/%E5%9C%A8%E6%88%91%E7%9A%84%E5%8F%8C%E7%A1%AC%E7%9B%98windows%E7%94%B5%E8%84%91%E4%B8%8A%E5%AE%89%E8%A3%85ubuntu18-04-Desktop-LTS/</url>
      
        <content type="html"><![CDATA[<p>在我的thinkpad电脑上安装ubuntu18.04-Desktop-LTS系统，达到windows+ubuntu的双系统环境</p><h2 id="我的电脑配置"><a href="#我的电脑配置" class="headerlink" title="我的电脑配置"></a>我的电脑配置</h2><p>Intel i7-8550U，16GB内存，双硬盘256G的SSD，1T的机械硬盘，BOOT启动模式为UEFI,磁盘分区表模式是GPT，开机进入UEFI BIOS设置按住F12，磁盘分区情况如下：</p><p><img src="https://github.com/zazaluMonster/zazaluMonster.github.io/blob/hexo/themes/hexo-theme-cactus/source/images/tmpImage/%E5%AE%89%E8%A3%85%E5%89%8D%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E6%83%85%E5%86%B5.JPG?raw=true"></p><h2 id="制作ubuntu的U盘启动盘"><a href="#制作ubuntu的U盘启动盘" class="headerlink" title="制作ubuntu的U盘启动盘"></a>制作ubuntu的U盘启动盘</h2><p>准备的材料</p><ol><li>ubuntu18.04-Desktop-LTS.iso镜像文件，在ubuntu官网就可以轻松下载</li><li>一个16GB的u盘</li><li>Rufus，一个启动盘写入软件，官网下载最近版即可</li></ol><p>打开Rufus，按照如下配置：</p><p><img src="https://raw.githubusercontent.com/zazaluMonster/zazaluMonster.github.io/hexo/themes/hexo-theme-cactus/source/images/tmpImage/%E4%BD%BF%E7%94%A8Rufus%E5%88%9B%E9%80%A0U%E7%9B%98%E5%90%AF%E5%8A%A8%E7%9B%98.JPG"></p><p>分区类型选择GPT（因为我windows用的GPT分区），目标系统类型选择UEFI（因为我windows用的就是这个启动方式）<br>文件系统选择FAT32（FAT虽然只支持最高4GB的文件大小，但是兼容性强，所以先选择这个文件系统，后面我会尝试使用NTFS）<br>簇大小我用的默认8192字节(8K)</p><p>点击开始后会弹出选择什么镜像模式写入，选择推荐的ISO镜像<br>完成后u盘启动盘就制作完成了</p><h2 id="为ubuntu准备磁盘空间"><a href="#为ubuntu准备磁盘空间" class="headerlink" title="为ubuntu准备磁盘空间"></a>为ubuntu准备磁盘空间</h2><ol><li>在windows的系统盘C盘中预留10G，用于分配/boot分区（分配多一点，以防万一，如果你的SSD不够大的话，分2G应该就足以了）</li><li>在1T的机械硬盘中分割500G作为ubuntu系统存储使用</li></ol><p>如何分割？<br>使用windows自带的磁盘管理工具，右键压缩卷，输入压缩的大小就是分割出来的磁盘空间（黑色显示未分配的部分）</p><h2 id="禁用快速启动fast-startup"><a href="#禁用快速启动fast-startup" class="headerlink" title="禁用快速启动fast startup"></a>禁用快速启动fast startup</h2><p>我暂时没做，用起来没啥区别，估计底层做了一定处理</p><h2 id="关闭Secure-Boot功能"><a href="#关闭Secure-Boot功能" class="headerlink" title="关闭Secure Boot功能"></a>关闭Secure Boot功能</h2><p>由于过去 cracker 经常借由 BIOS 开机阶段来破坏系统，并取得系统的控制权，因此 UEFI加入了一个所谓的安全启动 （secure boot） 机制。<br>但是这个机制容易导致linux系统无法顺利开机，所以需要进行关闭</p><p>关闭方式：<br>重启电脑，按住F12打开BIOS界面，在该界面找到Secure Boot，改成disabled，然后保存重启即可（不同主版也许不同，具体请自己上网查询）</p><h2 id="正式安装ubuntu"><a href="#正式安装ubuntu" class="headerlink" title="正式安装ubuntu"></a>正式安装ubuntu</h2><ol><li>插入我们u盘启动盘！</li><li>开机，按住f12！选中自己的USB设备，回车运行</li><li>选择install ubuntu</li><li>中间什么语言，键盘设定我就不做说明了，选自己喜欢的就行，最好english，可以提高自己</li><li><p>分区配置：<br> 在SSD的未分配空间分：<br> /boot,至少2G,我给了10G,Logical逻辑分区(因为我的boot分区放在windows的SSD盘里，而这个SSD盘已经有windows的主分区了，所以这里我们选逻辑分区即可)<br> 在HHD的未分配空间分：<br> /,至少15000MB，我给20G，逻辑分区<br> swap area,你电脑实际内存(RAM)的两倍，不过很多资料说基本不需要了，所以就随便给了16G，逻辑分区<br> /home,因为就我一个人用，所以把剩下的所有空间都放给这个用户文件夹，逻辑分区</p><p> 所有分区位置都选择从头位置开始（beginning of the space）</p><p> 最后一栏：<br> Device for boot loader installation:<br> 选择刚刚我们分配的/boot对应的那个Device，意思就是把启动程序都装到那里</p><p> 下面放2张参考图<br> <img src="https://github.com/zazaluMonster/zazaluMonster.github.io/blob/hexo/themes/hexo-theme-cactus/source/images/tmpImage/boot%E5%88%86%E5%8C%BA%E9%85%8D%E5%A5%BD%E5%90%8E%E6%88%AA%E5%9B%BE.png?raw=true" title="boot分区配好后"></p><p>  <img src="https://raw.githubusercontent.com/zazaluMonster/zazaluMonster.github.io/hexo/themes/hexo-theme-cactus/source/images/tmpImage/root%E5%88%86%E5%8C%BAhome%E5%88%86%E5%8C%BAswap%E5%88%86%E5%8C%BA%E9%85%8D%E5%A5%BD%E5%90%8E.png" title="root分区home分区swap分区配好后"></p><p> 全部搞定后点击下一步！</p></li><li>设置用户</li><li>等待安装完成，安装完成后提示重启</li><li>开机后会自动先进入UEFI界面，然后选择启动ubuntu即可</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此为止，我个人在双硬盘windows上安装ubuntu18.04-Desktop-LTS的流程已经完毕，上面所描述的步骤都是我亲手秩序的过程，最后成功安装完毕</p><p>参考：</p><ol><li><a href="http://myviewsonfoss.blogspot.com/2018/05/this-article-willshow-you-how-you-can.html" target="_blank" rel="noopener">http://myviewsonfoss.blogspot.com/2018/05/this-article-willshow-you-how-you-can.html</a></li><li><a href="https://blog.csdn.net/love666666shen/article/details/80947903" target="_blank" rel="noopener">https://blog.csdn.net/love666666shen/article/details/80947903</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客多环境同步使用</title>
      <link href="/2019/04/30/hexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%90%8C%E6%AD%A5%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/04/30/hexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E7%8E%AF%E5%A2%83%E5%90%8C%E6%AD%A5%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>最近自己可使用的机子多起来了，一台windows，一台mac，一台ubuntu。windows我目前是纯娱乐，mac是之前大学时候常用的电脑，ubuntu是之前为了加强自己对linux系统的好感度最近才买的机子，准备未来在这个机子上做主要IT开发任务（还很年轻还能挖坑.jpg）</p><p>但是机子多了也带了一定的困扰，我其实是一个爱记录的人，之前做记录一般都是在mac上做，但是因为最近想学一些新语言的练习开发项目，mac这台电脑内存过小（仍在考虑这台仍可以使用但是性能已经不佳的mac该如何处理，后续如何让它起到一定价值，还在思考中），我有点用的不舒服，所以自己弄了一台16G内存来专门负责以后的学习工作兼并开发的电脑。为了方便起见，我肯定会将博客相关的全部挪到ubuntu上去做。不过一直觉得mac用起来非常舒服，估计在写一些非技术文章的时候还是会考虑打开mac来写。</p><p>所以就有了可以同时在mac和ubuntu上写博客的需求。今天就简单的写一下实现思路。</p><h2 id="hexo本地数据同步"><a href="#hexo本地数据同步" class="headerlink" title="hexo本地数据同步"></a>hexo本地数据同步</h2><p>hexo博客在不同环境想要同步使用，最关键的一点就是hexo data的同步，也就是你的那些文章，主题，配置文件。这些文件是hexo博客的自定义数据，无法从别人那里拿到，也无法从hexo官网拿到，我这里就把这些数据归类为本地数据。</p><p>当你换一台电脑，虽然可以非常简单的重新搭建hexo博客环境，但是如果不同步之前的本地数据，那么这个新搭建的hexo博客就和新的hexo博客没区别。</p><p>绕了一大圈，总结来说，想要从一台电脑转到另一台电脑，然后实现hexo博客的转移，最根本的要素就是本地数据的转移。</p><p>那么我们如何做到本地数据的转移呢？</p><ol><li>使用便携式硬盘，比如u盘，拷贝你的本地数据，然后转到新的电脑上。</li><li>使用现在流行的云端存储，那么只要有网络的情况下，不管是什么环境，你都可以轻松的同步你的hexo博客</li></ol><p>u盘这种形式我最早就用过，但是缺点有很多，最明显的缺点就是同步率低而且麻烦，只适合用于转移使用环境，比如你从一台电脑转移到另一台，并且从此不在之前的电脑上进行hexo博客使用<br>所以将hexo本地数据云备份是最好的办法，它不仅可以让我们实时的进行本地数据同步，并且可以有网络的机子上快速搭建，无需考虑其他u盘等什么麻烦的要素。</p><h2 id="hexo本地数据云端管理实现思路"><a href="#hexo本地数据云端管理实现思路" class="headerlink" title="hexo本地数据云端管理实现思路"></a>hexo本地数据云端管理实现思路</h2><p>上小节我谈到，最好的hexo本地数据管理方式是云端管理，那么如何这个云端管理如何运行呢？它的整体架构是怎么样的呢？</p><ol><li><p>选择一款好用的云端存储软件，目前来看最切合的还是github，因为hexo博客的view层数据本身就是存在github上的，然后通过gitpage.io去展现的。使用github提供的远端git库，我们就可以很方便把hexo博客运行和本地数据统一管理起来。</p></li><li><p>将本地数据存至远端git库，这一步其实也完成了hexo本地数据备份的功能，具体操作可以见“hexo备份之路”</p></li><li><p>每次在本地想写文章的时候，先进行git远端库和本地库的数据同步操作（git pull），让本地数据和远端git库一致，并且始终已远端git库作为自己父类数据，本地的数据只看成子类数据，每次在本地完成新文章编写后，将最新的数据提交到远端git库（git push），实现父类数据的更新。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总而言之，hexo多环境同步使用的核心思路就是</p><ol><li>云端存储本地数据</li><li>每次更改前先将从云端同步数据到本地，每次更改完后将本地数据提交到云端</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>虽然思想很简单，但是还是说一些注意事项</p><ol><li><p>git相关代码会产生较多而且固定化，建议使用shell脚本，将所有命令整合成一个语句</p></li><li><p>由于使用了git，所以要遵守代码管理软件的通用规则，那就是必须先更新再提交，以免造成云端数据问题</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo备份之路</title>
      <link href="/2019/04/25/hexo%E5%A4%87%E4%BB%BD%E4%B9%8B%E8%B7%AF/"/>
      <url>/2019/04/25/hexo%E5%A4%87%E4%BB%BD%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>前阵子，我的hexo博客丢失源文件，吃了没有备份的源文件的苦头，所以现在我的hexo博客已经加上了备份机制，使其更加健壮了，本文将记录如何方便的进行hexo备份</p><p>适用hexo版本 4.x<br>查阅此文档前，您必须保证您已经阅读完毕hexo的官方文档，并且已经实际操作过，不然阅读以下的文字会让你理解上有点困难</p><h2 id="hexo备份步骤"><a href="#hexo备份步骤" class="headerlink" title="hexo备份步骤"></a>hexo备份步骤</h2><ol><li><p>在一个新的文件夹(A文件夹)内使用git去clone你的github上的远程hexo库(yourgitname.github.io)，完成后A文件夹内会出现一个clone后的git库文件夹(yourgitname.github.io),点击进入后，里面是hexo用于生成网页的文件结构，而非hexo本地源文件。</p></li><li><p>打开浏览器，进入自己的github，为自己的远程hexo库建立一个分支，最好名为hexo，并将其设为默认分支（方便我们后续提交）。随后我们需要在这个分支内创建一个.gitignore文件。因为新版本hexo在执行<code>hexo init</code>等一系列建站脚本后，会在本地已经为你创建了一个.gitignore文件了，其文件内容就是我们想要的，将其内容复制到刚刚我们新创建的.gitignore文件内并上传至hexo分支即可（如何创建分支自行百度）</p></li><li><p>hexo分支准备完成后，我们就可以在我们cmd界面使用<code>git checkout  hexo</code>将分支切到hexo分支，然后将我们的hexo源文件复制到这里，复制完成后将这些文件一并上传至远程hexo分支即可。到此就完成了hexo备份。现在我们就可以在本地的hexo分支环境下直接写新文章，写完后上传hexo分支，最后使用<code>hexo d</code>，让hexo脚本自动将生成后的文件上传至master分支。最后github上的hexo库的2个分支就完美的呈现它们的价值了，hexo分支内可以看到我们的本地源文件，master分支上就保存着<code>hexo d</code>对应的那些文件用于直接排版我们的网页</p></li><li><p>以防万一，我们最好在本地也对我们的源文件进行归档备份</p></li></ol><h2 id="后续每次写完新文章后需要执行的shell指令"><a href="#后续每次写完新文章后需要执行的shell指令" class="headerlink" title="后续每次写完新文章后需要执行的shell指令"></a>后续每次写完新文章后需要执行的shell指令</h2><ol><li>git add <newfile></newfile></li><li>git commit -m “备份”</li><li>git push origin hexo</li><li>hexo g</li><li>hexo d</li></ol>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019我的个人电脑机械硬盘问题引发的故事</title>
      <link href="/2019/04/24/2019%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E8%84%91%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98%E9%97%AE%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%95%85%E4%BA%8B/"/>
      <url>/2019/04/24/2019%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%94%B5%E8%84%91%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98%E9%97%AE%E9%A2%98%E5%BC%95%E5%8F%91%E7%9A%84%E6%95%85%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p>最近一直用着的MBP，突然机械硬盘出现问题，导致部分数据丢失，其中就包括了我的博客源文件。最早开发我自己博客的时候，写了一大堆自定义css和js文件，且当时没有良好的打包备份思想，导致今天让自己跳进坑里。</p><p>hexo博客源文件丢失后，唯一能找回的数据只剩下github上，每次deploy的时候上传的那些文件。</p><p>但是那些是模版技术在本地执行后生成好的完整的html文件，打开一看，自然里面排版异常难看，想把自己的数据找回着实不易。</p><p>最后自己干脆把网页显示后上的文字通通复制到本地，然后在本地重新初始化了hexo相关配置，经过了几个小时的奋斗，总算把自己的博客内容失而复得。虽然那些看上去好玩的css和js不见了，但是现在想来，那些东西都是没有啥参考意义的乱码罢了，故舍弃之。转而从新选择了一个风格简单的主题作为今后的blog主打风格。同时也转移了live2d看伴娘的模块（觉得唯一值得保护的一个模块）。</p><p>因为不想再吃源代码丢失的苦痛，这次使用了备份分支，专门将本地源文件也上传至github，今后就可以放心了</p><p>差不多就这些,后续可能会针对hexo博客备份专门写一篇操作文档进行记录</p>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用JavaSeurity进行数字签名(二)</title>
      <link href="/2019/04/24/%E4%BD%BF%E7%94%A8JavaSeurity%E8%BF%9B%E8%A1%8C%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-%E4%BA%8C/"/>
      <url>/2019/04/24/%E4%BD%BF%E7%94%A8JavaSeurity%E8%BF%9B%E8%A1%8C%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>在上一章中，我们使用JavaSeurityAPI对dsaSignFile文件进行了一次数字签名，并且将其数字签名以及公钥都保存到了本地硬盘的相应文件中。作为发送方，我们通过各种“交通”手段，将这三个文件一一发给了接收方。在本章我们就来展示接收方如何使用这三个文件，对数字签名进行验证，最终确定dsaSignFile的确实是由发送方发出的</p><blockquote><p>什么是验签</p></blockquote><p>接收方获取到原数据文件，公钥文件，数字签名文件后，使用这三个文件便可以完成验签。验签的基本流程简单来说如下</p><ol><li>使用公钥文件将数字签名还原为散列值A</li><li>使用加签时相同的算法获取原数据文件的散列值B</li><li>对比A和B是否一致，若一致便说明数字签名正确，该文件确实是发送方发出，而不是由别人篡改后发出的</li></ol><blockquote><p>JavaSeurity进行验签</p></blockquote><p>1.使用公钥文件获取公钥<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PublicKey <span class="title">getPubFromPubFile</span><span class="params">(File pubFile)</span> <span class="keyword">throws</span> IOException, NoSuchAlgorithmException, InvalidKeySpecException </span>&#123;</span><br><span class="line">        <span class="comment">//从文件中获取公钥字节数据</span></span><br><span class="line">        FileInputStream keyfis = <span class="keyword">new</span> FileInputStream(pubFile);</span><br><span class="line">        <span class="keyword">byte</span>[] encKey = <span class="keyword">new</span> <span class="keyword">byte</span>[keyfis.available()];</span><br><span class="line">        keyfis.read(encKey);</span><br><span class="line">        keyfis.close();</span><br><span class="line">        <span class="comment">//先将公钥字节数据转换为key specification，只有key specification才能使用KeyFactory转化为PublicKey Object</span></span><br><span class="line">        <span class="comment">//key specification你可以理解为密钥的一种格式，是密钥字节数据的升级</span></span><br><span class="line">        X509EncodedKeySpec pubKeySpec = <span class="keyword">new</span> X509EncodedKeySpec(encKey);</span><br><span class="line">        <span class="comment">//使用KeyFactory，通过key specification获取PublicKey Object</span></span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        PublicKey pubKey = keyFactory.generatePublic(pubKeySpec);</span><br><span class="line">        <span class="keyword">return</span> pubKey;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>2.使用数字签名文件获取数字签名字节数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] getSignatureBytesFromSignFile(File signFile) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        FileInputStream sigfis = <span class="keyword">new</span> FileInputStream(signFile);</span><br><span class="line">        <span class="keyword">byte</span>[] sigToVerify = <span class="keyword">new</span> <span class="keyword">byte</span>[sigfis.available()];</span><br><span class="line">        sigfis.read(sigToVerify);</span><br><span class="line">        sigfis.close();</span><br><span class="line">        <span class="keyword">return</span> sigToVerify;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>3.使用原数据，公钥，数字签名字节数据验证正确性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">verifySignature</span><span class="params">(PublicKey publicKey,File dataFile,<span class="keyword">byte</span>[] sigToVerify)</span> <span class="keyword">throws</span> NoSuchAlgorithmException, InvalidKeyException, IOException, SignatureException </span>&#123;</span><br><span class="line">        <span class="comment">//这次我们使用公钥初始化签名器</span></span><br><span class="line">        Signature sig = Signature.getInstance(<span class="string">"SHA1withRSA"</span>);</span><br><span class="line">        sig.initVerify(publicKey);</span><br><span class="line">        <span class="comment">//将原数据导入签名器</span></span><br><span class="line">        FileInputStream datafis = <span class="keyword">new</span> FileInputStream(dataFile);</span><br><span class="line">        BufferedInputStream bufin = <span class="keyword">new</span> BufferedInputStream(datafis);</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> (bufin.available() != <span class="number">0</span>) &#123;</span><br><span class="line">            len = bufin.read(buffer);</span><br><span class="line">            sig.update(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        bufin.close();</span><br><span class="line">        <span class="comment">//使用签名器进行验证</span></span><br><span class="line">        <span class="keyword">boolean</span> verifies = sig.verify(sigToVerify);</span><br><span class="line">        <span class="keyword">return</span> verifies;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>4.前三步整合为一个验签程序如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">verifySign</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException, IOException, InvalidKeySpecException, SignatureException, InvalidKeyException </span>&#123;</span><br><span class="line">        String pubKeyDataFileUrl = <span class="string">"src/test/resource/pubKeyData"</span>;</span><br><span class="line">        PublicKey publicKey = getPubFromPubFile(<span class="keyword">new</span> File(pubKeyDataFileUrl));</span><br><span class="line">        String signDataFileUrl = <span class="string">"src/test/resource/signData"</span> ;</span><br><span class="line">        <span class="keyword">byte</span>[] sigToVerify = getSignatureBytesFromSignFile(<span class="keyword">new</span> File(signDataFileUrl));</span><br><span class="line">        String dsaSignFileUrl = <span class="string">"src/test/resource/dsaSignFile"</span> ;</span><br><span class="line">        <span class="keyword">boolean</span> verifies = verifySignature(publicKey,<span class="keyword">new</span> File(dsaSignFileUrl),sigToVerify);</span><br><span class="line">        System.out.println(<span class="string">"signature verifies: "</span> + verifies);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>存在的隐患</p></blockquote><p>到目前为止，使用Java进行加签验签的过程已经全部测试完毕了，但是在我们的这个流程中存在一个隐患。那就是我们不能确保接收方获得的公钥文件是正确的。</p><p>打个比方，如果发送方在发出原数据，公钥文件，数字签名文件后，被中间人拦截。中间人为了达到自己的目的，篡改了原数据的内容，并且使用自己的私钥重新生成了一份新的数字签名文件，并且把公钥文件也替换为自己的公钥文件。然后将这三个文件再发送给接收方。接收方的验签过程并不会报错，从而导致接收方将错误的信息信以为真。</p><p>为了避免这样的情况发生，目前的解决方法之一就是使用数字证书。一个数字证书是由国际上公认的机构进行颁发，每个数字证书中包含了发送方的公钥，以及一个该证书内容的数字签名。接收方则在本地密钥库中寻找该数字证书所对应的公钥数据，如果存在，则使用它解开这个数字证书，随后拿到发送方的公钥。这个过程中最终我们的信任方是计算机本地存储的受信任的根证书列表，只要保证它的正常运作，那么就不会发生被人篡改的情况</p><blockquote><p>小节<br>java的数字签名练习就到此结束了。本来我还想着写一下RSA加解密，但是发现其实在流程本质上和数字签名是一致的，所以就不浪费时间重新赘述了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> signature </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用JavaSeurity进行数字签名(一)</title>
      <link href="/2019/04/24/%E4%BD%BF%E7%94%A8JavaSeurity%E8%BF%9B%E8%A1%8C%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-%E4%B8%80/"/>
      <url>/2019/04/24/%E4%BD%BF%E7%94%A8JavaSeurity%E8%BF%9B%E8%A1%8C%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>Hello,my blog.好久不见.由于最近项目有些地方有涉及到数字签名,RSA加解密,数字证书等东西.虽然对其不太了解,也没有过多的影响到自己的开发,但是抱着一颗好奇的心,对其相关知识进行了网上冲浪,现在对自己所看到的相关资料,进行自我整理以及消化.在这一章,你将了解到[什么是数字签名] [什么是公钥私钥] [JAVA如何生成公钥私钥进行数字签名]</p><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><blockquote><p>数字签名何时诞生? </p></blockquote><p>1976年，Whitfield Diffie 和 Martin Hellman 两人第一次提出了数字签名的概念，当时虽然他们并没有现成的方法去得到数据的数字签名，但是他们推测可以使用相关数学函数去进行计算获取 到数字签名，这个方案是可行的。随后不久， Ronald Rivest, Adi Shamir, 和 Len Adleman便研究出了RSA算法，这是一个可以生成数字签名的算法(虽然当时RSA算法得到的数字签名被公认为还是不安全的)最后第一个可以为指定数据生成数字签名的软件包诞生， Lotus Notes 在1989年将其发布。</p><blockquote><p>数字签名是什么</p></blockquote><p>简单来说，数字签名就是使用公认可靠的签名算法，使用公钥加密技术，生成一段数据的一串散列值。比如<code>hello,zazalu</code>这串数据的数字签名就类似于<code>BE459576785039E8</code>，我们可以将这一串值理解为非常难以破解的东西。</p><blockquote><p>数字签名的用武之地在哪里</p></blockquote><p>我用一个生活中的简单例子来做个比喻.</p><p>当我们收到自己爱人的来信时，激动不已的你急忙打开并且进行阅读。在这个简单的环节中，人的大脑其实自动帮你做了一个简单的验签的过程，你在看到那些熟悉的字体，熟悉的称呼或者一个简单的暗号后，你就为潜在的认为这封信确实是你的爱人写的，因为只有你熟悉他(她)的写法，只有你才知道暗号的含义。</p><p>数字签名其实起到的就和“暗号”“写法”这类东西类似，都是用来证明发件人确实是你爱人用的。在没有数字签名之前，我们在网上收到一封重要文件，虽然系统提示你发件人为A，但是并不代表真的是A，有可能是B正好偷偷用A的电脑发的也说不定。总而言之，在没有数字签名的时候，你无法确定发件人是谁。而数字签名就是起到证明发件人确实是A的作用的东西。</p><blockquote><p>数字签名如何生成？</p></blockquote><p>在前面，我有说到，数字签名是使用公认可靠的签名算法，使用公钥加密技术，为数据生成一串散列值。那么具体是怎么样的呢？</p><p>首先我们来简单说明下公钥加密技术，目前我们常用于数字签名的公钥加密技术有两种，一个是RSA，还有一个是DSA。不过在进行数字签名这方面，他们的行为在语言描述上是一致的，这里也就不做区分说明。</p><p>不管是RSA还是DSA算法，他们都需要两个密钥，一个叫公钥，一个叫私钥。使用加密算法前，我们需要先使用相关算法库，生成一对密钥对，使用公钥加密的信息只能由私钥进行解密</p><p>是的，由于公钥是公有的，谁都能获取，所以按逻辑上来说，我们不应该使用私钥进行加密。但是我们却可以利用这一点来验证这串数据是由谁加密的，因为私钥是保密的。我使用私钥生成一串数字签名，那么只要使用我的公钥解析数字签名并且使用相同算法比较数据的散列值，如果是一样的，就说明这个数据就确实是由我发出的，不会有假。这也就说明了数字签名的有效性，可靠性。</p><blockquote><p>参考</p></blockquote><p>上面几节，不知道讲没讲明白，但是我已经把我自己的理解全部整理了一遍，如果您还是不理解，不妨可以试试下面链接，都说明的不错</p><ol><li><a href="https://security.stackexchange.com/questions/66392/why-should-i-sign-data-thats-already-encrypted" target="_blank" rel="noopener">https://security.stackexchange.com/questions/66392/why-should-i-sign-data-thats-already-encrypted</a></li><li><a href="https://docs.oracle.com/javase/tutorial/security/apisign/step3.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/security/apisign/step3.html</a></li><li><a href="https://www.jianshu.com/p/090e35989501" target="_blank" rel="noopener">https://www.jianshu.com/p/090e35989501</a></li></ol><h2 id="JAVA如何生成数字签名"><a href="#JAVA如何生成数字签名" class="headerlink" title="JAVA如何生成数字签名"></a>JAVA如何生成数字签名</h2><blockquote><p>获取RSA密钥对的接口方法getRSAKeyPair</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> KeyPair <span class="title">getRSAKeyPair</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException</span>&#123;</span><br><span class="line">    <span class="comment">//获得一个密码随机数生成器(用于密钥生成),使用SecureRandom以及SHA1PRNG </span></span><br><span class="line">    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(<span class="string">"RSA"</span>);<span class="comment">//获得密钥生成器,java语言使用KeyPairGenerator</span></span><br><span class="line">    <span class="comment">//SHA1PRNG意思便是使用SHA1密码散列函数,来生成伪随机数,PRNG = pseudo random number generator  </span></span><br><span class="line">    <span class="comment">// 有兴趣的同学可以进行深入研究, 这里不会探讨此问题        </span></span><br><span class="line">    <span class="comment">//我们的示例使用SHA1,当然你也可以试试SHA-2，SHA-3       </span></span><br><span class="line">    SecureRandom random = SecureRandom.getInstance(<span class="string">"SHA1PRNG"</span>);</span><br><span class="line">    <span class="comment">//初始化1024位密钥生成器       </span></span><br><span class="line">    keyGen.initialize(<span class="number">1024</span>,random);        </span><br><span class="line">    <span class="comment">//生成公钥私钥      </span></span><br><span class="line">    <span class="keyword">return</span> keyGen.generateKeyPair();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用我们刚刚生成的密钥对去生成指定文件的数字签名,getFileSignature接口参数,file为你指定的文件,keypair为你使用getRSAKeyPair生成的密钥对</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Signature <span class="title">getFileSignature</span><span class="params">(File file,KeyPair keyPair)</span> <span class="keyword">throws</span> NoSuchAlgorithmException, InvalidKeyException, IOException, SignatureException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(file == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取一个签名器,注意：生成密钥对的时候使用的是什么非对称加密算法和什么散列函数,String参数就填写对应"XXXXwithXXX"</span></span><br><span class="line">        <span class="comment">//e.g. DSA密钥对,使用SHA1PRNG,则为"SHA1withDSA"</span></span><br><span class="line">        Signature dsa = Signature.getInstance(<span class="string">"SHA1withRSA"</span>);</span><br><span class="line">        <span class="comment">//使用私钥初始化签名器,注意：请不要使用公钥初始化,只有私钥才能用来生成数字签名</span></span><br><span class="line">        PrivateKey priv = keyPair.getPrivate();</span><br><span class="line">        dsa.initSign(priv);</span><br><span class="line">        <span class="comment">//使用签名器的update方法将要进行签名文件的数据导入到签名器中(光看api就感觉很类似导入的感觉,所以就这么说明了,如有违和的地方请指正)</span></span><br><span class="line">        dsa = updateDsaSignture(dsa,file);</span><br><span class="line">        <span class="comment">//获取数字签名</span></span><br><span class="line">        <span class="keyword">return</span> dsa;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将文件数据导入至签名器中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dsa 签名器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file 需进行签名的文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Return</span>: dsa 数据导入完毕的签名器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Creator</span>: hejj</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Signature <span class="title">updateDsaSignture</span><span class="params">(Signature dsa,File file)</span> <span class="keyword">throws</span> IOException, SignatureException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        BufferedInputStream bufin = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bufin.read(buffer)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            dsa.update(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        bufin.close();</span><br><span class="line">        <span class="keyword">return</span> dsa;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>把数字签名和公钥保存到本地</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveSignature</span><span class="params">(File signFile, Signature signature)</span> <span class="keyword">throws</span> IOException, SignatureException, NoSuchAlgorithmException, InvalidKeyException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(signFile == <span class="keyword">null</span>)&#123;</span><br><span class="line">            signFile = <span class="keyword">new</span> File(<span class="string">"../resource/signFile"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(signFile.exists())&#123;</span><br><span class="line">            signFile.delete();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            signFile.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputStream sigfos = <span class="keyword">new</span> FileOutputStream(signFile);</span><br><span class="line">        sigfos.write(signature.sign());</span><br><span class="line">        sigfos.close();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">savePublicKey</span><span class="params">(File pubKeyFile, PublicKey publicKey)</span> <span class="keyword">throws</span> NoSuchAlgorithmException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pubKeyFile == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pubKeyFile.exists())&#123;</span><br><span class="line">            pubKeyFile.delete();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pubKeyFile.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] key = publicKey.getEncoded();</span><br><span class="line">        FileOutputStream keyfos = <span class="keyword">new</span> FileOutputStream(pubKeyFile);</span><br><span class="line">        keyfos.write(key);</span><br><span class="line">        keyfos.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>将所有接口整合，运行起来的demo</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signFile</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException, InvalidKeyException, IOException, SignatureException </span>&#123;</span><br><span class="line">    MyRsaDsaUtil rsaDsaUtil = <span class="keyword">new</span> MyRsaDsaUtil();</span><br><span class="line">    <span class="comment">//获取密钥对</span></span><br><span class="line">    KeyPair keyPair = rsaDsaUtil.getRSAKeyPair();</span><br><span class="line">    <span class="comment">//获取文件签名(请先预创建自己的rsaSigndFile文件)</span></span><br><span class="line">    String signFilePath = URLDecoder.decode(MyRsaDsaUtil.class.getResource(<span class="string">"../resource/rsaSignFile"</span>)</span><br><span class="line">            .getFile(),<span class="string">"utf-8"</span>) ;</span><br><span class="line">    Signature signature = rsaDsaUtil.getFileSignature(<span class="keyword">new</span> File(signFilePath),keyPair);</span><br><span class="line">    <span class="comment">//保存文件签名 保存后才能发送给别人哦</span></span><br><span class="line">    String signDataFileUrl = <span class="string">"src/test/resource/signData"</span> ;</span><br><span class="line">    String pubKeyDataFileUrl = <span class="string">"src/test/resource/pubKeyData"</span>;</span><br><span class="line">    rsaDsaUtil.saveSignature(<span class="keyword">new</span> File(signDataFileUrl),signature);</span><br><span class="line">    rsaDsaUtil.savePublicKey(<span class="keyword">new</span> File(pubKeyDataFileUrl),keyPair.getPublic());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>本章我们先从数字签名的基础知识讲起，随后用了实际代码例子进行了练习，现在我们应该都已经学会了使用java生成某个文件的数字签名！</p><p>在下一章中，我们将作为文件接收者，去验证这个数字签名是否正确，从而完成一整个使用数字签名验证发件人有效性的整个流程。</p>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> signature </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo next主题自定义css格式切换</title>
      <link href="/2019/04/24/hexo-next%E4%B8%BB%E9%A2%98%E8%87%AA%E5%AE%9A%E4%B9%89css%E6%A0%BC%E5%BC%8F%E5%88%87%E6%8D%A2/"/>
      <url>/2019/04/24/hexo-next%E4%B8%BB%E9%A2%98%E8%87%AA%E5%AE%9A%E4%B9%89css%E6%A0%BC%E5%BC%8F%E5%88%87%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>当我每次想要进行自己的hexo next博客的外观变更的时候,每次都需要去修改配置文件,会非常的麻烦,而且容易忘记.所以自己稍微研究了下,做了一些bat批处理文件,用于控制博客的页面外观(css)的自动转换.比如新年的时候,就切换到新年的配置文件.</p><p>本文档主要就是简单记录下,防止自己未来忘记了,强烈建议其他阅读者不要读此文档，大概率你看不懂写的什么东西</p><blockquote><p>适用版本<br>hexo版本：3.3.9<br>nexT版本: 5.0.0<br>可能最新的版本不符合本文档的描述，若你使用的是别的主题，使用举一反三的思考方式，其实也是类似的</p></blockquote><h2 id="hexo-nexT主题自定义css配置文件"><a href="#hexo-nexT主题自定义css配置文件" class="headerlink" title="hexo-nexT主题自定义css配置文件"></a>hexo-nexT主题自定义css配置文件</h2><p>nexT主题自定义css配置文件路径: <code>themes\next\source\css\_custom\custom.styl</code></p><p>修改custom.styl中文件内容 重新部署hexo后即可看到修改后的css效果.</p><h2 id="创建css格式切换临时文件夹"><a href="#创建css格式切换临时文件夹" class="headerlink" title="创建css格式切换临时文件夹"></a>创建css格式切换临时文件夹</h2><p>在themes\next\source\css_custom下 可以自行创建一个css格式切换文件夹</p><p>比如我创建的就是<br><code>themes\next\source\css\_custom\themes</code></p><p>目前我在其中放置了两个版本的css配置文件</p><p><code>custom_new_year.styl</code><br><code>custom_normal.styl</code><br>分别对应新年版本css配置文件和普通版本的css配置文件</p><h2 id="创建bat批处理文件"><a href="#创建bat批处理文件" class="headerlink" title="创建bat批处理文件"></a>创建bat批处理文件</h2><p>使用批处理文件 其功能是可以将custom_*.styl文件移动到<code>themes\next\source\css\_custom</code><br>下并且重命名为custoom.styl即可<br>这个批处理文件就是将css切换为新年模式的一个很简单的bat脚本.</p>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017俺の年终总结</title>
      <link href="/2019/04/24/2017%E4%BF%BA%E3%81%AE%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
      <url>/2019/04/24/2017%E4%BF%BA%E3%81%AE%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>终于迎来了学业生涯结束后的第一个春节!非常感谢自己踏在这样美好的人生转折点上,这一年里,我有欢笑也有泪水(虽然我已不记得上一次哭是什么时候了哈哈),这一年里我完成了许多事,也做砸了许多事;这一年里我告别了许多人,我也认识了许多人;这一年里我见识到了许多事,也对社会的很多事感觉失望.2017注定对我而言注定是特殊的,有太多值得我去记录和分享的东西在那里!在这个安静的傍晚时光里,就让我全部一点点的记录下来吧!</p><h2 id="先从毕设开始说吧"><a href="#先从毕设开始说吧" class="headerlink" title="先从毕设开始说吧"></a>先从毕设开始说吧</h2><p>2017年的开头,就先从毕设说起吧.2017年上半年基本都在为毕设忙碌了.身为西电软件学院的一名普通学生,毕设自然而然是要做一个软件作为自己毕业的答卷! 我不是一个非常优秀的学生,成绩也一般般,对软件稍有兴趣但是大学四年也是经常东张西望,真正学到的东西很少,基础知识非常不扎实.所以当时就”抢”到了一个比较简单的毕设题目<code>香水在线购物网站</code> 这几年Web技术一直发展和传播的非常好,学习方便,不牵涉大量后端知识光做一个前端壳子的话,这个题目作为毕设题目真的非常适合<strong>普通学生</strong>呢!(苦笑) </p><ol><li>没要求放到互联网上</li><li>不需要考虑后台各类优化</li></ol><p>总的来说就是,你不需要考虑很多东西,毕设老师虽然会在你答辩的时候提出各种优化问题,但是其实只要你懂,能说出个一二来,毕设老师是不会在项目代码检查的时候刻意去检查这些东西的,因为他们也明白光靠一个人去做一个在线购物网站,在没有现有代码框架的基础上,基本不可能让一个大四学生在半年内完成(准确来说是4个月左右,除非是大佬!大佬请带带我…),所以整个毕设的过程,基本就会围绕着前端展开!页面做的好看,就像媳妇领进门,后续的优化就会慢慢去磨合,慢慢去优化,毕设老师们也会<strong>放你一马</strong>(最主要的就是答辩的时候你一定要懂得说出来,如何优化!要blabla一大堆!让毕设老师觉得,恩,这小伙子(姑娘,不错)</p><p>西电毕设才不会那么随便</p><p>虽然前面我自说自话了一大堆所谓的<strong>毕设通关宝典</strong>,但是我还是要为我校说点好话的.西电不是一个985,也可算是一个211学校.不算很好的学校,也不算很差的学校.在我看来,我们西电的学生大部分都是好学生,一个个怀揣着自己的梦想.大学是自由的,如何度过,老师不会来管你,学校规定的那些任务以及要求,只要你不要浪过头,就都可以完成.在我认识的同学里面,有一直玩游戏的,也有一直钻研自己的东西的,也有学霸天天好好上课学习的,当然大部分都是完成正常课程同时业余时间玩自己的业余活动的同学居多的.</p><p>但不管怎么样,不同的人也都在大四那年迎来了自己不同的结局.学习好的都找到了薪资更高的工作,奔赴北上广深,为自己的梦想不断前行.不怎么优秀但是为人脚踏实地的同学,也都能找到一份不错的工作;学习不太好,平时不太学习本专业知识的,最后也都会有自己的想法,去走不同的路.</p><p>如果说大学前三年在学习知识,那么可以说大四就是在体验一份浓浓的人生咖啡.担任毕设老师中,也有不少非常不错的老师,在毕设期间,用他们的一言一行,传达给我们各种各样的人生技能和专业技能.让我受益匪浅.(<strong>曾老师</strong>就是我特别崇拜的一名毕设老师,当时他担任我的毕设老师,我也特比感谢可以在大学的最后一个阶段,遇到他,遇到这么好的一个老师)</p><h2 id="手游的那些事"><a href="#手游的那些事" class="headerlink" title="手游的那些事"></a>手游的那些事</h2><p>先是感叹国内acg文化的茁壮发展，大概几年前,国内的宅er还要死要活翻墙去玩岛国的<strong>舰队collection</strong>,和自己的老婆相隔一个国度,还经常遇到<strong>猫</strong>危机(舰队collection连接服务器失败会弹出一只猫的画面)</p><p>没想到过了不到几年,国内的宅er就有了很多国产老婆可以玩了~</p><p><strong>少女前线</strong>就是一款枪械拟人的游戏,把不同的枪械变化为一个萌萌的妹子,然后宅er可以带着她们前往前线进行战斗,体验到美少女战斗的舒爽快感(反正我们就是喜欢小姐姐!)</p><p>虽然我是不太喜欢这类游戏的,因为他们一般都会比较肝,特别耗时间去玩,不过当时由于其游戏性还不错(比舰娘要好玩),游戏剧情设置较合理,也是吸引我玩了一段时间.这款游戏还是在我无聊的时光里带给我了不少欢乐.虽然后来参与工作后,就不怎么玩,不过我也会偶尔去看看这游戏,真心希望官方可以好好的做好这个游戏,给这类游戏一个满意的答卷.而不是三分热度,捞一笔就跑路.</p><p>本来以为这个小节我能讲很多,但没想到真正写的时候,缺没有什么值得讲的东西.</p><ol><li>我才不会讲我曾借助按键精灵写了一个按键脚本,在电脑上无限刷5-4.</li><li>我才不会讲我曾因为剧情发展到关键时候,发帖说了”AR-15请千万不要出事”这些话语.</li><li>我才不会讲半夜睡不着,是各个枪娘陪伴着我度过不眠之夜.</li></ol><p>好吧,要说的真的不多呢,这小节就到此为止吧! 祝愿少女前线可以在2018年能红红火火.</p><h2 id="就业"><a href="#就业" class="headerlink" title="就业"></a>就业</h2><p>过了毕设那段时光后,便马不停蹄的前往了自己的工作单位进行相关工作.</p><p>真正觉得自己还不够努力,但却有点无可奈何</p><p>当时校招的时候,由于害怕一线城市的就业压力大,所以选择了二线城市的一个公司工作.<br>虽然工资在同行里不算很高,不过公司提供吃住方面都很不错,所以我很快就适应了工作岗位.</p><p>一开始,我参与了公司的尝试性项目,这个项目主要是新人试水项目,简单来说就是看看你这人的能力怎么样.因为面试的过程中,有太多的包装,根本不知道招进来的人到底有多少能耐.所以我们公司都会有这类尝试性项目,专门丢给新人做,然后综合评估新人的代码能力,处理能力,团队沟通能力.</p><p>幸运的是,我的工作表现貌似非常不错,那段时间生活就只有工作和休息,放弃了自己爱玩的游戏,放弃了自己爱看的动漫,全身心的投入到工作中去.</p><p>程序员加班是难免的,更简单的说,21世纪加班都是不可难免的.初创公司就不说了,很多大公司应该也用经常加班加点干活.个人认为加班加点有部分是项目本身有问题,有部分也是自己的问题.一般来说,如果你很优秀,你完全可以写出非常易扩展和维护的代码,而降低自己返工的次数和时间.有时候需求是不明确的,这种时候就需要有一定的开发经验,去提前预见到一些需求,并且提前完成它.如果能做到这样的话,我想加班加点也一定会减少的.</p><p>工作虽然重要,但是生活还是要继续</p><p>在经过一段时间的拼命工作后,我也开始慢慢放慢自己的节奏,我更喜欢每天可以有时间去学习学习新技术,看看一些编程书籍,一些写的不错的博客,来提升自己的眼界.</p><p>因为很多时候,我们的工作范围时很小的,这对自我的提升可以说是很小的.所以经常去看看别的技术,可以起到润滑剂的作用,让自己保持一定的鲜度,也会让自己工作更顺心.</p><h2 id="对2018的祈祷"><a href="#对2018的祈祷" class="headerlink" title="对2018的祈祷"></a>对2018的祈祷</h2><p>来年我希望自己可以做到更多的事情</p><ol><li>遇到自己喜欢的老婆</li><li>对自己要求高点,少玩游戏,多读书!</li><li>工作要更加勤勤恳恳,认真对待!</li><li>如果允许的话,想着可以找个杭州的工作!</li><li>希望爸爸妈妈老去的更慢些!而自己要强大的更快些!</li></ol>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学的日子(二)</title>
      <link href="/2019/04/24/%E5%A4%A7%E5%AD%A6%E7%9A%84%E6%97%A5%E5%AD%90-%E4%BA%8C/"/>
      <url>/2019/04/24/%E5%A4%A7%E5%AD%A6%E7%9A%84%E6%97%A5%E5%AD%90-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>好久不见，我的博客。离上次写博客，已经有很长一段时间过去了，这段时间之间自己刚毕业，刚迈入工作岗位，每天拼命的工作，生活不是很安定，和以前的大学生活差距很大，自然而然就没什么心情写写博客了。可能是因为想倾诉的东西很多吧，有太多的东西想倾诉给某人听，不过自己身边并没有那么适合的人，所以我最终还是找回自己的博客，将自己想说的都说给我自己的博客听。</p><p>这次我想回忆回忆自己的大学学习生活。</p><p>我是一名普通的西安电子科技大学软件学院的学生，我今天就想好好的说一说我自己在大学的学习故事。</p><h2 id="西电有一个很好的软件IT氛围"><a href="#西电有一个很好的软件IT氛围" class="headerlink" title="西电有一个很好的软件IT氛围"></a>西电有一个很好的软件IT氛围</h2><p>大二左右的时候，自己打开qq和微信就可以看到很多人拉队友，参加各种竞赛，增加自己的能力和经验，自己身边也不乏各种编程大神，当我还只会使用windows的时候，人家都已经熟练的使用着ubantu了。每次做软件的大作业的时候，我总会花一两礼拜的时间，泡在图书馆里，学习编程知识，然后边问那些大神们，边完成自己的软件大作业。没有他们，我都不知道自己模拟制作的那些聊天室，web网站(基本处于玩玩的那种程度吧)能不能按时完成呢。我非常感谢自己可以很幸运的遇到他们，能够在他们提供的帮助下，一次次的完成老师布置的软件大作业，不会被老师挨骂，同时也会有那么一点点小小的成就感，毕竟程序的完成，都是我自己一个个代码敲出来的，虽然其实现方式和代码总体架构和设计上完成不能看就是了，基本处于做完就废的那种感觉。我也非常感谢他们不断的在我身边熏陶着一些编程新闻，让我至少在聊软件的时候，可以多说几句我知道的东西。现在很多人认为学软件是不错的选择，不过我还是善意的提醒一句，如果你真的喜欢敲代码，那么我不介意你去学，如果你只是单纯的想找一份比较好的工作，那么我觉得软件这一行业是不适合你的。</p><h2 id="贵在坚持"><a href="#贵在坚持" class="headerlink" title="贵在坚持"></a>贵在坚持</h2><p>大一大二的时候，都是在上编程的基础课程，基本没有自己真正去敲代码的经验，所以自己真正接触代码的时间应该要从大三开始吧。大一大二平平庸庸的过了两年后，我慢慢的察觉到在大学里，按时完成老师布置的作业真的是远远不够的。我不知道985的学校是怎么样的，反正我觉得现在内陆的大学，因为看重毕业率，在大学学习，非常自由，老师不会给太难的任务，导师不会给太多的约束，完全就属于放养的状态。那么我们这些从小就按部就班，一步一步走过来的人呢，就会感觉没有了明确的目标，学习的劲头也没有以前足，加上有些人本身也并不喜欢软件这个专业。差不多到了大三，可以明显的看出我们这批人开始行动了起来，有的开始认真学习自己的专业知识，有的开始另求后路。大三这一年最辛苦的应该就是这些人了，他们每天应该看上去都像一个拼命三郎，每天都在准备的去翻越眼前的大山。我差不多也是这个时候开始喜欢泡图书馆，每天上完课，就回去图书馆看书学习，也是那个时候把自己的Mac系统用了起来，卸载了原来的windows。自从开始用Mac系统后，就开始慢慢的喜欢捣鼓自己的东西，因为Mac系统玩不了很多流行的游戏，自然而然我的时间就更多的花到了自己喜欢的地方去了。这些时间，有些我用来逛自己喜欢的博客，看看他们的生活和技术博文；有些我用来捣鼓Mac系统的使用，使得它更加的适合我平时的学习和使用；还有一些时间我就用来看看视频，发发弹幕，修身养性了。软件编程，我们经常会碰到一些奇奇怪怪的问题，这是因为我们现在大部分的程序员都是在使用软件巨人们帮我们打好的”地基”上面进行开发，由于我们对这些”地基”了解程度不够，没有好好的看文档，也没有好好的去理解深层的原理；有时候一个问题，可能会麻烦你好几天也没有个解决方法。这很考验一个人的坚持能力，如果你坚持了，说不定你成功了。做软件的，如果你真喜欢，那么不管发生什么事情，都请静下来，一个个的去解决眼前的问题，在解决完以后，自己要花点时间去思考，去总结，才能有所收获！</p><h2 id="大学-玩"><a href="#大学-玩" class="headerlink" title="大学==玩?"></a>大学==玩?</h2><p>至少在我小时候居住的环境下，都流行着一种不好的风气，就是高中好好念，上个好大学，在大学里就可以不用像高中那样拼命学习。正如我现在的导师所说，你现在努力过头，不给自己一个喘气的机会，你怎么保证自己可以一直这种状态工作下去呢？没错，现在很多小孩子，从小学，初中到高中，特别是高三，更是把自己的全部都豁了出去，就像这是自己一生中最后一次拼搏一样，有些努力的身体出毛病，有些则努力的自己的心理也开始扭曲。所以一旦毕了业，就会非常想好好休息休息，而因为之前拼搏太久，可能那三个月一点点的假期是远远不够的。所以自然而然，到了大学，我们开始追求自由的生活，不再那么努力，不再那么的看重学业，感觉自己的未来明朗清晰，把大学按部就班的读好，就可以找个好点的工作，然后开始自己的后半生。那么往往这样的结果是不好的。有句话说得好，出来混总有一天要还的。大学才是我们人生中最重要的时刻，你如何利用好你的大学时光，才能真正的决定你的未来。</p><h2 id="大四的那点小事"><a href="#大四的那点小事" class="headerlink" title="大四的那点小事"></a>大四的那点小事</h2><p>西电软院，每年大三暑假都会安排一次实训，和一些软件公司合作，安排我们这些娃子去他们那里实习，实习的内容都是做一个模拟的项目，几个人一个小组进行正常的工作。我认为这是非常好的，甚至比有些自己找的实习机会更加的有帮助。如果在看这篇文章的同学正好是我校友而且也是软院的学生的话，如果你正在烦恼实习怎么办的话，强烈建议你不用花时间去找个自己不喜欢的单位，然后在那里面实习，而是参加学校安排的实训，重点不是看你去哪里实习，而是要看你在实习的时候做了什么。实训的时候如果你想着水过去，那么也就水过去了，因为毕竟只是实训，项目经理不会过来骂你，说你完成的不好，完成的不对。所以还是那句话，自己要严格要求自己。大三实训完接着就是大四的上半学期，各大公司都会过来学校校招，这是一个丰收自己的学习成果的阶段，机会都是留给有准备的人的。但是要进好公司，比如腾讯，阿里，那么你估计需要大量的努力和一点点好运。同时我也推荐你们能进到互联网公司而不是传统IT行业。虽然互联网公司对技术要求高，但是对你来说，可以算是一个很好的平台，站得越高，看得越远。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>感觉自言自语的很久，也算是对自己的大学生活的学习过程有了一个小总结，日后可以自己看看.</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回忆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>踩坑的Bug总集</title>
      <link href="/2019/04/24/%E8%B8%A9%E5%9D%91%E7%9A%84Bug%E6%80%BB%E9%9B%86/"/>
      <url>/2019/04/24/%E8%B8%A9%E5%9D%91%E7%9A%84Bug%E6%80%BB%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>主要纪录我面向Google编程失败后自己解决的部分值得纪录问题，为LTS版本，长期更新</p><h2 id="Java-Exceptions"><a href="#Java-Exceptions" class="headerlink" title="Java Exceptions"></a>Java Exceptions</h2><hr><h3 id="1-java-lang-NoSuchMethodError-com-mchange-v2-async-ThreadPoolAsynchronousRunner"><a href="#1-java-lang-NoSuchMethodError-com-mchange-v2-async-ThreadPoolAsynchronousRunner" class="headerlink" title="1.java.lang.NoSuchMethodError: com.mchange.v2.async.ThreadPoolAsynchronousRunner."></a>1.java.lang.NoSuchMethodError: com.mchange.v2.async.ThreadPoolAsynchronousRunner.</h3><p>第一次遇到这种java异常，看字面意思，找不到这样的方法的错误。</p><p>哇 当时看到这个错误 第一个反应就是 我是不是没导这个jar包？ 然后我排查了一次jar包后发现，明明就有，所以我就非常的无奈，一边吐槽着垃圾Eclipse 一边无奈的各种网上搜解决方案</p><p>很显然，大部分回答都是，checkout your jar！ </p><p>但是我检查了jar包 然后海点进去检查了此jar包的对应的此方法，都是存在的 </p><p>同时我也没有使用maven 不存在maven方面的问题 </p><p>所以我就开始心急如焚，因为我发现自己解决不了这个问题 面向google编程也即将失效</p><p>就在我快要崩溃的时候，看到有一个人说，会不会是jar包冲突？</p><p>我瞬间就反应过来，还真说不定。因为我搭建这个项目的时候，跟着教程无脑导入了大量的jar包，也许就是这个问题</p><p>于是，我使用了eclispse的类搜索功能。我一搜ThreadPoolAsynchronousRunner。。</p><p>发现居然有两个结果</p><p>好吧 同名类。。。。</p><p>于是我删除了其中一个。。。</p><p>运行后 异常消失，一切正常。</p><h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>在java项目中导入jar包乱导入 没有自己去一个个分析每个包的作用导致的jar包冲突的问题。 就好比现实中，有病乱投医，什么药都吃。也表示我吗以后着手做事情的时候，一定要把自己的工具的作用了解清楚再做后续的事情。</p><h2 id="Mysql-Exception"><a href="#Mysql-Exception" class="headerlink" title="Mysql Exception"></a>Mysql Exception</h2><hr><h3 id="1-the-right-syntax-to-use-near-“xxx”"><a href="#1-the-right-syntax-to-use-near-“xxx”" class="headerlink" title="1.  the right syntax to use near “xxx”"></a>1.  the right syntax to use near “xxx”</h3><p>当你看到sql报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to &gt;your MySQL server version for the right syntax to use near &apos;desc, name) &gt;values (2, &apos;Test town desc.&apos;, &apos;Test town&apos;)&apos; at line 1</span><br></pre></td></tr></table></figure></p><p>类似这样的错误</p><p>第一反应便是 你使用了mysql的保留字作为了你的数据库表名或者列名</p>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bugs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自由软件许可证杂谈</title>
      <link href="/2019/04/24/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E8%AF%81%E6%9D%82%E8%B0%88/"/>
      <url>/2019/04/24/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E8%AF%81%E6%9D%82%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<p>昨天刚回浙江老家，在家里闷着无聊的时候，无意间瞄到了shadowsocks的Apache自由软件许可证，一时觉得很好奇，脑海里没有这方面的了解，就开始在网上看起了这方面的知识。于是乎是到了该总结的时候了。</p><p>我仅会在此文章讨论下计算机软件的相关话题，即不会讨论别的事物的版权等问题，顶多会用别的东西来做个比方。</p><h3 id="还是从copyright说起"><a href="#还是从copyright说起" class="headerlink" title="还是从copyright说起"></a>还是从copyright说起</h3><hr><p>在我国，copyright就是著作权或者说版权的象征<sup id="fnref:freesw-1"><a class="footnote-ref" href="#fn:freesw-1" rel="footnote">1</a></sup>，比如小说，音乐，美术，甚至配音作品（cv一般都是在一个事务所下工作的，所以很多cv的配音版权可能都是归属于一个事务所里，但是这个是纯属我自己的猜测，我暂时也不想再上网去看看有关这方面的知识，我只知道必须一个cv配一个角色，那么除非这个cv无法继续进行配音工作，不然不能让别的cv来代役）</p><p>你也许觉得你的作品如果不发表到公共领域就不会受到著作权的保护，其实不然。其实只要你完成了一个作品，并且具有独创性，那么你就享有者著作权的保护。</p><p>我们经常可以在一些网站的底部看到copyright xxxx-xxxx by xxx .这些字样就表明了作者在声明自己的著作权，同时如果你再不经过作者同意的情况下对作品进行转发，分发，修改或者销售，就会受到法律的制裁。</p><p>一般来说一个拥有著作权的作者有权对自己的作品如果用语商业用途后对要使用自己作品的商人收取部分著作费。这些费用是支持和鼓励作者保持一个良好的创造力的方法。毕竟人都是这样，有奖励才会有动力继续做。（做自己喜欢的事情，本身就是一种奖励，所以我们都喜欢无私的为自己喜欢的事情做贡献）</p><p>那么为什么还会有copyleft机制呢？如果说copyright是为了使得人类的创造力能够源远流长，不会乱流，那么copyleft的出现岂不是“助纣为虐”，帮助那些非法使用者们非法的使用别人辛辛苦苦的制作出来的作品。</p><h3 id="copyleft和free-software"><a href="#copyleft和free-software" class="headerlink" title="copyleft和free software"></a>copyleft和free software</h3><hr><p>其实copyleft的出现是和“自由软件”<sup id="fnref:freesw-2"><a class="footnote-ref" href="#fn:freesw-2" rel="footnote">2</a></sup>息息相关的。现在我们可能见到的比较多的就是“开源”“open source”这样的字样，比如我们的android系统就是（部分）开源系统，有很多大牛投入其中，并且研究出了很多类似android的衍生系统。</p><p>软件是开源的，代表我们可以阅读源代码，但其实并不意味了我们可以对其进行任意的修改，复制，或者用着其他用途，开源的软件，依然享有著作权，你可以看到大大的copyright声明贴在最下方，或者一个项目的项目说明书之类的地方。</p><p>那么，我说的自由软件和copyleft的关系呢？其实copyleft就是专门为自由软件而存在的。“自由软件”其实就是不仅“开源”而且“do what you want to do！”。可能说成做任意你想做的说法不是很合适，至于为什么不是很合适，我会在下文继续说明。</p><p>是copyleft的软件，那么就是自由软件，您可以在获取这个软件后，对该软件进行任意的修改，分发，或者改进软件后使其变成更优秀的软件，但是你必须要让这个派生作品也是一个copyleft的软件，即自由软件，不能让其变成一个私有软件或者专有软件从而让使用这软件的人们感觉不自由，或者处于不自由的状态。</p><p>如果说一个软件不是一个自由软件，那么也许就会像一个垄断一样，全世界只有你一个公司知道这个软件的源代码，你的用户对你的软件会产生极大的依赖性，从而导致你可以任意收取你想要的费用，使得你的财产越做越大！</p><p>但是如果说全世界只剩下私有软件或者专有软件，那么我们作为用户的权利就会微乎其微，因为用户无法知道自己所使用的软件，是否在正确的工作。（我相信在看的读者，一定看到过一些恶意软件的新闻，比如在后台自动收集该台电脑的各项记录或者数据等，这种在背后做的恶意软件的产生和肆意妄为，都是因为用户对源代码的未知）</p><p>从上述观点中，我们不难看出，如果赋予一个软件copyleft，那么这个软件就会是安全的，而且是可以健康成长的！而不会使得这个软件被不正当的人群拿去使坏，除非他们不怕坐牢。</p><p>不过我们也从前面的讨论中发现，也许只是一个copyright或者copyleft无法适应软件的各方面变化需求，比如你有一个copyleft的软件，但是却希望别的人可以拿去自由使用，甚至可以拿去使用做商业用途或者做出闭源这样的做法。一般来说，用户可以通过询问作者，来获取这方面的权限，但是如果用户多，问得多，就会对作者的生活感到很大的困扰。所以就有了自由软件许可证书。目前有很多自由软件许可证书，比如GNU GPL，GNU LGPL，BSD，MIT，Apache许可证等。不同的许可证有不同的对该自由软件的要求。不过关于自由开源许可证的内容，我放到下一节来讲</p><h3 id="自由开源许可证"><a href="#自由开源许可证" class="headerlink" title="自由开源许可证"></a>自由开源许可证</h3><hr><p>其实copyleft的创始人也是GNU项目的创始人，所以GNU的证书都是copyleft的，和Apache开源许可证一对比，最大的差别就是，GNU GPL等证书用户修改后不能闭源，要继续保持开源，即继续作为一个自由软件为社区社会作出贡献。</p><p>你能看到现在的很多软件，都会有一个copyright说明，同时还有一个自由开源许可证的保护。copyright保护了作者的著作权，而自由开源许可证则保护了软件的自由。如果一个软件没有说明自己是基于哪个自由开源许可证的，那么该软件就是基于我们的著作权保护法，你不能随意对作品进行复制，分发，修改或者改进。自由开源许可证就像是软件的保护法，保护着软件的各项行为。</p><p>而关于各类许可证的作用，在网上则有很多说明文档，我这里就不重复赘述，但是也并无妨碍我说一下很常见的许可证，比如Apache自由开源许可证。这个许可证的要求是很低的，它不要求修改后的源代码必须开源，但是它要求修改过的文件，必须放置版权说明。</p><h3 id="尾语"><a href="#尾语" class="headerlink" title="尾语"></a>尾语</h3><p>我估摸着想讲的好像都已经讲完了。我写这篇文章的目的主要还是在于，防止自己再未来看到许可证的时候不会一脸呆滞，至少我了解过这方面的知识，我知道这些许可证和版权的区别！</p><hr><p><li id="fn:freesw-1">[1]可参见<a href="https://en.wikipedia.org/wiki/Copyright" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Copyright</a><a href="https://en.wikipedia.org/wiki/Copyright" target="_blank">&#8617;</a></li></p><p><li id="fn:freesw-2">[2]可参见<a href="https://fsfs-zh.readthedocs.io/zh/latest/" target="_blank" rel="noopener">https://fsfs-zh.readthedocs.io/zh/latest/</a><a href="https://fsfs-zh.readthedocs.io/zh/latest/" target="_blank">&#8617;</a></li></p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bugs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet的总结</title>
      <link href="/2019/04/24/Servlet%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2019/04/24/Servlet%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>一篇对JavaWeb的Servlet的个人理解</p><a id="more"></a><h2 id="什么是Servlet"><a href="#什么是Servlet" class="headerlink" title="什么是Servlet"></a>什么是Servlet</h2><hr><p>servlet是运行在web服务器上的小型Java程序（即服务器端的小应用程序），servlet通常通过HTTP接收和响应来自web客户端的要求</p><p>我所熟知的是关于httpservlet的使用。不要觉得知道了http servlet，但是却不知道https的相关使用。其实https只是http的一层安全包装而已，底层使用的还是一样的东西。所以并没有https servlet这个说法</p><p>本文不会阐述servlet的使用。因为会使用和懂是两码事，比如你知道枪如何使用，但是你知道枪的内部运行原理吗？</p><p>所以本节将努力的将Servlet的工作原理解释清楚，希望学习web开发的读者也可以用心去理解，虽然不需要你去掌握，但至少理解是必要的。</p><h2 id="Tomcat基本知识"><a href="#Tomcat基本知识" class="headerlink" title="Tomcat基本知识"></a>Tomcat基本知识</h2><hr><p>对于学习web开发的我们来说，tomcat那是再熟悉不过的东西了。简单来说，tomcat就是一种servlet容器，就好比手枪，手枪有很多种，tomcat就像一种手枪，里面装的“子弹“就是我们要讲的servlet。这小节我会阐述下什么是tomcat，tomcat怎么样，tomcat能干什么</p><p>作为web开发人员来说，知道tomcat，那么肯定也知道apache。</p><p>Tomcat现在是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目。由Apache、Sun 和其他一些公司及个人共同开发而成。（Java开发人员不知道Sun的人可以去死了）</p><p>Tomcat的特点</p><ul><li>免费，开源，清凉，很适合我们学习人员的使用。</li><li>它内含了一个单独的Http服务器，它也可以被视作一个单独的Web服务器。但是如果说只是将Tomcat用于单独的web服务器，那么在一些有速度和事务处理有要求的情况下来说是不利的，他没有其它完备的web服务器功能那么牛逼，比如（Apache服务器？）所以Tomcat常常会讲其中的Servlet引擎配合其它web服务器使用。</li><li>Tomcat实现了对Servlet和JavaServer Page（JSP）的支持，所以Tomcat内部有一个Jsp编译器（Jsper模块），用以将JSP编译成一个Servlet。这里就不得不说JSP的九大隐含对象了，request，response，pageContext，session，application，config，out，page，exception</li></ul><p>Tomcat简单来说就是可以作为一个简易的web服务器，你可以将你的站点放置在Tomcat上，由Tomcat进行管理。</p><h2 id="Tomcat的总体架构"><a href="#Tomcat的总体架构" class="headerlink" title="Tomcat的总体架构"></a>Tomcat的总体架构</h2><hr><p>讲完了Tomcat的一些基本知识，接下来说说Tomcat的总体架构</p><p>一个好的软件是需要非常模块化的，tomcat也不例外，我们先了解了Tomcat的总体架构，那么再对其中的一部分一部分进行分析，我想作为一个web开发人员，你掌握了这些，也可算是合格的一员了。</p><p>先给出一张tomcat容器模型图<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image001.gif"></p><p>可以看到一个tomcat下可以有很多个Service服务。</p><p>Service可以说是一个接口，实现它的标准类是StandardService<br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image002.png"><br><img src="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/image003.png"></p><p>所以说一个Service服务，其实就是一个StandardService的实例进程。</p><p>那么我们可以说说一个StandardService在干嘛呢？从上图的方法名就可以知道，比如setContainer,setServer,addConnector（这些Container和Connector后面会重点讲，先别急）<br>这些方法其实可以说是对Container和Connector等相关初始化工作</p><p>是的，Service其实就是Container和Connector的一个外部包装，专门负责Container和Connector之间的管理。比如一个Connector要将request和response传递给Container，就是需要Service的帮忙。</p><p>那么Service由谁来管理呢？ 233，也许你会脱口而出，“由tomcat管理”。哈哈，tomcat其实只是一个名字而已，真正管理Service的肯定也是代码呢。</p><p>细心的同学应该会发现，之前有一个setServer方法，那么Server是谁呢？ 我想聪明的你肯定猜到了，对Server就是管理Service的。Server类中有一个addService方法，用于添加Service。</p><p>ok，说到这里，我想大家应该对Server和Service有了大致的了解，那么接下来就来说说有关Service内部的事情。</p><hr><p>我们知道Service里面包含有Container和Connector，简单来说Connector是负责接收浏览器的发过来的 tcp 连接请求<br>，然后将其信息封装为Request和Response，将其传递给Container处理（在一个子线程中执行Container，主线程依旧等待新的tcp请求）</p><p>ok，我想大家应该知道Container和Connector之间的关系了吧，那么接下来说说Connector是如何工作的</p><p>Tomcat5 中默认的 Connector 是 Coyote，这个 Connector 是可以选择替换的.（至今也仍然在使用Coyote，此外是可以替换的，也说明了Tomcat模块化很好。是的，模块好真的很不错！其实减轻了不少开发人员的负担，可以更好的分配工作）</p><h6 id="首先呢Connector如何接受tcp请求？"><a href="#首先呢Connector如何接受tcp请求？" class="headerlink" title="首先呢Connector如何接受tcp请求？"></a>首先呢Connector如何接受tcp请求？</h6><p>嗯，交给Socket呗，不多讲了</p><h6 id="其次呢Connector是如何管理多个请求的？多线程体现在哪里？"><a href="#其次呢Connector是如何管理多个请求的？多线程体现在哪里？" class="headerlink" title="其次呢Connector是如何管理多个请求的？多线程体现在哪里？"></a>其次呢Connector是如何管理多个请求的？多线程体现在哪里？</h6><p>你可以理解为一个while循环，检测一个信号量，如果有请求来了，会改变这个信号量，从而进入while循环内部，然后就会进行一次有关操作了。</p><p>同时主线程继续等待，等待新的请求进来。</p><h6 id="Connector如何处理一次请求的"><a href="#Connector如何处理一次请求的" class="headerlink" title="Connector如何处理一次请求的"></a>Connector如何处理一次请求的</h6><p>Connector处理一次请求，靠的是两个类的运作，HttpConnector和HttpProcessor</p><p>HttpConnector用于等待新的请求，有新的请求后，就会转交给HttpProcessor处理，HttpProcessor的process方法，会将tcp请求的信息封装为对应的Request和Response实例</p><p>最后这个Request和Response就会转递给Container，而转递的任务就是之前讲的Service的工作了。</p><hr><p>理解了Connector的工作原理后，我们就来讲讲Container的工作原理吧</p><p>我们还是先来看看container容器的内部模型图</p><img src="https://www.ibm.com/developerworks/cn/java/j-lo-servlet/image002.jpg"><p>可以看到一个Container内部有Engine，Host，Context还有Wrapper。ok，还是简单之上，我们其实不需要了解的很细，只要知道其每个部分都在干什么就行了</p><h6 id="Engine容器"><a href="#Engine容器" class="headerlink" title="Engine容器"></a>Engine容器</h6><p>首先一个Container里有一个Engine容器，这个容器比较简单，它只定义了一些基本的关联关系，初始化和它相关联的组件，以及一些事件的监听。一个简单的Servlet，也许根本不需要Engine这一层的管理</p><hr><h6 id="Host容器"><a href="#Host容器" class="headerlink" title="Host容器"></a>Host容器</h6><p>从英文单词上看就知道，host代表主机，不过host容器可以有多个，所以如果对web开发比较熟悉的人，应该就知道了，host其实就代表虚拟主机的意思。对，所以说其实一个host容器就代表一个站点哦！ 比方说，我想再建立一个站点，但是我不需要再去找一个web服务器重新设置我的站点，我只需要建立一个虚拟主机，虽然url看上去不一样，但是其实请求都是有同一个container再处理数据哦。</p><hr><h6 id="Context容器"><a href="#Context容器" class="headerlink" title="Context容器"></a>Context容器</h6><p>Context代表Servlet的Context，它具备了Servlet运行的基本环境，理论上只要有Context就能运行Servlet了。简单的Tomcat可以没有Engine和Host。</p><p>所以简单来说，Context用于管理Servlet！</p><hr><h6 id="Wrapper容器"><a href="#Wrapper容器" class="headerlink" title="Wrapper容器"></a>Wrapper容器</h6><p>Wrapper 代表一个 Servlet，它负责管理一个 Servlet，包括的 Servlet 的装载、初始化、执行以及资源回收。Wrapper 是最底层的容器，它没有子容器了，所以调用它的 addChild 将会报错。</p><p>所以说一个Context容器里可以有很多个Wrapper，我们每次在web.xml中注册一个Servlet的时候，就会相应的建立一个Wrapper哦</p><hr><h2 id="Servlet的工作原理"><a href="#Servlet的工作原理" class="headerlink" title="Servlet的工作原理"></a>Servlet的工作原理</h2><hr><h5 id="Servlet的初始化流程"><a href="#Servlet的初始化流程" class="headerlink" title="Servlet的初始化流程"></a>Servlet的初始化流程</h5><p>我们之前有提到Context容器就是Servlet的居住地，里面的Wrapper就代表一个Servlet。（ps：Wrapper只是一层Servlet的封装，为了将Servlet和tomcat分开，因为tomcat是tomcat，而servlet则是另一个领域模块，意思就是说，也许今后会有更厉害的servlet改装版本，然后这个改装版本就可以直接装入wrapper类中，体现了低耦合，高内聚）</p><p>要执行一个Servlet的相关方法前，我们肯定要先实例化Servlet，由Context容器来实例化Servlet，那么我们就先从Conetxt的初始化讲起</p><p>Context容器的初始化可以看两大部分</p><p>1.ContextConfig 的 init 方法将会主要完成以下工作：</p><ul><li>创建用于解析 xml 配置文件的 contextDigester 对象</li><li>读取默认 context.xml 配置文件，如果存在解析它</li><li>读取默认 Host 配置文件，如果存在解析它</li><li>读取默认 Context 自身的配置文件，如果存在解析它</li><li>设置 Context 的 DocBase</li></ul><p>2.ContextConfig 的 init 方法完成后，Context 容器的会执行 startInternal 方法，这个方法启动逻辑比较复杂，主要包括如下几个部分：</p><ul><li>创建读取资源文件的对象</li><li>创建 ClassLoader 对象</li><li>设置应用的工作目录</li><li>启动相关的辅助类如：logger、realm、resources 等</li><li>修改启动状态，通知感兴趣的观察者（Web 应用的配置）<br>子容器的初始化</li><li>获取 ServletContext 并设置必要的参数</li><li>初始化“load on startup”的 Servlet</li></ul><p>这其中是很复杂的，但是我现在主要任务是让大家理解总体脉络，细节部分也不是我们应该掌握的</p><p>既然Context容器的初始化工作完了，那么接下来就要解析一个web应用了。我们知道一个web应用的一个重要的配置文件叫web.xml。所以说，接下来Context容器就会去解析web.xml文件，有Servlet就想应的调用wrapper的相关方法，初始化，创建Servlet等。所以说 Context 容器才是真正运行 Servlet 的 Servlet 容器。一个 Web 应用对应一个 Context 容器。</p><h6 id="Servlet实例"><a href="#Servlet实例" class="headerlink" title="Servlet实例"></a>Servlet实例</h6><p>上文所讲的，我们就已经做完了所有Servlet的初始化工作，接下来我们就要在应用启动的时候，实例化对应的Servlet了。Tomcat在实例化Servlet的时候，是按照有需求再实例化的逻辑的。不过其实这样是不好的，因为如果一个servlet的内容过去庞大的话，在初始化的时候就会需要大量的时间，那么这个初始化时间对于使用这个wen应用的客户来说就是一个blank的盲等待，过场的等待会让客户很生气的，毕竟电脑上的等待10秒，相当于等地铁30分钟呢。所以说，我们要尽量设置load-on-startup属性，这个属性设置后，Context容器就会在Tomcat启动的时候对相应的Servlet进行一次实例化</p><p>Servlet实例化的工作由Wrapper完成，Wrapper简单的调用Servlet的init方法，对Servlet进行初始化。（当然这里还可能初始化的是一个jspServlet，不过道理一样，不多说了）</p><hr><h2 id="Servlet的体系结构"><a href="#Servlet的体系结构" class="headerlink" title="Servlet的体系结构"></a>Servlet的体系结构</h2><hr><img src="https://www.ibm.com/developerworks/cn/java/j-lo-servlet/image010.jpg"><p>从上图可以看到，和Servlet有关的类有ServletRequest，ServletResponse，ServletConfig，ServletContext</p><p>Request和Response我们就不多说了，这个学过Servlet的使用后就一定会接触的</p><p>ServletConfig，可以说是具有这个Servlet的相关配置信息的类</p><p>而ServletConetxt，则有这个Servlet所寄居的Contetx容器的相关信息，具体信息都请查阅相关API接口</p><hr><h2 id="Servlet如何工作"><a href="#Servlet如何工作" class="headerlink" title="Servlet如何工作"></a>Servlet如何工作</h2><hr><p>一个请求到来后，如何知道这个请求要去哪个Servlet里进行相关操作呢？</p><p>这个分配去向的任务很简单</p><p>将url解析，映射到对应的Container容器，Container容器获取到的request里带有mappingData属性，这个属性是mapper类根据这次请求的 hostnane 和 contextpath 将 host 和 context 容器设置到 Request 的 mappingData 属性中的。所以request进入到Conetxt容器里时候，就会知道自己该去哪个wrapper里了！</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Servlet的所有工作流程已经总结完毕，有对其中部分不理解的地方，可以对这个部分进行google的关键字搜索了解更多的知识！</p><p>友情链接：</p><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-servlet/</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/</a></li><li><a href="http://www.tqcto.com/article/web/51385.html" target="_blank" rel="noopener">http://www.tqcto.com/article/web/51385.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的字符编码总结</title>
      <link href="/2019/04/24/%E6%88%91%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%80%BB%E7%BB%93/"/>
      <url>/2019/04/24/%E6%88%91%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>刚开始接触mac osx这类系统的时候，使用default的zip解压，很容易出现乱码问题。每次我使用默认设置解压一个压缩文件的时候，如果这个文件来自一个中国人的windows电脑的话，十有八九肯定是乱码，想都不用想！ 一开始我还没有使用［The Unarchiver］这款软件的时候，用着各种不爽，出现次数多了，火气就起来了（信不信我砸了你，就是这种感觉）</p><p>不过，生气归生气，还是要研究下为什么会出现这种问题的！所以，随后我查阅了好多网上的资料，也看了一些写的比较好的blog学习了下，算是将困扰我很久的字符编码问题给解决了（弄懂一个东西后还真是感觉心情舒畅啊＝v＝）</p><p>其实mac是一直采用utf-8的字符编码，而一般我们中文环境下的windows系统是采用gbk作为默认的字符编码的（现在应该最新的是gb18030，全称叫China National Chinese）。看到这里如果没能反应过来乱码和这两个东西有什么关系的话，没关系，因为接下来我就回来解释下为什么了！</p><h2 id="先从二进制说起"><a href="#先从二进制说起" class="headerlink" title="先从二进制说起"></a>先从二进制说起</h2><hr><p>我们都知道，计算机里使用的都是二进制码，即0，1这两个数字。我们常说的一个字节（byte），其实代表了一个八位（bit）的二进制数字。比如数字32，我们就可以很容易的得出它的二进制表示，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">0010 0000</span><br><span class="line"></span><br><span class="line">1 * 2^5 = 32;</span><br><span class="line">//有关进制之间的互相转换，这个我就不在这里提及了，网上搜一大堆呢，自己学去</span><br></pre></td></tr></table></figure><p>可以看到十进制数32，刚好可以由一个八位的二进制数表示（其实只要六位，前两位的0都没有用到，不过八位刚好凑成一个字节的长度，所以我这里这么说）<br>所以我们在电脑上看到的数字32，在计算机来看，按照上面的这里换算编码的话，就是0010 0000这一串东西了。</p><h2 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h2><hr><p>ASCII码是比较简单的一种编码，它就是用八位的二进制数来表示一些字符的，我们可以知道一个八位的二进制，可以有2^8种，即256种。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000 0000</span><br><span class="line">0000 0001</span><br><span class="line">0000 0010</span><br><span class="line">0000 0100</span><br><span class="line">0000 1000</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">1111 1111</span><br></pre></td></tr></table></figure><p>–<br>从0000 0000到1111 1111，256种情况，可以分别代表256种字符。</p><p>不过，当时这玩意就是做给英文操作系统用的，哪里需要256种，128种其实就够了。所以ASCII码的第一位都是0，这样就把种数变成了128种。</p><blockquote><p>控制字符</p></blockquote><p>ASCII的前32个加上第127个，代表的都是控制符号，这些符号主要用于一些特殊情况，我们作为使用者是不怎么会用到的，这里不会细讲，真的很想了解的同学，please google一下</p><blockquote><p>可显示字符</p></blockquote><p>既然前32个都用来作为控制符号用，那么其他的当然是为我们所用了，比如26个个英文字母，abcdefg…..都有对应的ASCII码。（对于程序员来说，知道A是65，a是97，应该是比较重要的哦＝v＝）</p><p>不管怎么说，ASCII码，这货能干的活仅限于美国佬的computer。如果说要用它来表示我们博大精深的中文汉字，256种哪能够呢。哈哈哈哈</p><p>所以我们接下来来讲讲和中文汉字编码有关的字符编码方式</p><h2 id="Unicode字符编码"><a href="#Unicode字符编码" class="headerlink" title="Unicode字符编码"></a>Unicode字符编码</h2><hr><p>再说中文汉字的字符编码之前，先说说Unicode这个字符编码吧！</p><p>把Unicode说成是一个字符编码是不对的，Unicode其实是字符编码的一个国际标准，其实现方式有很多种，比如utf-8,utf-16,utf-32。</p><p>Unicode使用了16位的二进制数，所以理论上是可以表示2^16次（65536种），这么多基本满足了各类语言对不同符号的需求。</p><p>不过有时候确实16位也不够，那么我们就32位吧，就是4个字节，2^32，这么多总可以了吧，事实上，确实是够了。</p><p>不过当变成32位的时候，又出现了一些问题，比如我们只是简单的表示一个英文字母a，我们如果用32位来表示的话，前面不都是0吗，这些有必要存储吗？没必要</p><p>所以为了让这些0可以去掉，来节省我们的存储空间，所以Unicode的实现方式就有好多种了。</p><p>接下来我们重点就来看看utf-8，这是一个互联网时代通用的unicode实现方式，如果大家都统一用utf8的话，相信乱码问题也会少很多呢</p><h2 id="utf-8"><a href="#utf-8" class="headerlink" title="utf-8"></a>utf-8</h2><hr><blockquote><p>那年我们的网站制作过程全程采用utf8真是太好了！gbk？gb18030？那是什么，我不知道，啊哈哈哈哈</p></blockquote><p>utf8的出现原因是这样的。比如我们要表示一个英文单词a的时候，只需要八位就可以了，那么使用16位的Unicode来表示，前八位不就都变成0，然而这些0是没有意义的，所以当我们仍然采用Unicode的16位进行传输一些英文单词的时候，要传输的内容不就多了一倍，而且这多出来的一倍还特么的是一堆没用的零蛋！</p><p>咳咳，所以说我们要缩短用Unicode表示的英文单词的字符长度！所以就有了utf-8</p><p>utf-8是Unicode在传输的时候使用的一种实现方式！（注意不要以为utf8是一个字符集，错！它只是encoding层次的！utf8的二进制数可以转换回Unicode形式，然后查找Unicode字符集来转译成我们看到的字符！）</p><p>下面我展示一下utf8的编码规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Unicode符号范围 | UTF-8编码方式</span><br><span class="line">(十六进制) | （二进制）</span><br><span class="line">--------------------+---------------------------------------------</span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure><p>1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。<br>2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下<br>的没有提及的二进制位，全部为这个符号的unicode码。</p><p>以上两点就是utf－8的规则！是不是很简单！</p><p>不过不要被其表面的简单所蒙骗了，Unicode虽然好用，不过你如果是一名web开发人员的话，就一定会在意流量问题！</p><p>如果从流量问题角度出发！如果你使用utf8，那么对于中文来说，你的流量会增加50%。因为大部分常用的中文，使用两个字节就可以表示了，如果采用utf8的话，utf8按上面的规则，一个中文字会变成3个字节，这不就多了一个字节的空间了吗！</p><p>还有另一个问题！关于现在有些网站仍在使用的gbk，这个怎么说呢，应该算是一个历史遗留问题了吧。我相信对于开发人员来说，一定更喜欢utf8，毕竟省事！（不过从流量角度出发，gbk还是有优势的！不过多出50%的流量）</p><p>在utf8后还有utf16，utf32，可以理解为是对不同情况下的utf8的拓展</p><h2 id="所以最开始说的乱码问题"><a href="#所以最开始说的乱码问题" class="headerlink" title="所以最开始说的乱码问题"></a>所以最开始说的乱码问题</h2><hr><p>mac电脑默认采用utf8，而很多中文windows系统的文件采用gbk，一个两字节，一个1～3字节，有自己的算法，所以在mac电脑上解压的zip文件默认用Unicode（USC－2）或者utf8 或者utf16le等等（大端be，小端le）来进行解压的时候，自然而然就变成了乱码了！</p>]]></content>
      
      
      <categories>
          
          <category> IT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的恋爱文字冒险游戏答卷</title>
      <link href="/2019/04/24/%E6%88%91%E7%9A%84%E6%81%8B%E7%88%B1%E6%96%87%E5%AD%97%E5%86%92%E9%99%A9%E6%B8%B8%E6%88%8F%E7%AD%94%E5%8D%B7/"/>
      <url>/2019/04/24/%E6%88%91%E7%9A%84%E6%81%8B%E7%88%B1%E6%96%87%E5%AD%97%E5%86%92%E9%99%A9%E6%B8%B8%E6%88%8F%E7%AD%94%E5%8D%B7/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=4922735&auto=1&height=66"></iframe><p>恋爱文字冒险游戏影响了我一定程度的三观，所以特意也为其专门写一篇文章</p><h2 id="《clannad》如果说你认为它只是一部galgame，那么我就要生气了"><a href="#《clannad》如果说你认为它只是一部galgame，那么我就要生气了" class="headerlink" title="《clannad》如果说你认为它只是一部galgame，那么我就要生气了"></a>《clannad》如果说你认为它只是一部galgame，那么我就要生气了</h2><hr><p>这一礼拜重新回温了一款galgame，名叫《your diary》 （cube社的甜作）</p><p>重温这款游戏的初因是9月30号晚上的一时兴起（我觉得最近自己总是一时兴起，但是真正去干好的事情却没有几个，无法彻彻底底的下定决心是我最近的一个大烦恼）</p><p>在我看来，一部好的galgame真的可以改变一个人在现实生活中的处世态度和处世方式，证据就是我自己。我还记得我玩的第一部galgame的时候是高二，那时候高二暑假，临近高三，那年暑假是待在家里度过的（好像是？饿，应该没记错）我的第一部galgame名叫《clannad》，在哥哥的电脑上玩的。我对《clannad》的评价那便是</p><blockquote><p>一款玩通之后会让你怀疑人生的作品</p></blockquote><p>也许看上去我这评价是负面的，但是毫无疑问，这是我对它的一个正面的最高的评价。爱情小说和肥皂剧我都有看过几部，但是感觉其震撼人心的程度却完全不及《clannad》的十万分之一。（不过这可能也只是我的片面评价，就像初高中女生评价自己喜欢的一个肥皂剧的时候，也会说它有多么多么的感动，不过我冷静的思考过后，我感觉我还是这么写比较好，首先这确实是我脑子里蹦出来的第一个想法，其次它确实是改变了我自身的各个方面，而前两者却没有）</p><p>《clannad》牵涉到了爱情，友情，最后还有亲情，包含的东西确实是很多，我跨越了一个暑假的时间去仔细的推敲每个人说的每一句话，在感叹人心复杂外，也有很多很多对自己生活的思考。正是引发了很多对自己生活的思考，所以我觉得《clannad》是超越了小说还有电视剧的一个存在。《clannad》是一部galgame，它是galgame界的一个楷模，确实是带了一个好头，让其后的galgame中也冒出了很多经典的作品（白色相簿啊还有白色相簿啊还有白色相簿啊等等）</p><p>呀，写着写着，《clannad》中的一幕幕又开始扫过自己的脑中，哎，不讲道理啊，就是这么有深度的一款galgame，不然也不会有那么多人说</p><blockquote><p>读作clannad，写作人生</p></blockquote><p>感觉再说这作的事情，自己的情绪就要不受控了，暂且停笔吧</p><h2 id="《your-diary》"><a href="#《your-diary》" class="headerlink" title="《your diary》"></a>《your diary》</h2><hr><p>所以说呢，作为大学四年最后一次国庆小长假，室友们好像也没有什么外出的安排（毕竟大二大三的时候，国庆节出去玩简直是累惨了，根本不是去看风景的，而是去看人海的吧！）好吧，我也没有什么安排，心已经沉下去了，正是整理自己足迹的时候了呢！</p><p>所以说呢，我就在自己的回忆里，抽出了《your diary》这个作品，其实我玩过的galgame不多，除了《clannad》外，其余都是被一个大佬推荐后才去玩的，所有玩的galgame可以用一个手的手指数清楚。</p><p>《your diary》是cube社的一个甜作，甜度确实可以，剧情也是蛮不错的，至少可以上台面的那种。<br>当初选的由亚线，也是被由亚的那种性格(活泼，开朗，外表小清新，声线少女)所吸引了吧。当时的自己感觉还比较雀跃的那种，自然而然是对个性开朗，活波的女孩子比较有感觉吧。当时走入由亚线后，剧情也没有令我失望，虽然最后让由亚和男主又重新团圆的设定不是很完美，不过也算是给了一个happyend（网上很多人觉得如果由亚和男主彻底分开的结局更神，不过我感觉如果真那样了，又有一批人要致郁了吧）</p><p>重新打开游戏后，一开始是想着重新重温由亚线的，重温与由亚的邂逅，让自己可以再次感受下她的温暖，勇敢面对自己的下一个阶段生活，重温下那甜甜的声音（cv满分，把握很好）剧情并不像《clannad》那么有深度，因为我不想把自己再搞的那么致郁，只是想着最后享受一次galgame的温暖，为我自己的galgame日记划上一个比较完美的句号（此处是我为自己设的flag也说不定）</p><p>令我自己惊讶的是，由亚还是当时的由亚，而我玩着玩着，却走到了学姐线里去了（与由亚完全不同的女性，话少，沉稳，端庄，黑长直，御姐音：发声位置靠后且低，头腔共鸣和胸腔配合共鸣为主，声音稳重、成熟，但很有魅力）</p><p>原来我已经开始憧憬起学姐这样的女性了吗？果然随着年龄的增长，心境自然而然的就发生了变化了呢。<br>和声音稳重、成熟的女性聊天我会更有想深聊的想法，就如同红酒一样，可以慢慢品慢慢尝。</p><hr><p>起初，我注意到学姐的时候，是剧情发展到由亚与学姐初次见面的时候，当时由亚应该是第一次与学姐见面的，但是我发现学姐的神情却不像是第一次与由亚见面。这就奇怪了，勾起了我想深究的欲望，等回过神来的时候，已经发现所有的分支选项我都选择了走入学姐线的选项。</p><p>在真正进入学姐线之前，有一个小场景是比较触动我的心的。</p><p>男主是图书馆副委员长，而学姐其实是图书馆委员长。有一次偶尔男主发现学姐在资料室的座位上靠着桌子睡着的时候，便拿自己的外套为学姐披上，防止学姐着凉。</p><p>随后学姐在当晚居然亲自上门来还外套这个事件比较关键。因为，一般来讲外套其实可以在次日上学的时候顺路还给男主然后道谢就行了。但是当时学姐并没有这么做，而是选择当晚就来还外套。</p><p>学姐自己陈述的原因是“外套里有你的学生手册”。学姐觉得，学生手册应该第一时间归还才行，因为如果老师在次日上学后要求检查学生手册的话，男主可能会遇到很多不必要的麻烦（其实一开始学姐的理由只是说，男主自己没有外套穿，第二天去上学也许会着凉，但是男主觉得这个理由还不足以学姐大晚上了还上门还外套的理由，学姐才说出了学生手册的原因，说实话，着凉的这个理由更能收拢男人的心啊）</p><p>接下来用文字的形式重现下这个场景：</p><blockquote><p>学姐：“早上还是很冷的”</p></blockquote><blockquote><p>男主：“走着走着，就会暖起来的”</p></blockquote><blockquote><p>学姐：“可是，穿这么薄的话…”</p></blockquote><blockquote><p>男主：“那么跑步就行了”</p></blockquote><blockquote><p>学姐：“出了汗的话，会着凉感冒的”（认真脸）</p></blockquote><blockquote><p>男主：“那我到时候换体育服咯”（体育服这装备那么强！？）</p></blockquote><blockquote><p>学姐：“那么，如果长峰同学被老师叫住，训斥的话…”（长峰是男主的姓，学姐没有直呼其名，也说明了两人关系还不够密切，也说明了虽然当了很久的副委员长，可是男主也没有和学姐走得很近这一点。同时也说明了学姐这个人人物的性格吧，难以接近？）</p></blockquote><blockquote><p>男主：“谁会训斥我啊，不过是没穿外套而已”（就是就是，学姐是不是想多了，我当时是这么想的）</p></blockquote><blockquote><p>学姐：“也许会被生活指导老师警告的”（日本学校的生活指导老师的威严还是很强的）</p></blockquote><blockquote><p>男主：“只要说忘记在教室之类的，就能应付过去了”</p></blockquote><blockquote><p>学姐：“但是如果还被要求拿出学生手册的话”（学姐的表情开始转变成略带沮丧的感觉）</p></blockquote><blockquote><p>男主：“这样的话，就会老老实实交出来的啊”（然后发现学生手册不在身上，哈哈）</p></blockquote><blockquote><p>学姐：“长峰同学的学生手册…在我这里噢？”</p></blockquote><blockquote><p>男主：“呃？”（男主诧异）</p></blockquote><blockquote><p>学姐：“在外套里，口袋里面…”（这句话有点意味，首先一般来说不会随便翻别人的衣服的吧？！然而学姐居然翻看了…如果说不是学姐的个人习惯的话，那么只能用学姐对男主也有一点在意这个理由来解释了）</p></blockquote><blockquote><p>男主：“…啊！”</p></blockquote><blockquote><p>学姐：“我以为你知道这个手册在哪里，但是为了确认一下，就…”</p></blockquote><blockquote><p>男主接过外套后说：“的确…是在这里呢”</p></blockquote><blockquote><p>学姐：“有其他丢了的东西吗”（这句话可以看出，学姐的心真的非常细腻啊，是我的话，还了就还了，怎么还会问这些有的没的。。。）</p></blockquote><p>学姐在这个小场景里表现是很有前辈范的，稳重，成熟，细腻的感觉透露的凌厉精致。考虑周全，思维缜密，语气稳重成熟的孩子是目前的我最喜欢的了，这也是让我决定走入学姐线的一个比较重大的原因。其实不管是学姐的第一个表面原因还是第二个的深层原因，都让我感受到人心的温暖。我在想现实生活中一定无时无刻不再发生这样的事情吧。只不过有些人不擅长把握吧。</p><hr><p>随后，顺利的靠攻略的力量，走入了学姐线后，不得不提的第二件比较触动我心的事件发生了。</p><p>但是在说明这个事件之前，有一个设定还是要说明一下的：</p><blockquote><p>由亚是给人带来幸福的神明，由亚只会出现在需要幸福的人的身边，故事的开头便是由亚突然降临至男主身边，励志要为男主带来幸福。但其实男主并不是由亚服务的第一个人类，由亚服务的第一个人类，是学姐</p></blockquote><p>所以问题就那么来了，既然由亚服务的第一个人类是学姐，那么由亚有带给学姐幸福了。照着现状来看，是没有的。（这也是为什么之前男主向学姐介绍由亚的时候会有那个奇怪的反应了）</p><p>学姐知道由亚，学姐也说过交上一个可以扯一辈子的朋友，是学姐的幸福。</p><p>但是不巧的便是，随着由亚陪伴在学姐的时光增加，学姐渐渐的将由亚放在了自己心中最高的位置，有由亚在身边就是学姐最高的幸福</p><p>但是有一天由亚突然从学姐身边消失了，为什么？</p><p>因为由亚发现，学姐所想要的幸福，居然是和自己一直生活下去</p><p>但是这对于一个神明来说，是不可能的，由亚有由亚的使命，总有一天当学姐实现愿望的时候，由亚就必须离开了。</p><p>所以说，学姐在由亚消失后的日子了，一直是非常难受的，以为自己被由亚抛弃，以为自己被幸福之神抛弃，以为自己是一个不幸的人。从此不愿意和人有过多的接触。（成为图书委员长的原因也许就是这个）</p><p>但是其实呢？由亚并没有真的离开学姐的身边，她只是将自己的形态隐藏了起来，然后一直默默的在学姐的身边守护了一年。每天都尝试着去说服学姐身边的同龄人，让他们和学姐友好相处，和学姐做做朋友。<br>由亚只是觉得，不让学姐找到别的朋友，一直拘泥于自己，是永远得不到幸福的，因为由亚知道自己总有一天会离开学姐的。</p><p>差不多就是这些原因，才导致了现在的学姐，一直认为自己是不幸的。学姐一直担心的事情便是，很少有永恒的友情，永恒的爱情。证据就是她自己的经历，友情方面便是由亚的离开，爱情方面便是自己父母的离婚。</p><p>是的。确实拿着这两个强力的证据来推翻友情和爱情，是轻而易举的事情。</p><p>对于友情，虽然我们全然不知自己和朋友们将来会怎么样，会不会因为一些事情而分离（比如毕业，就业），但是我想每个人应该都是想一只做朋友下去的，一直陪伴在朋友的身边。没有人会觉得分离是件好的事情。不过，总而言之生活不会如你所愿，分离在所难免。</p><p>而学姐就是被这个“分离”所束缚了，当时由亚的突然离开，让她不敢和男主展开进一步的交往，怕男主也会在有一天离开自己。关于这段的学姐的怕，怕，怕，可以从下面学姐向男主袒露心声的对话中看出（即攻略成功的时候）</p><blockquote><p>学姐：“不会丢下我一个人不见吧？”</p></blockquote><blockquote><p>男主：“跟你约定”</p></blockquote><blockquote><p>学姐：“不会比我先死吧？”（难为男主了，这个真不好回答啊）</p></blockquote><blockquote><p>男主：“为了学姐，我以后会注意身体的”</p></blockquote><blockquote><p>学姐：“绝对。绝对哦？”</p></blockquote><p>学姐说自己的父母离婚的理由是因为工作一直不能在一起，所以男主说“那么只要我们以后工作在一起不就行了，一起开个咖啡店怎么样？”</p><p>呀，这个作为切入点，真的很不错。虽然我不是女生，不过我感觉我都要被男主的措辞感动了。</p><hr><p>最后一个事件，我也想提一下。</p><p>学姐在确定了与男主一起携手未来后，老师们开始埋怨起学姐了。</p><p>学姐是一个超级优等生，一直是各种第一第一第一，而男主是那种成绩不怎么起眼的小角色，所以关于学姐在高三之际还进行恋爱什么的，可能会影响学业人生之类的话题</p><p>当时学姐与老师争论人生未来的时候，说的理由实在是太油说服力了。加上学姐的cv强有力的配音，感觉学姐整个人的形象油然而生，不愧是学姐。我打心里佩服。。。。。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>呼，总算是对自己的galgame经历有了一篇小小的交代总结。</p><p>虽然感觉自己没写好，没有写出自己想表达的内容。</p><p>不过，就这样吧。有这么一篇文章后，以后自己拿出来就有东西看了。我为自己的galgame日记划下一个句点，这是第一次，也是最后一次对自己体验过的galgame进行大篇幅的评价，说出来感觉心情舒畅呢～<br>嘛，小长假过去了，又要开始好好工作学习，也祝自己能够顺顺利利吧，也恭祝日本的galgame越做越好！希望国人可以更加关注下正版，自己喜欢的东西一定要给点钱买个正版支持一下哦</p><img src="http://i67.tinypic.com/2wciah2.png">]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回忆向 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学的日子(一)</title>
      <link href="/2019/04/24/%E5%A4%A7%E5%AD%A6%E7%9A%84%E6%97%A5%E5%AD%90-%E4%B8%80/"/>
      <url>/2019/04/24/%E5%A4%A7%E5%AD%A6%E7%9A%84%E6%97%A5%E5%AD%90-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<img src="http://i63.tinypic.com/2a8p10o.jpg"><p>这是一篇回忆自己大学时光的文章</p><blockquote><p>比起不做而后悔，不如做了再后悔。<br>                                   ——空白《游戏人生》</p></blockquote><p>不得不说，电子游戏是我大学人生中占比重比较大的一部分内容，所以我想先拿一些值得写的，自认为比较有营养的游戏。</p><p>高强度的高三结束后，顺利的来到了西电。心里当时确实是充满了对未来的幻想，想做这个，想干那么，心里想做的事真的很多很多～（标准结局：到现在有好多都没有完成～笑）</p><p>和高中不一样，大一的自主时间很多，在认认真真完成了上课，作业，报告等任务后，可以剩下很多时间自由安排。自然而然，我想好好的享受一下游戏（毕竟高中三年都没能好好玩）</p><img src="https://pbs.twimg.com/profile_images/692932156826451969/gNsHJSuZ.jpg"><h2 id="LOL"><a href="#LOL" class="headerlink" title="LOL"></a>LOL</h2><blockquote><p>那天的团灭，依然记忆犹新</p></blockquote><p>Dota，LOL，可以说它们展开了电子竞技的辉煌舞台。对一个职业的电子竞技选手，综合素质可以说是要非常强的。</p><p>我觉得这类游戏，可以锻炼一个人的以下能力：</p><ul><li>全局观念</li><li>抗压能力</li><li>团队能力（领导）</li></ul><p>对全局的掌控，是这类游戏上手的玩家应该做的第一门功课。什么时候，应该干什么。具备这一点，才能让胜利离你更近一步。毕竟这游戏的胜利方式不是取决于杀死敌对玩家操作的人物，而是拆除敌方核心建筑物取胜。如果对全局的掌控好的话，取胜的方法是有很多的，就算你们处于劣势也没关系，重点在于调配全局的动向。</p><p>在电子竞技的正式比赛上，观赛人数是不输于别的竞技类节目的。这也就让参赛选手更加想赢得比赛的胜利，向世界证明自己的实力。但是期望越大，在面临我方劣势的时候，压力也就会越大。这就是我所说的抗压能力的体现。如果在这场比赛中，你的抗压能力更好，那么很有可能你会获得最后的胜利。</p><p>最后想说的是团队能力。有一句话说得好 “这是五个人的舞台，而不是让你一枝独秀的地方”<br>是的，团队在这个游戏的份量是很大的。一般来说，五个人中会分配一个统帅全队的玩家，而到底是哪个玩家来统帅其余4个玩家，带领全队走向胜利，那么这是要由很多方面说明的，简单来说，你展示的足够优秀，那么其余的人自然会跟上你的节奏，顺从你的引导。而当我方和敌方集体交战的时候，就是所谓的”团战”。团战爆发的时候，各司其职是很重要的，中间如果出错一环，都有可能失败，让战局逆转。而如何在团战中站稳自己的位置，要说的就更多了，这里就简单的说一句，相信自己的队友！</p><p>LOL在大一还是玩的比较多的一款游戏，觉得是一款精良的游戏。要说还可以持续多久，我觉得这游戏再活5，6年应该是可以的，也许甚至更多</p><hr><h2 id="ElsWorld"><a href="#ElsWorld" class="headerlink" title="ElsWorld"></a>ElsWorld</h2><img src="http://i68.tinypic.com/2l8uu4y.png"><blockquote><p>吾乃 艾拉 韩</p></blockquote><p>这款游戏就没有那么有名了，但是其实它在韩国还是很火的一款游戏。</p><p>接触这款游戏的初衷那自然就是被一个游戏人物的人设所吸引了（上图中的妹子）</p><p>个人爱好：<br>我在2D的建模方面都是比较挑剔的，只要是有关2D的游戏，扫一脸所有人物的建模，就可以让我对这个游戏产生了一个6成的评价。其次的4成在于声优的配音工作是否理解了人物本身的性格。</p><p>而其中的一个枪兵角色，艾拉 韩，不管是在人物建模还是声优配音方面，我都给100分的评价。</p><p>人物建模依旧是ElsWorld的人物建模的团队，在这里我向他们致敬，他们还是用心在不断的创造欣赏力极佳的人物（后来的新成员希尔与露也有一种匠心巨作的感觉）</p><p>声优方面，佐藤聪美为其配音的真可谓非常的到位！那声音入耳后就觉得，艾拉是一个比较坚强，好学，但是又有点冒失的孩子，再配上自认为完美的人物建模，和技能特效（艾拉的技能特效全部设定为晚秋的红黄色，所有技能的释放都会伴有秋叶的飘落，技能“飞燕”，更是把秋叶飘落特效放大到极致，词贫的我只能已“美”来形容了）</p><p>游戏体验：<br>选好了角色，那么后面的人物就是玩这款游戏了。</p><p>可以说，中国的游戏玩家素质还是非常令人失望的（苦笑），国服的ElsWorld环境并不是很好，玩的人也不多。</p><p>不过自从官方发布了一个HA技能演示视频后，在各大视频网站上转播，国内玩家到了最峰值，我也是在那段时间认识了很多和自己有一样爱好的小伙伴们（笑）</p><p>游戏主要就是打副本性质的游戏，同时也拥有玩家对战pk的功能。</p><p>ElsWorld的玩家对战是设计的很好的。玩过毒奶粉的对战后，我就感到ElsWorld设计者在设计对战规则的独到之处。不过对战的装备还是越厉害越好，所以这一点上依旧是一个大坑。不过好在玩家不多，随便带点装备，就可以去愉快的和别人对战了～。</p><p>游戏时间：从我转向Mac OSX之前都有间断的在玩，如果你和我差不多同龄，又喜欢二次，那么可以在课余时间尝试下这游戏呢。</p><hr><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>在用了Mac OSX后，基本不玩端游了，我对自己大学阶段有关游戏的介绍也就告一段落了～不过，还真是一份不错的回忆。</p><p>呼，时间也过去挺久了，今天就写到这里吧。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回忆向 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
