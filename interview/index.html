<!DOCTYPE html>
<html lang=en>
  <!-- 引入视差滚动css -->
  <!-- <link rel="stylesheet" href="/parallax/parallaxCss.css"> -->
  <head><meta name="generator" content="Hexo 3.9.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="银信科技面试题HR提前放出的题目 从项目开始到线上的流程  我就拿我黄河银行收单系统来举例说明, 当时项目一期刚好结束, 我过去接手开发时(已经提前熟悉了一遍项目一期的项目架构,代码以及系统负责的黄河银行业务内容),双方正准备筹划项目二期建设需求,黄河银行那边先给了我们一份项目二期建设的需求书, 随后我和另一名负责pos的app相关开发(c的)的同事(他全程参加了项目一期的开发,但是java那块的">
<meta property="og:type" content="website">
<meta property="og:title" content="interview">
<meta property="og:url" content="https://zazalu.space/interview/index.html">
<meta property="og:site_name" content="Zazalu&#39;s Blog">
<meta property="og:description" content="银信科技面试题HR提前放出的题目 从项目开始到线上的流程  我就拿我黄河银行收单系统来举例说明, 当时项目一期刚好结束, 我过去接手开发时(已经提前熟悉了一遍项目一期的项目架构,代码以及系统负责的黄河银行业务内容),双方正准备筹划项目二期建设需求,黄河银行那边先给了我们一份项目二期建设的需求书, 随后我和另一名负责pos的app相关开发(c的)的同事(他全程参加了项目一期的开发,但是java那块的">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-04-04T01:13:08.406Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="interview">
<meta name="twitter:description" content="银信科技面试题HR提前放出的题目 从项目开始到线上的流程  我就拿我黄河银行收单系统来举例说明, 当时项目一期刚好结束, 我过去接手开发时(已经提前熟悉了一遍项目一期的项目架构,代码以及系统负责的黄河银行业务内容),双方正准备筹划项目二期建设需求,黄河银行那边先给了我们一份项目二期建设的需求书, 随后我和另一名负责pos的app相关开发(c的)的同事(他全程参加了项目一期的开发,但是java那块的">
    
    
        
          
              <link rel="shortcut icon" href="https://he_jia_jun.gitee.io/zazalumonster.github.io//images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="https://he_jia_jun.gitee.io/zazalumonster.github.io//images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="https://he_jia_jun.gitee.io/zazalumonster.github.io//images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>interview</title>
    <!-- styles -->
    <link rel="stylesheet" href="https://he_jia_jun.gitee.io/zazalumonster.github.io/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="https://he_jia_jun.gitee.io/zazalumonster.github.io/css/rtl.css">
    
    <!-- rss -->
    
    
</head>


  <body class="max-width mx-auto px3 ltr">
    <!-- 添加视差滚动容器 -->
    <!-- <ul id="scene" class="scene unselectable" data-friction-x="0.1" data-friction-y="0.1" data-scalar-x="25" data-scalar-y="15" style="width: 100%; height: 769px; transform: translate3d(0px, 0px, 0px); transform-style: preserve-3d; backface-visibility: hidden;">
      <li class="layer" data-depth="0.00" style="position: relative; display: block; left: 0px; top: 0px; transform: translate3d(0px, 0px, 0px); transform-style: preserve-3d; backface-visibility: hidden;"></li>
      <li class="layer" data-depth="0.10" style="position: absolute; display: block; left: 0px; top: 0px; transform: translate3d(29.05px, 9.825px, 0px); transform-style: preserve-3d; backface-visibility: hidden;"><div class="background"></div></li>
      <li class="layer" data-depth="0.10" style="position: absolute; display: block; left: 0px; top: 0px; transform: translate3d(29.05px, 9.825px, 0px); transform-style: preserve-3d; backface-visibility: hidden;"><div class="light orange b phase-4"></div></li>
      <li class="layer" data-depth="0.10" style="position: absolute; display: block; left: 0px; top: 0px; transform: translate3d(29.05px, 9.825px, 0px); transform-style: preserve-3d; backface-visibility: hidden;"><div class="light purple c phase-5"></div></li>
      <li class="layer" data-depth="0.10" style="position: absolute; display: block; left: 0px; top: 0px; transform: translate3d(29.05px, 9.825px, 0px); transform-style: preserve-3d; backface-visibility: hidden;"><div class="light orange d phase-3"></div></li>
      <li class="layer" data-depth="0.15" style="position: absolute; display: block; left: 0px; top: 0px; transform: translate3d(43.575px, 14.7375px, 0px); transform-style: preserve-3d; backface-visibility: hidden;"></li>
      <li class="layer" data-depth="0.30" style="position: absolute; display: block; left: 0px; top: 0px; transform: translate3d(87.15px, 29.475px, 0px); transform-style: preserve-3d; backface-visibility: hidden;"></li>
      <li class="layer" data-depth="0.30" style="position: absolute; display: block; left: 0px; top: 0px; transform: translate3d(87.15px, 29.475px, 0px); transform-style: preserve-3d; backface-visibility: hidden;"><div class=""></div></li>
      <li class="layer" data-depth="0.40" style="position: absolute; display: block; left: 0px; top: 0px; transform: translate3d(116.2px, 39.3px, 0px); transform-style: preserve-3d; backface-visibility: hidden;"><div class=""></div></li>
      <li class="layer" data-depth="0.50" style="position: absolute; display: block; left: 0px; top: 0px; transform: translate3d(145.25px, 49.125px, 0px); transform-style: preserve-3d; backface-visibility: hidden;"><div class=""></div></li>
      <li class="layer" data-depth="0.60" style="position: absolute; display: block; left: 0px; top: 0px; transform: translate3d(174.3px, 58.95px, 0px); transform-style: preserve-3d; backface-visibility: hidden;"><div class="lighthouse depth-60"></div></li>
      <li class="layer" data-depth="0.60" style="position: absolute; display: block; left: 0px; top: 0px; transform: translate3d(174.3px, 58.95px, 0px); transform-style: preserve-3d; backface-visibility: hidden;"></li>
      <li class="layer" data-depth="0.60" style="position: absolute; display: block; left: 0px; top: 0px; transform: translate3d(174.3px, 58.95px, 0px); transform-style: preserve-3d; backface-visibility: hidden;"><div class=""></div></li>
      <li class="layer" data-depth="0.80" style="position: absolute; display: block; left: 0px; top: 0px; transform: translate3d(232.4px, 78.6px, 0px); transform-style: preserve-3d; backface-visibility: hidden;"><div class=""></div></li>
      <li class="layer" data-depth="1.00" style="position: absolute; display: block; left: 0px; top: 0px; transform: translate3d(290.5px, 98.25px, 0px); transform-style: preserve-3d; backface-visibility: hidden;"><div class=""></div></li>
  </ul> -->
    
    <div class="content index py4">
      
      <header id="header">
  <a href="/">
  
    
      <div id="logo" style="background-image: url(https://he_jia_jun.gitee.io/zazalumonster.github.io//images/logo.png);"></div>
    
  
    <div id="title">
      <h1>Zazalu&#39;s Blog</h1>
    </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#"><i class="fas fa-bars fa-2x"></i></a>
      </li>
       
        <li><a href="/">主页</a></li>
       
        <li><a href="/about/">我是谁</a></li>
       
        <li><a href="/archives/">随笔</a></li>
       
        <li><a href="/tags/">标签</a></li>
       
        <li><a href="/categories/">分类</a></li>
       
        <li><a href="/search/">搜索</a></li>
      
    </ul>
  </div>
</header>

      
      <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  

  <div class="content" itemprop="articleBody">
      
          <h1 id="银信科技面试题"><a href="#银信科技面试题" class="headerlink" title="银信科技面试题"></a>银信科技面试题</h1><h2 id="HR提前放出的题目"><a href="#HR提前放出的题目" class="headerlink" title="HR提前放出的题目"></a>HR提前放出的题目</h2><ol>
<li>从项目开始到线上的流程</li>
</ol>
<p>我就拿我黄河银行收单系统来举例说明, 当时项目一期刚好结束, 我过去接手开发时(已经提前熟悉了一遍项目一期的项目架构,代码以及系统负责的黄河银行业务内容),双方正准备筹划项目二期建设需求,黄河银行那边先给了我们一份项目二期建设的需求书, 随后我和另一名负责pos的app相关开发(c的)的同事(他全程参加了项目一期的开发,但是java那块的负责人在一期结束后离职,他对java后台不太熟悉), 我们两人外加上部门负责的领导, 进行了几次开会, 其中涉及java后台的改动和新功能的开发, 我对需求进行了评测,从现有系统架构以及现有代码出发, 评估了下工时, 并说了一些自己的看法, 领导听取了一些意见, 最后与银行方一起开会把需求定版. 随后就是分模块开发, 二期开发过程中, 公司也多派了几位开发人员,协助完成了整体开发工作. </p>
<p>由于项目还包括ios和app,所以开发期间也少不了和移动端开发人员进行沟通,为他们编写后台接口文档</p>
<p>整体开发的差不多后, 将测试环境部署起来(由于一期构建好了一个完整的测试环境, 我做的只是将新版本导包部署), 银行测试人员开始进行业务测试, 银行技术人员开始查阅源代码以及做压力测试等技术性高的测试. 测试过程中银行方会发现需求业务存在问题(我按照需求做了), 要求我改逻辑. 一开始我由于缺乏行业经验, 同时觉得难度不大,就加班加点帮忙改了. 随后银行方要求改的越来越多, 脱离需求书过多, 我便提出要求银行方重新定制新的需求书, 并发版本备案, 走正式流程, 否则不能进行修改(前提是自己实现的功能和需求已经一致)</p>
<p>最后测试环境测试没问题后, 需要进行项目上线,, 上线前,我先编写了傻瓜式的上线步骤,每一步干什么都要写清楚. 然后召开一次上线评审. 评审没问题后就会上线, 当时上线时间是选择了晚上12点, 我10点左右陪同银行技术人员进入生产区, 然后银行技术人员根据上线步骤文档,一步步操作系统. 关闭系统-部署项目-重启服务-对重要业务进行立即在线测试, 这些全都没问题后便开始了真正的试运行阶段</p>
<p>试运行期间, 我常常跑生产区看日志(有些地方实现确实缺乏经验,包括日志打印这些), 在试运行阶段出现的问题, 会统一在一个时间点打补丁包进行更新(所谓的增量更新)</p>
<p>最终系统稳定后, 可能会继续做一些边缘的开发任务(公司项目组开发人员有限,其实后期就我一个java后台), 比如测试期间的一些页面觉得不好看的进行下一些优化, 银行部分机构撤并后, 系统需要进行下数据修改(写数据变动sql,系统不能停止运行), 符合最新的机构报表情况(因为会影响到资金清算入账,所以很重要)</p>
<ol start="2">
<li>mybatis的$和#</li>
</ol>
<p>比如 select name from user where ${column} = #{value},jdbcType=VARCHAR}(先暂且不谈sql注入啥的,我只是举个简单例子来说明) 首先它们都会被替换为mapper中传入的参数的具体值, 但是有个区别, #内的参数会被mybatis预处理, 有点类似jdbc的preparedStatement中的?, 就像我这个例子中的描写的一样,最终<code>value</code>参数会使用双引号来修饰,使得其在sql中表示为一个字符串. 而${column}它是不会进行预处理,或者说进行转义的, 它会直接将column参数包含的内容替换到这个sql语句中.</p>
<ol start="3">
<li>数据库的优化? 索引怎么创建?</li>
</ol>
<p>数据库优化如果指的是查询优化,那么我的个人经验总结如下(根据体系结构从上倒下来讲):</p>
<ul>
<li><p>作为数据库使用者,还非数据库开发者, 最显而易见的道理就是, 我查的少了速度肯定就快了. 在实际开发中, 我遇到不少抉择, 是再查一遍数据(只需增加少量代码), 还是修改多处java代码把数据重新传进来(需要改动很多地方,从开发者角度出发,产生了极度的抗拒心理). 我认为这也算是一种优化, 我应该恪守DRY原则, 不重复获取数据,并且争取在一次业务逻辑中就获取到所需的数据,不多查也不少查. 真正想去完成到这一点其实很难. 很多时候由于项目周期紧,所以很容易打破这个原则,采用比较暴力的方式去获取.</p>
</li>
<li><p>在sql层面上, 最重要的优化思路就是重构查询方式, 但是mysql不是静止不变的东西,所以不同版本,对于sql的重构方式也不经相同, sql解析器和查询优化器的行为不是我能掌控的, 因为我没看过源代码,也不是其开发人员. 幸运的是, 这个优化思路可以说是在长远来看不会变的, 针对不同的情况, 我们可以将我们的sql重构,来达到更快的效果, 比方说现在被大多数人所认同的 用JOIN替代子查询的方式就是一种优化思路. 子查询虽然更容易理解,但是在基准测试上会发现其性能不如JOIN的形式. 其他还有很多sql优化思路,比如切分查询,分解关联查询等等.</p>
</li>
<li><p>使用索引, 分表等等</p>
</li>
<li><p>理解数据库的内部机制,比如通信协议数据包定义是否还能继续优化,查询优化器怎么运作的, 如何配合他使得我的sql更加高效的运作, 或者说有能力的话对其进行改造,. 这一层次的优化思路对开发人员的要求特别高, 一般来说对于忙碌(菜)的应用开发人员来说是不太可能的. 或者说分配给数据库更多的可用内存空间等等</p>
</li>
<li><p>文件引擎层面, 我们的数据最终是需要存到存储器中的, 那么想加速, 提高硬盘IO速度也是很关键的一环, 最快的当然是直接跑在内存中.</p>
</li>
<li><p>建立数据库集群，实现读写分离，负载均衡，热备等，简单来说就是多个数据库共同完成一个工作，来减少单数据库的访问压力，从而提高查询速度</p>
</li>
</ul>
<p>索引如何创建?</p>
<p>CREATE INDEX indexName ON mytable(username(length));?</p>
<ol start="4">
<li>数据库的引擎? 以及区别</li>
</ol>
<p>首先说到数据库的引擎, 一般指的是Mysql的存储引擎, 而不是Oracle. 因为Mysql的体系结构中,从上到下大致分四层, 第一层就是我们应用开发人员一直接触的一层, 就是连接池组件, 第二层可以算是Mysql的控制层,里面包含sql分析,sql优化器,缓存组件等等, 这一层的任务不是查数据,而是处理应用开发人员的各类sql语句,并根据既定的优化方案去制定如何查询数据, 第三层便是Mysql的存储引擎, 由于Mysql制定了存储引擎规范, 所以我们可以自定义存储引擎的行为来得到我们需要的查询效果(本人并没有自定义存储引擎的任何经验),所以世界各地不同地方的编程大牛或者公司都开发了自己的存储引擎, 最著名的应该就是InnoDB, MyISAM以及Memory引擎(拿出来作对比,因为其数据都存在内存中,和别的存储引擎区别明显). 第四层是就是文件引擎了,真正持久化数据的地方.</p>
<p>而Oracle的体系结构没有这个特点,所以没有引擎这种说法, 但是其内部的数据存储机制,换句话来说其实也是一种”引擎”</p>
<p>Mysql引擎的区别我觉得总结起来有几点核心的技术点:</p>
<ul>
<li><p>如何存储数据? 是存储在文件硬盘中还是存储在内存中,或者存储在其他存储器上. 比如InnoDB和Memory的区别, Memory的数据都是存储在内存中, 好处显而易见,内存中操作数据的速度是最快的</p>
</li>
<li><p>是否支持事务? 我们知道事务的好处是, 万一中间的某个sql执行失败, 就全部失败, 不会影响数据库已有数据. 当我在进行数据迁移的时候, 对事务的距离是最近的, 编写数据迁移脚本的时候, 我个人水平有限, 没法一口气写出毫无错误的代码, 所以使用事务已经是一个必须品了(不过也要注意DDL和DML, 当使用DDL语句,比如CREATE,DROP,ALTER的时候,由于表本身结构要变动,所以变动前会隐式提交事务, 这一点一定要非常注意,我以前在数据迁移的时候遇到过这个问题,导致了严重后果,花费了更多的时间去修复). InnoDB就是支持事务的一个存储引擎, 而MyISAM则不支持事务. 支持与不支持, 我觉得好与坏,一切都要根据实际. 因为事务逻辑, 必将导致InnoDB写更多的代码去实现事务, 这也就会降低InnoDB的执行效率,因为它要处理的事情变多了. 从这一点上也可以很好的解释为什么MyISAM的查询速度通常都比InnoDB表现要好</p>
</li>
<li><p>索引类型的区别,换句话说, 它们是如何想办法查数据的,数据的组织方式是怎么样的. InnoDB采用的是主键索引(也就是聚集索引)为主,非聚集索引为辅的模式, 我们可以抽象成, 它把所有数据构建成了一个B+树, 利用B+树的特点, 做到快速定位. 而MyISAM最大的特点也许就是全文索引了,同时它将数据和文件分开存储, 所以采用的是类似非聚集索引的机制(后者能不说则不说,毕竟我自己用的很少)</p>
</li>
</ul>
<p>又比如InnoDB支持外键约束, 而其他常见Mysql的存储引擎不支持</p>
<ol start="5">
<li>聚集索引和非聚集索引的区别?</li>
</ol>
<p>简单来说, 在Mysql中存在聚集索引这种说法, 聚集的意思其实就是, InnoDB它将数据和索引放在了一起,抽象成了一颗B+树, 叶节点上存放了所有的行数据, 所以叫聚集. </p>
<p>而非聚集的意思是, 数据和索引它是分开的. 比如InnoDB的普通索引(非主键索引)都是非聚集索引, 这些索引自身构成了一个B+树, 并且叶节点上存的是主键索引对应的值(理解为存的是一个指针,或者说引用). 拿到这个引用后,再去主键索引的那颗B+树上搜索到对应的行</p>
<ol start="6">
<li>怎么和第三方或APP交互?</li>
</ol>
<ul>
<li><p>交互的大前提是, 两台计算机必须可以进行网络互联, 简单来说就是可以进行TCP或者UDP连接(Socket则是这些连接协议的一个抽象层,方便开发人员使用的), 随后在TCP基础上,数据包内容按照HTTP协议规定的格式(目前使用最广的TCP/IP通信协议)进行传输数据. </p>
</li>
<li><p>我们的业务数据都是放在http请求的报文体中的, 目前来看json格式是最流行的一种方式, 因为应用层上有很多优秀的解析库支持, 且json数据易读, 方便沟通.</p>
</li>
<li><p>最终请求会根据url地址 被转发器代码分配到不同的业务逻辑代码中进行处理,并返回</p>
</li>
</ul>
<p>这样便完成了一次简单的第三方或者APP交互(也可以举支付宝对账文件的例子)</p>
<ol start="7">
<li>会单元测试吗?</li>
</ol>
<p>说实话, 我的单元测试的思维只停留下, 比如使用Junit 测试下我的一些我不太确定的函数是否运行正常,输出对不对,会不会报错等等. 或者使用框架的单元测试框架 比如Spirng-test对我刚开发的一个controller方法进行测试.</p>
<p>但是一些普通的 我感觉很自信的地方, 我都不会去写专门的单元测试代码. 毕竟写单元测试代码也是一种时间的开销, 如果原代码出现问题, 那么你还必须同时修改单元测试代码的逻辑. </p>
<p>所以对于这一块, 我仍然存在一定的迷惑, 不知道面试官可以说一点自己的见解</p>
<ol start="8">
<li>经常使用的集合?</li>
</ol>
<p>list有ArrayList,LinkedList, 简单通用性能中肯, 如果插入频繁,量大的话 我会用LinkedList,因为不需要做扩容. 如果读取操作比较多的话,会使用ArrayList, 总而言之要根据不同情况使用.</p>
<p>Set有HashSet,当我不希望有重复数据的时候使用,但是实际用的很少,因为重复数据基本不会出现在java业务层面上; TreeSet, 当我希望进行自动排序的时候会用.</p>
<p>Map有HashMap, 效率高, jdk8后碰撞几率低,真的碰撞了还会用红黑树来降低查询时间复杂度. 如果存在并发操作map的场景的话, 会使用ConcurrentHashMap代替; TreeMap, 当我需要对key做排序的时候使用</p>
<p>CopyOnWriteArrayList 没用过,但是CopyOnWrite是个很不错的编程思想</p>
<p>若需要考虑线程安全, 则都会对应使用相关的线程安全实现类, 或者使用同步转换方法</p>
<ol start="9">
<li>用到SpringCloud的哪些组件?</li>
</ol>
<p>没用过SpringCloud</p>
<ol start="10">
<li>用的什么开发工具?</li>
</ol>
<p>个人毕业开始就一直用的InteliJ idea, 用它的好处是, 总是能第一时间支持框架的最新功能, 界面风格更喜欢</p>
<p>大学期间用的是Eclipse</p>
<p>代码编辑器一直再用Vscode, 有良好的插件社区, 能当半个IDE使用</p>
<ol start="11">
<li>有用到定时器吗?</li>
</ol>
<p>有, 但是不知道您问这个问题具体含义是什么呢? 目前来看我使用定时器并没有踩到过什么坑, 他们都很好的在工作</p>
<ol start="12">
<li>redis主要场景使用?</li>
</ol>
<ul>
<li><p>做缓存, 因为全是内存操作,读写性能优异, 且支持过期时间设置</p>
</li>
<li><p>redis不同于Ehcache Memchache 它有多种存储数据结构,而不是单一的String, redis支持使用存储list,而且可以从前后端进行操作, 可以用于实现消息队列. 又比如有序set, 可以用于实现一些排行榜热度榜功能; </p>
</li>
<li><p>redis的部分指令是原子性的, <code>incr</code>, 这样就可以用于做一些简单的计数器功能, 比如浏览数, 播放量等等</p>
</li>
</ul>
<h2 id="面试当天流程记录"><a href="#面试当天流程记录" class="headerlink" title="面试当天流程记录"></a>面试当天流程记录</h2><p>发我的面试邮件突然说地址错了,更改地址, 所以我判断这肯定有点猫腻, 有可能存在邮件造假风险</p>
<p>说好的两点钟, 结果居然没有提前,反而是延迟了9分钟才下来..</p>
<p>ok, 人下来了, 准备进行第一场社交面试,管他是黑是白, 反正我就是个半斤八两但是愿意干活的人</p>
<p>待会不要紧张, 不要以为面试官有多厉害, 回答好自己知道的就行了, 同时也不要关心自己说的语气啥的, 慢慢说就行了</p>
<p>面试官一开始有两个, 但是面着面着有一个出去了. </p>
<p>面试问的问题还算可以, 但是有些东西我确实没答上来(感觉面试前HR给的题目我回答的都特别棒, 但是没给的题目我就回答的不是特别好了)</p>
<p>我回答的特别不好的有: </p>
<ol>
<li><p>知道消息中间件吗, 它有什么作用?</p>
</li>
<li><p>知道axios的底层是什么吗? 我说了ajax, 然后他说是promise. (<a href="https://segmentfault.com/a/1190000006708151" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006708151</a> + <a href="https://www.jianshu.com/p/c09916018f3d" target="_blank" rel="noopener">https://www.jianshu.com/p/c09916018f3d</a>)</p>
</li>
<li><p>vue里的三个点是什么 …(主要是写了ES6,结果导致他问了,结果我没复习好,加上本身用到es6的语法就很少)<br> <a href="https://forum.vuejs.org/t/vue-form/29440" target="_blank" rel="noopener">https://forum.vuejs.org/t/vue-form/29440</a></p>
</li>
<li><p>微服务,分布式,SpringCloud 这三个都问了, 我没接触过,所以都没回答</p>
</li>
<li><p>oracle三大范式(<a href="https://blog.csdn.net/Daniel_Chen_/article/details/53482663" target="_blank" rel="noopener">https://blog.csdn.net/Daniel_Chen_/article/details/53482663</a>)</p>
</li>
<li><p>springboot的properties文件或者yaml文件是怎么读取的(<a href="https://blog.csdn.net/jlh912008548/article/details/81437036" target="_blank" rel="noopener">https://blog.csdn.net/jlh912008548/article/details/81437036</a> + 建议自己读一下源码)</p>
</li>
</ol>
<p>最后面试官觉得我数据库这块说的还是蛮好的, 感觉面试官非常和蔼, 让我面试体验很棒, 虽然已经被筛掉, 但是整个面试过程对我来说获益匪浅</p>
<h2 id="SpringBoot是如何读取properties文件或者yaml文件的"><a href="#SpringBoot是如何读取properties文件或者yaml文件的" class="headerlink" title="SpringBoot是如何读取properties文件或者yaml文件的"></a>SpringBoot是如何读取properties文件或者yaml文件的</h2><p>SpringBoot启动时, 先创建SpringApplicationContext, SpringApplicationContext在初始化阶段, 会从spring.factorys文件中读取初始化器和监听器, 其中有一个ConfigFileListener, 当Enviromet类准备完毕后. 会调用ConfigFileListener的一个回调方法onApplicationEnvironmentPreparedEvent, 这个方法会去搜索默认位置下的配置文件内容以及profile的内容, 并将他们也加载到Environment中</p>
<p>Environment是SpringBoot存储运行时所有配置资源的地方, 后期SpringBoot获取properties文件或者yaml文件的配置,都是从这个类中读取的</p>
<h2 id="vue的promise"><a href="#vue的promise" class="headerlink" title="vue的promise"></a>vue的promise</h2><p><a href="https://segmentfault.com/a/1190000006708151" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006708151</a> + <a href="https://www.jianshu.com/p/c09916018f3d" target="_blank" rel="noopener">https://www.jianshu.com/p/c09916018f3d</a></p>
<p>总结来说:<br>当遇到多次回调的时候, js代码会变因不同开发人员的习惯, 写出不同的臃肿代码, 不美观且不宜读, 这种叫做回环金字塔或者回调地域问题. </p>
<p>而promise是es6标准的一部分, 它将异步回调进行的统一, 使得开发人员拥有了统一的编写异步回调的语法, 遵照promise可以让我们的异步编程代码更规范更合理</p>
<p>promise使用了三种状态pending, resolve, reject来统一管理回调执行时期, 同时使用then函数和catch函数分别处理正常回调和异常回调(then函数也可以处理异常,只不过为了更合理,写在catch函数中更好)</p>
<h1 id="仍需了解的知识"><a href="#仍需了解的知识" class="headerlink" title="仍需了解的知识"></a>仍需了解的知识</h1><p>消息中间件RabbitMQ, springcloud+dubbo, oracle或者mysql的存储过程,函数编写, db2数据库使用</p>
<p>zookeeper, kafka, webservice, lua, nginx, elasticsearch,</p>
<h1 id="浙江承志信科技有限公司面试流程"><a href="#浙江承志信科技有限公司面试流程" class="headerlink" title="浙江承志信科技有限公司面试流程"></a>浙江承志信科技有限公司面试流程</h1><p>面试官题目:</p>
<ol>
<li>抽象类和接口的区别</li>
</ol>
<p>抽象类通常作为一种骨架实现，为各自子类实现公共的方法, 包含了公共的基类行为, 减少了代码重复性, 提高了代码可重用</p>
<p>此外(我的个人见解), 抽象类的这种能力, 其实我们也完全可以使用一个非抽象类的父类去实现, 在父类中也可以为各自子类实现公共的方法. 但是这就好比正式与非正式的区别, 当你使用抽象类语法的时候, 其他开发人员可以一目了然的知道, 这个类包含了基类的公共方法, 为我们实现某个接口提供了一个骨架实现. 而如果你写的是一个普通的方法, 你可能还需要写注释去解释类的行为目的.</p>
<p>接口是一种行为约束, 一种规范, 使得声明和实现解耦 , 提高了代码灵活性, 比如jdbc是java官方提出的接口, 随后不同的数据库厂商对其进行了实现, 当想换另一个数据库的时候, 不需要修改大部分代码(因为它们和实现是解耦的), 只需要修改使用的实现类即可</p>
<p>接口类体现了自然界“如果你是……则必须能……”的理念</p>
<p>我认为，抽象类和接口的区别在于使用动机。</p>
<p>使用抽象类是为了代码的复用，是具体开发后会考虑的事情<br>而使用接口的动机是为了实现多态性,声明和实现解耦,是具体开发之前做的事情, </p>
<p>接口就像领导分配职位和职位要求, 这样的话, 后续想要替换某个职位的人员, 就找相应职位的其他人员即可(解耦,组件化,多态)<br>而抽象类就像一个职位的一个代表, 当领导不知道如何具体讲述一个岗位该干什么的时候, 便挑一个代表出来, 告诉大家这个代表知道所有的基本工作内容, 大家可以学习借鉴(代码复用)以及创新(重写)</p>
<ol start="2">
<li><p>谈谈你熟悉的设计模式</p>
</li>
<li><p>对Spring的理解, IOC, AOP</p>
</li>
</ol>
<h1 id="久久基因"><a href="#久久基因" class="headerlink" title="久久基因"></a>久久基因</h1><ol>
<li><p>二分查找</p>
</li>
<li><p>实现String的indexOf</p>
</li>
<li><p>伪代码实现生产者/消费者模式</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者消费者伪代码</span></span><br><span class="line">Producer p;</span><br><span class="line">Consumer c;</span><br><span class="line">LinkedList buffer;</span><br><span class="line">Boolean door = <span class="keyword">true</span>;<span class="comment">//true = open , flase = close</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">produceItem</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(closeDoor())&#123;</span><br><span class="line">        <span class="keyword">if</span>(buffer.size &gt;= max)&#123;</span><br><span class="line">            sout(<span class="string">"is full, i can take a rest now"</span>);</span><br><span class="line">            openDoor();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            buffer.add(Item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        sout(<span class="string">"door is close, i am waiting"</span>); <span class="comment">// sout = System.out.println</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">comsumeItem</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(closeDoor())&#123;</span><br><span class="line">        <span class="keyword">if</span>(buffer.size != <span class="number">0</span>)&#123;</span><br><span class="line">            buffer.remove(Item);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sout(<span class="string">"nothing to do!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        openDoor();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        sout(<span class="string">"door is close, i am waiting"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">synchronized</span> <span class="title">closeDoor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(door)&#123;</span><br><span class="line">        door = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> door;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">openDoor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!door)&#123;</span><br><span class="line">        door = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="comment">//Thread A</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        produceItem();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Thread B</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        comsumeItem();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>单点登录</li>
</ol>
<ul>
<li>什么是单点登录</li>
</ul>
<p>单点登录(SSO, Single Sign on), SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p>
<ul>
<li>为什么要单点登录</li>
</ul>
<p>针对企业多套不同系统提供统一的登录方式, 提高用户的使用体验. 简单来说就是为了方便, 一把锁可以开同一个公司的多个门, 而不是每次开个门都要换一把锁</p>
<ul>
<li>如何实现单点登录</li>
</ul>
<p>同域:<br>如果你的所有域名地址都是同域的, 比如app1.a.com, app2.a.com, 那么可以使用cookie和session就能够实现单点登录<br>在不同的后台server中进行session的共享, 同时将sessionid存至顶级域cookie中, 比如存至a.com中(cookie的存取是按照域来划分的,它无法跨域获取,比如你如果是a.com的系统,是无法获取到baidu.com的cookie的). 这样如果你在app1.a.com中登录, 那么当你在app2.a.com中登录的时候,发现已存在cookie,所以就直接发送这个cookie内容给app2的后台, 而app2的后台从共享session中获取到了由app1存取的session, 于是验证成功,登录完成</p>
<p>不同域:<br>如果是不同域, 那么cookie就没法用了,因为cookie是无法跨域访问的, 这时候就必须使用另一种方式, token的方式.<br>专门分配一个sso服务用于登录, 比如sso.a.com, 当访问app1.a.com的时候, 会先跳转至sso.a.com进行登录, 要求输入用户名和密码,并返回一个唯一的token, app1拿到这个token后, 发送给后端sso进行验证, 验证无误后, 记录登录状态, 并成功登录. 随后访问app2的时候, 也是一样跳转到sso.a.com进行登录, 但由于之前已经登录过, 所以这次就直接返回token给app2, app2拿到后也进行一次验证, 无误后,直接登陆成功.</p>
<h1 id="鸿程系统"><a href="#鸿程系统" class="headerlink" title="鸿程系统"></a>鸿程系统</h1><ol>
<li><p>mysql分页<br><a href="https://zazalu.space/2019/08/28/mysql-pagination-optimization-1/">https://zazalu.space/2019/08/28/mysql-pagination-optimization-1/</a></p>
</li>
<li><p>mybatis的statement要素 </p>
</li>
</ol>
<p>比如<select> 我们最常见的属性有:</select></p>
<ul>
<li><p>id, 唯一的标识符，可以被用来引用这条语句。</p>
</li>
<li><p>parameterType, 指示传入参数的类型, 我自己最常用的是传入map,  这个参数可以不选, 因为mybais可以通过类型选择器(TypeHandle)进行判断</p>
</li>
<li><p>resultType 或者 resultMap, resultMap对应自己定义的<resultmap>我觉得适用了大部分情况, 也可以使用resultType, 对应指定相应的pojo类</resultmap></p>
</li>
<li><p>flushCache, 如果设置为true, 则会清除一级和二级缓存, 一个在特殊需求下会很好用的设置</p>
</li>
<li><p>useCache, 设置为false, 则会取消这个statement进行二级缓存, <select>是默认为true的</select></p>
</li>
<li><p>timeout, 超时时间</p>
</li>
</ul>
<ol start="3">
<li>vue的生命周期</li>
</ol>
<p>beforeCreate 和 created<br>在这俩个钩子函数执行的时候，并没有渲染 DOM，所以我们也不能够访问 DOM，一般来说，如果组件在加载的时候需要和后端有交互，放在这俩个钩子函数执行都可以，如果是需要访问 props、data、method 等数据的话，就需要使用 created 钩子函数</p>
<p>在 mounted 钩子函数中可以访问到 DOM</p>
<p>在 destroy 钩子函数中可以做一些定时器销毁工作，了解它们有利于我们在合适的生命周期去做不同的事情。</p>
<ol start="4">
<li>常用的io类</li>
</ol>
<ul>
<li>字节流 File(Buffered)Input(Output)Stream</li>
<li>字符流 BufferedWriter和BufferedReader, PrintWriter和PrintReader</li>
</ul>
<p>看下我写的Java基础.md中的I/O部分</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol>
<li>simpleDataFormat 高并发下存在问题</li>
</ol>
<p>由于SimpleDateFormat不是线程安全的, 导致多个线程使用同一个SimpleDateFormat实例的时候, 会因为状态变量共享导致异常报错</p>
<p>解决方法: 使用ThreadLocal包装,使得每个线程对应一个实例. 但是这样如果线程很多的情况下又会创建太多的SimpleDateFormat实例, 这时候你可以使用DateTimeFormatter, LocalDateTime(jdk8)去代替, 不过线程安全其实也就意味着要做控制,所以我认为性能可能会低于前者</p>
<ol start="2">
<li>常见的线程安全集合类</li>
</ol>
<p>Vector HashTable</p>
<p>ConcurrentXXX, CopyOnWriteXXX</p>
<ol start="3">
<li>正向和反向代理</li>
</ol>
<p>正向代理是内网需访问外网，由一个可以访问外网的代理服务器进行代理转发请求<br>反向代理是外网需访问内网，外网服务器访问代理服务器，由代理服务器转发请求</p>
<h1 id="非技术类问题"><a href="#非技术类问题" class="headerlink" title="非技术类问题"></a>非技术类问题</h1><ol>
<li>为什么离职</li>
</ol>
<ul>
<li>工作不在浙江,父母不愿意</li>
<li>出差过久</li>
<li>自己原因</li>
</ul>
<ol start="2">
<li>为什么那么久没有再工作</li>
</ol>
<ul>
<li>自己原因</li>
</ul>
<ol start="3">
<li>你觉得你的优点 你的核心竞争力是什么</li>
</ol>
<ul>
<li>处境不容乐观, 但是依旧开朗</li>
<li>前后端,测试,生产全都熟悉,会写数据接口, 会搞整一点系统架构, 有长期单人驻场开发经验, 有很好的沟通能力</li>
<li>深知自己以前的缺点, 不卑不亢, 踏实干事</li>
</ul>
<h1 id="面试自我介绍（浙商银行版）"><a href="#面试自我介绍（浙商银行版）" class="headerlink" title="面试自我介绍（浙商银行版）"></a>面试自我介绍（浙商银行版）</h1><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>我叫何镓钧，来自浙江绍兴，17年毕业于西安电子科技大学软件学院，今年8月以来就一直就职于赞同科技。</p>
<h2 id="聊聊黄河银行项目"><a href="#聊聊黄河银行项目" class="headerlink" title="聊聊黄河银行项目"></a>聊聊黄河银行项目</h2><p>（从项目的简单介绍说起）<br>我毕业后就一直从事银行相关业务系统的开发，比如我参与过黄河银行其一码付平台二期的开发，一码付平台是福建联迪（我当时就职的公司），为黄河银行提供的一套聚合支付交易平台，所谓的一码是指一个二维码就可以向客户提供各类第三方支付服务，比如支付宝，微信支付，银闪付等等。同时一码付平台还提供了面向行内用户的管理平台和面向商户的商户服务平台。</p>
<p>Version1.0<br>【我当时主要负责的功能模块有，比如行内员工管理，商户管理，机构管理，码牌管理，移动端APP数据接口，以及涉及资金的交易流水对账清算入账功能。 同时我作为驻场开发人员，我还负责部署开发和测试环境，配合银行测试人员测试；负责与银行经理对接项目需求，参与各种与需求相关的会议，并代表公司发表意见；对接银行新核心接口并做联调测试；编写项目相关开发文档等等。】</p>
<p>Version2.0<br>【我主要负责面向行内员工的管理平台开发，比如行内员工管理，商户管理，多级审核以及资金的对账清算入账功能；同时也作为驻场开发人员负责对接银行测试人员和负责与银行核心接口进行联调测试等。】</p>
<p>我觉得从我的经历来看，我对自己的沟通能力，协调能力以及严谨的软件开发能力有一定的信心，我非常希望可以为浙商银行贡献自己的一份力，并努力实现自己的自我价值！谢谢</p>
<p>—-如果时间来得及继续讲下面的—-</p>
<p>（主要是为了体现我自己对于业务学习能力，以及十分看重业务的态度）<br>先拿商户管理为例，它听上去感觉很简单， 但其实在商户开立的过程中，需要涉及第三方支付的商户开立，银行本身的内部账户开立，商户银行账户查询验证，同时还要提供多级审核(授权)机制，每个功能的完成都必须对业务有非常清醒的认知。 类推到我们柜面系统开发上来看，柜面系统涉及的业务量也是非常多的，只有熟悉了业务的程序员才能开发出银行需要的优秀交易，才能胜任并满足项目的长期发展。而我毕业后就一直从事银行开发工作，虽说之前的属于边缘子系统，不太涉及银行核心业务，但是对银行业务的学习能力充满信心。</p>
<p>行内员工管理主要任务是新增行内员工以及修改行内员工的基本信息和职级，</p>
<p>（目的是表现我开发上的严谨性）<br>再说下交易流水的对账清算入账功能，</p>
<p>对账：通过定时任务，每天10点都会根据第三方支付特有的银行商户号从第三方支付那里获取对账文件，内含第三方交易流水记录，根据银行交易流水号来一一比对对账文件内的交易流水和平台交易流水的交易状态，交易金额，手续费是否一致。若都一致则标记为对账成功否则失败。</p>
<p>清算：将对账成功的交易流水，根据银行需求里提出的手续费规则（银行手续费，机构手续费，第三方手续费，是否手续费返还，是否手续费优惠等），计算每笔交易的手续费，并记录入表，并标记为已清算</p>
<p>入账：根据日期取出已清算的交易流水，按照规定转账路线，调用核心入账接口（比如先转入内部账再转到商户账），完成对商户T+1的打款</p>
<p>差错处理这一块也要讲。对账的差错处理，由人工审核，无误后重新进行对账清算流程。</p>
<p>全部采用了Java的BigDecimal完成了所有涉及金额的操作，并且按照int类型存储至单位分，保证了资金计算无误</p>
<h3 id="如何与银行核心系统互通互调的？"><a href="#如何与银行核心系统互通互调的？" class="headerlink" title="如何与银行核心系统互通互调的？"></a>如何与银行核心系统互通互调的？</h3><p>http，具体来说借助http工具类(当时公司内部对socket的封装类)，根据接口文档的规定，发送http报文，并接受返回报文，根据返回报文头携带的核心状态码，展开后续的操作</p>
<p>说到HTTP, 这里就涉及了TCP连接的概念(HTTP的实现不是非使用TCP传输协议不可, 但是一般都是使用TCP, 从默认端口80就可以知道这点). TCP是一种可靠的字节流服务. 为了规范连接以及统一分层, 我们都使用Socket来进行TCP连接. TCP是全双工的, 字节数据可以双向传输. TCP属于</p>
<p>TCP是如何保证可靠的?<br><code>数据完整性校验机制</code>,<code>分组丢失重传机制</code>,<code>滑动窗口提高信道吞吐量</code></p>
<p>TCP连接最常问的两个东西:<br>三次握手(用于建立连接)和四次挥手(用于拆除连接)</p>
<p>TCP三次握手:</p>
<ol>
<li>客户端发送SYN包(SYN=1,seq=x),进入SYN SEND状态</li>
<li>服务端接收到SYN包, 向客户端回复SYNACK包(SYN=1,ACK=1,seq=y,ack_seq=x+1),从LISTEN状态进入SYN RCVD状态</li>
<li>客户端接收到SYNACK包后, 向服务端回复ACK包(SYN=1,seq=x,ack_seq=y+1), 客户端进入ESTABLISHED状态.服务端接收到这个ACK包后也进入ESTABLISHED状态,.至此, 双方连接建立完毕</li>
</ol>
<p>TCP四次挥手:</p>
<ol>
<li>客户端发送FIN段, 要求断开连接, 状态进入到FIN_WAIT_1, 这个状态下客户端不会再发送新的数据包</li>
<li>服务端应答这个FIN段, 并返回一个ACK段, 状态进入到CLOSE_WAIT, 这个状态下的意思是服务端会继续发送剩余未发送的数据包, 但是不会再接收新的数据包.客户端接收到ACK段后, 状态进入到FIN_WAIT_2</li>
<li>服务端发送完剩余数据包后, 会向客户端也发送一个FIN段,状态进入到LAST_ACK, 这个状态的命名含义是服务端只接受客户端最后一次的ACK段.</li>
<li>客户端接收到服务端的FIN包后,返回ACK段, 状态进入到TIME_WAIT, 等待2MSL后进入CLOSED状态. 服务端接收到最后的ACK包后进入到CLOSED状态.至此TCP连接就会结束</li>
</ol>
<h3 id="常用的Linux-Shell指令"><a href="#常用的Linux-Shell指令" class="headerlink" title="常用的Linux Shell指令"></a>常用的Linux Shell指令</h3><p>man,cd,ls,mkdir,rm,ps,grep,vim,top,mv,echo,whichis,$(),|,cat,tail,</p>
<h3 id="Maven（重要性不高，先往后推）"><a href="#Maven（重要性不高，先往后推）" class="headerlink" title="Maven（重要性不高，先往后推）"></a>Maven（重要性不高，先往后推）</h3><h3 id="Oracle："><a href="#Oracle：" class="headerlink" title="Oracle："></a>Oracle：</h3><ol>
<li>如何搭建，先安装服务端，再安装客户端，按照网上的静默化安装流程进行安装，一些关键点：<ul>
<li>使用单独的oracle用户进行安装，而不是使用root用户安装</li>
<li>其中可能会出现一些依赖错误，根据提示使用yum安装对应软件包</li>
</ul>
</li>
<li><p>使用上oracle特有的东西：</p>
<ul>
<li><p>主键自增，使用序列，每次插入的时候显示调用(使用nextval)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--插入数据 </span><br><span class="line">insert into test values(seq_on_test.nextval,&apos;Mary&apos;,15); </span><br><span class="line">insert into test values(seq_on_test.nextval,&apos;Tom&apos;,16);</span><br></pre></td></tr></table></figure>
</li>
<li><p>序列，是oracle提供的一个产生唯一数值型值的机制</p>
<p>序列的创建方式，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE SEQUENCE 序列名</span><br><span class="line">[INCREMENT BY n]</span><br><span class="line">[START WITH n]</span><br><span class="line">[&#123;MAXVALUE/ MINVALUE n|NOMAXVALUE&#125;]</span><br><span class="line">[&#123;CYCLE|NOCYCLE&#125;]</span><br><span class="line">[&#123;CACHE n|NOCACHE&#125;];</span><br></pre></td></tr></table></figure>
</li>
<li><p>oracle分页<br>oracle每次结果集都会有ROWNUM来标明每行数据的位置，下面是推荐写法，这种写法不会因为rownum变大而不断变慢<br><code>select a.* from ( select t.*,rownum rowno from test t where rownum &lt;= 20 ) a where a.rowno &gt;= 11</code></p>
</li>
</ul>
</li>
<li><p>oracle索引:</p>
<p> 常用的还是B树索引(是否聚集不太清楚)<br> 基数少的时候使用位图索引, 为什么是基数少的时候？ 因为位图索引其实就是为每一行维护一个位图向量，使用1和0来<br> 确定这一行这一列的值是否等于某个值，这种机制适合基数少的情况，具体可以看看<a href="https://www.cnblogs.com/liuning8023/archive/2012/11/18/2776127.html，" target="_blank" rel="noopener">https://www.cnblogs.com/liuning8023/archive/2012/11/18/2776127.html，</a> 很快就能理解了。位图索引适合静态数据，而不适合索引频繁更新的列，因为它的建立机制是扫描整个表后得到的位图向量，所以当你频繁修改更新列的值，oracle需要对这个位图向量进行多次的更新操作，更新的时候使用行锁定，导致其他oracle操作无法正常进行会被堵塞，最终导致性能不佳</p>
</li>
<li><p>oracle存储过程:</p>
<p> 为什么需要存储过程？<br> 存储过程最大的特点是性能优异，毕竟它是预编译过的，<br> 存储过程看上去就像编写sql脚本，可以定义状态和行为，同时存储过程可以复用，这样就使得我们可以把业务逻辑从应用层移动到数据库层，并且享受存储过程的性能优势。但是大量的使用存储过程实现业务逻辑，则不利于数据库迁移，毕竟不同的数据库甚至不同的数据库版本，相同的plsql代码都不一定能正常执行。<br> 安全性。避免了sql注入，避免了暴露表结构和字段</p>
<p> 存储过程写法?</p>
</li>
<li><p>oracle视图：<br>我前一个项目没怎么用视图， 但是视图我觉得还是不错的，它是一种虚表，存储了select语句的结果。如果修改视图的记录会同步影响到基表上，这点自己注意下；删除视图不会影响基表</p>
</li>
</ol>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ol>
<li>为什么使用Redis？<ul>
<li>作为缓存中间件，减少数据库压力，提高热点数据的响应速度<br>Redis的读写性能优秀（官网10w）以致于Redis的瓶颈在于网络吞吐而不是本身的读写（每秒4w次读写，跑满100M带宽）</li>
<li>除了String以为拥有多种数据类型，为开发人员减负</li>
</ul>
</li>
<li>常见的数据类型：<ul>
<li>string，list，set，sorted set，hash<br>我只用过string，用过incr递增</li>
</ul>
</li>
</ol>
<h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><ol>
<li>之前项目主要用于反向代理，负载均衡没做，因为内网对应的是单机实例，但是仍然需要nginx做分发，因为有三个后台应用服务器，一台专门做清算的，一台专门为管理平台返回数据的，一台专门为商户服务平台返回数据的</li>
<li>nginx是优秀的http服务器，常用于做反向代理，官网测试可以达到5w并发</li>
</ol>
<p>多级审核如何实现的？<br>简单来说，多级审核是通过审核链信息表，里面记录了审核的分级流程，java程序借助该表信息从而判断下一级推送给谁进行审核。</p>
<p>这个功能属于后期新增的需求，而且要求多个审核模块都要加上这个功能，所以我使用了java的泛型来实现了这个需求，只需要继承相应的多级审核抽象类，就可以轻松的支持多级审核功能(数据库层需要在对应的表中新增3个字段)</p>
<p>在java中定义一个多级审核抽象类，内部定义了多级审核需要调用的公共方法，每次审核的时候加上对多级审核相关字段的检查(当前审核角色，下一个审核角色，审核链id))，需要新增一个审核链表，专门记录审核流程，比如商户审核必须先由支行行长审核再由总行管理员审核才算通过。</p>
<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><ol>
<li>Vue是使用Object.defineProperty()实现数据变化 -&gt; 视图更新， 给可输入控件添加DOM事件监听来实现视图更新 -&gt; 数据变化，从而整体上达到了双向绑定的效果</li>
<li>Vue使用了虚拟DOM，为什么？<br>优点：</li>
</ol>
<p><code>保证性能下限</code>： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多(每次暴力操作DOM都会引起页面重新渲染)，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；<br><code>无需手动操作 DOM</code>： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；<br><code>跨平台</code>： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</p>
<p>缺点:</p>
<p>无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</p>
<ol start="3">
<li>虚拟 DOM 的实现原理主要包括以下 3 部分：</li>
</ol>
<p>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；<br>diff 算法 — 比较两棵虚拟 DOM 树的差异；<br>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</p>
<h3 id="my-youdian"><a href="#my-youdian" class="headerlink" title="my youdian"></a>my youdian</h3><p>善于沟通，但是不胡乱发言，主动寻找问题关键点，不喜欢拖延。</p>
<p>严于律己，不骄不躁，踏踏实实做事。</p>
<p>善于总结归纳，有自己的博客经常做技术总结。</p>
<h3 id="对账？"><a href="#对账？" class="headerlink" title="对账？"></a>对账？</h3><p>平台流水与第三方支付流水进行比对记录成功流水交易</p>
<p>具体来讲，每天早上10点会向支付宝和微信发起对账文件下载请求，我们通过特约商户编号(1)(当然还有其他各类参数，密钥等)(2)，从其平台拉取对账文件，我方平台记录保存并与平台流水进行比对，主要比对金额和交易状态是否正常。</p>
<p>(1) 黄河银行就是支付宝的特约商户，特约商户编号就是这么来的<br>(2) 数字证书，保证来源安全可靠有效</p>
<h3 id="清算？"><a href="#清算？" class="headerlink" title="清算？"></a>清算？</h3><p>交易流水对平后，根据银行的手续费规则， 计算出相应的银行手续费，机构手续费和第三方手续费</p>
<p>(1) 流水较多时，使用分批处理的方式，比如一次处理500条数据，防止内存溢出</p>
<h3 id="入账T-1？"><a href="#入账T-1？" class="headerlink" title="入账T+1？"></a>入账T+1？</h3><p>T+1代表第二天入账</p>
<p>入账前先要从清算表中获取需要入账的交易流水，然后记录每笔交易转至对应内部户的金额，转至客户账户的金额等等金额，这些金额记录可能存在重复，但是一切都是为了银行人员查看和排查方便。</p>
<p>入账分机构入账和商户入账，分别将机构手续费和商户应得的费调用核心转账接口进行入账</p>
<p>如何确保转账正确性，不会出现资金问题？</p>
<ol>
<li>在银行核心有控制，我方平台的账户每天只能入一次账，这是由银行核心提供的技术支持。意思就是说就算我们这里出现重复提交，都不会导致账入两次。</li>
<li>我方平台借助oracle序列，对程序进行加锁，防止重复入账的发生。（oracle序列是否原子性<a href="https://stackoverflow.com/questions/12104407/oracle-sequence-transactionality）" target="_blank" rel="noopener">https://stackoverflow.com/questions/12104407/oracle-sequence-transactionality）</a></li>
</ol>
<h2 id="聊聊SpringBoot项目"><a href="#聊聊SpringBoot项目" class="headerlink" title="聊聊SpringBoot项目"></a>聊聊SpringBoot项目</h2><h3 id="SpringBoot？"><a href="#SpringBoot？" class="headerlink" title="SpringBoot？"></a>SpringBoot？</h3><p>SpringBoot是基于Java的一种轻量级应用框架，可以说是Spring的一种扩展，可以快速的构建Java应用程序，比如JavaWeb应用</p>
<h3 id="Vue-1"><a href="#Vue-1" class="headerlink" title="Vue"></a>Vue</h3><p>Vue是基于JS的一种构建用户界面和单页面应用的MVVM框架，Model–view–viewmodel，相比Jquery，它将页面和数据分离的更透彻，在Jquery时代里我们常常要操作DOM结构，而Vue中我们可以使用Vue的模板语法操作虚拟DOM，将业务逻辑代码和<br>DOM操作代码分离，使得开发人员可以将重心偏向于业务逻辑</p>
<h3 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h3><p>服务端和客户端都会保存一段唯一的token，客户端登录成功后由后台生成并对称加密返回数字签名，客户端通过验签后解密数字签名，获取到token并保存至cookie中；随后所有的请求都会携带token，服务器每次都会验证token的有效性。从而保证了会话有效</p>
<h3 id="boot-js"><a href="#boot-js" class="headerlink" title="boot.js?"></a>boot.js?</h3><p>是我自定义的一个启动脚本，会存储一些常量到global对象(上下文环境变量)中，方便后续调用。</p>
<h3 id="VueRouter"><a href="#VueRouter" class="headerlink" title="VueRouter?"></a>VueRouter?</h3><p>单页面应用的路由控制器，负责根据不同url加载不同的页面内容</p>
<h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>一个状态变量的仓库，拥有Vue的内嵌支持，所以相比自己实现的状态变量仓库，使用Vuex存储的状态变量拥有双向绑定的特点</p>
<h3 id="iView"><a href="#iView" class="headerlink" title="iView"></a>iView</h3><p>一个基于Vue的UI框架，我利用它来快速构建出美观的Web界面</p>
<h3 id="vue-lazyload"><a href="#vue-lazyload" class="headerlink" title="vue-lazyload"></a>vue-lazyload</h3><p>一个图片懒加载的nodejs工具包，懒加载可以提高用户体验</p>
<h3 id="vuescoll"><a href="#vuescoll" class="headerlink" title="vuescoll"></a>vuescoll</h3><p>一个方便控制滚轮的nodejs工具包，我利用它来实现下拉自动刷新的功能</p>

        
  </div>

</article>

      
      


    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script src="https://he_jia_jun.gitee.io/zazalumonster.github.io//js/md5.min.js"></script>
    <div id="gitalk-container"></div>
    <script>
    if(location.pathname == '/'){
      //首页不需要评论系统
    }else{
      var gitalk = new Gitalk({
        clientID: '73a23fdac799d4edb132',
        clientSecret: '8200d919660d513fdd8629a7c45c13d7d13d9b6f',
        repo: 'zazaluMonster.github.io',
        owner: 'zazaluMonster',
        admin: 'zazaluMonster',
        id: md5(location.origin + "/" +location.pathname),
        distractionFreeMode: false,
        pagerDirection: 'first'
      });
      gitalk.render('gitalk-container');
    }
    </script>
    <!-- gitalk -->

<footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2021 zazalu
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">主页</a></li>
         
          <li><a href="/about/">我是谁</a></li>
         
          <li><a href="/archives/">随笔</a></li>
         
          <li><a href="/tags/">标签</a></li>
         
          <li><a href="/categories/">分类</a></li>
         
          <li><a href="/search/">搜索</a></li>
        
      </ul>
    </nav>
  </div>
  <!-- 不蒜子统计 -->
 <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <div>
    <span id="busuanzi_container_site_pv">
      本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
    <span id="busuanzi_container_site_uv">
      本站访客数<span id="busuanzi_value_site_uv"></span>人次
    </span>
  </div>
 
</footer>




    </div>
    <!-- styles -->
<!-- <link rel="stylesheet" href="https://he_jia_jun.gitee.io/zazalumonster.github.io/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="https://he_jia_jun.gitee.io/zazalumonster.github.io/lib/justified-gallery/css/justifiedGallery.min.css"> -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">
    <!-- jquery -->
<script src="https://he_jia_jun.gitee.io/zazalumonster.github.io/lib/jquery/jquery.min.js"></script>
<script src="https://he_jia_jun.gitee.io/zazalumonster.github.io/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="https://he_jia_jun.gitee.io/zazalumonster.github.io/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

    <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?15ccc3aa9c18bcd901435b78b3c09e78";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

<!-- Disqus Comments -->



    


    <!-- 药水制作师live2d -->
    <!-- 引入css -->
    <link rel="stylesheet" href="/live2d/css/font-awesome/css/font-awesome.min.css" />
    <link href="https://he_jia_jun.gitee.io/zazalumonster.github.io//live2d/css/waifu.css" rel="stylesheet" type="text/css" />
    <!-- html -->

    <div class="waifu-switch">Live2d</div>
    <div class="waifu">
      <div class="waifu-tips"></div>
      <canvas id="live2d" width="252" height="225" class="live2d"></canvas>
      <div class="waifu-tool">
        <i class="fa-times waifu-closed"></i>
      </div>
    </div>
    <!-- 引入js -->
    <script src="https://he_jia_jun.gitee.io/zazalumonster.github.io//live2d/live2d.js"></script>
    <script async src="https://he_jia_jun.gitee.io/zazalumonster.github.io//live2d/waifu-tips.js"></script>
    <script type="text/javascript">
      loadlive2d("live2d", "/live2d/Pio/model.json");
    </script>
    <!-- 药水制作师live2d插件结束 -->

    <!-- 引入视差滚动特效js -->
    <!-- <script src="/parallax/parallax.min.js"></script>
<script src="/parallax/parallaxController.js"></script> -->

    <!-- 不蒜子统计请见footer.ejs -->

  </body>

  </html>