---
title: 微服务设计读书笔记
tags:
---

# 什么是微服务
1. 微服务的出现是现实世界中孵化出来的一种模式, 其目的是为了更快的响应不可避免的需求变更, 为了一个更灵活和自治的软件架构而不是像原来的应用架构那样死板,难以改动.

2. 单一职责原则我认为的最好的概述: "把因相同原因而变化的东西聚合在一起, 把因不同原因而变化的东西分离开来"

微服务就是单一职责的很好体现, 根据业务需求界定不同的服务, 而不是像以前一样所有服务都融合在同一个项目中, 这样只会让我们的项目越写越大, 到最后进入到一种难以维护的窘境, 相似功能的代码随处可见, 一处改动难以界定会影响的范围, 一个小功能的实现会花费大量的时间去整理上下文逻辑, 难以下手.

不过我们如果尝试在一开始就构建一种以服务为单元的系统架构, 根据业务需求不断的生产不同的服务模块, 每个服务模块相互独立, 并通过网络通信方式进行互联, 这样我们在处理某个服务模块的时候, 由于代码模块相较于整体而言足够小, 所以对于开发人员来说需要警惕的地方少了, 可以有效的提升开发效率.

更抽象的, 现如今有太多的管理系统,OA系统,但是他们本身有很多相似的模块, 比如用户模块, 会话模块. 这些模块非常相似, 有点实力的技术人员应该可以完全将他们的核心部分抽象出来变成一种服务应用独立运行, 然后供给其他服务使用. 

就这样, 我们可以把一个很大的管理系统剥离成很多小部分, 每个小部分相互独立, 又可以相互重用, 代码量小所以容易掌控, 减轻了开发人员的开发压力, 可以更专注于开发出更高效的功能模块, 而不用去担心影响系统的其他部分

# 微服务的好处

## 技术异构性
有人说微服务的一个好处是"技术异构性". 因为不同服务之间都是采用网络进行通信的, 所以严格来讲不同服务之间我们可以使用不同的语言, 使用不同的技术架构去提供服务. 但是在我看来, 虽然微服务架构的内部, 不同的服务可以采用不同的技术, 但是现在我们用的微服务框架这个本身的技术框架就已经定死了, 并不能严格意义上来说达到了"技术异构性". 不过仔细想来, 我认为从来没有根本上的"技术异构性"可言, 不过对于不同的服务可以大胆的使用不同的技术去实现而言, 这确实是微服务给我们带来的好处, 因为微服务足够小, 也许我们只需要两周时间就可以使用不同的技术重写一个服务, 这点风险是可以承担的

## 弹性
一个系统的弹性, 这个说法其实很好理解. 比如说我们最传统的单一应用的系统, 如果系统某处出现致命问题, 会导致整个系统宕机. 而微服务由于将不同的服务分开部署,相互独立, 所以相对来说有更高的弹性. 这里我们就不谈微服务框架本身崩溃的可能性或者说机房宕机的可能性. 光从应用角度来看, 如果是微服务架构, 那么如果你的某个服务挂了, 也不影响系统的整体运行, 这就体现了一定的弹性

## 更有效的水平拓展
我不能一口否定我们现在常见的系统在拓展新功能上会比较困难, 毕竟很多系统本身的设计还是近乎合理的, 对于拓展是开放的. 比如某一天我们的产品经理想为电商系统新增一个在线听歌的功能, 那么只需对MVC三层中加入对应的功能代码, 就完成了拓展. 但是随之而来有了一个问题, 当我们的电商系统扛不住流量压力的时候, 我们就需要把系统整体进行水平拓展(简单来说就是多加机器多部署几套). 这个时候你会发现, 我们的在线听歌功能其实是不需要部署多套的, 因为它们的流量并不高. 流量不高却强行占用着昂贵的服务器资源,这是一种不合理的水平拓展, 浪费的一定的资源. 

所以如果我们的系统架构是微服务的, 那么我们只需要水平拓展其中需要拓展的部分即可, 这带来的好处就是减少了成本, 物尽其用

##　更有弹性的部署
参与过非微服务框架治理的系统项目的同学，一定有过和我一样的经历，那就是我修改一个功能，需要重启整个测试环境的系统，重启过程中所有的相关开发人员，测试人员的工作都会被强制中止！　(事实上，我目前所在的项目仍然有这种情况！　虽然在软件开发中这种情况几乎是无法避免的，但是减少频繁的重启整个服务是微服务框架给我们的福报)

有些公司领导非常抵制系统测试环境的经常重启，所以严格要求了每天重启测试环境的次数，比如每一小时一次．这个要求的出现会导致其他问题，写代码不够严谨或者不够警惕的开发人员每改一次就重启，但是每一小时才能部署一次给测试人员看效果，导致一天下来的测试进度十分缓慢

微服务从根本上解决了这个问题，我们前面也说了微服务的弹性特点，所以我们只需要重启一个服务而不是整个系统，这样负责不同模块的开发人员和测试人员可以不用停下来等待系统重启，提高了工作效率

同时微服务架构作为一个新技术，自然考虑了更自动化更高效的部署策略，所以使用微服务架构后，自动化部署也越来越不是什么罕见的东西了

# SOA 面向服务的架构
SOA理念和FP函数式编程的理念可以说就是一个东西， FP思想里的函数和SOA思想里的服务，实际上想表达的是一个概念，都有高内聚低耦合，单一职责的思想在里头。
现如今的微服务架构就是SOA的一种表现方式，SOA要做的好，需要界定好服务的边界，把模块分清楚。如果一个系统你对它不熟悉，强行拆分成微服务去做，那么很有可能你会把他们拆分的比较模糊，最终导致服务与服务之间仍然存在很高的耦合

# 如何界定出一个完整的服务
本来一个冗杂在一起的系统， 如何将其拆分成一个个服务，这需要你对系统有一个清晰的认识。
就算是经验老道的微服务架构从业者，给您的建议应该也只有两个：
1. 想办法框定每个服务的限定上下文， 限定上下文你可以理解为是一种细胞膜，规定好了什么东西在细胞里面，什么东西在细胞外面，只有哪些东西可以进出细胞膜
2. 一个服务对外提供的API，比如一个仓库系统对外提供库存信息，这个信息不应该和库存系统内部的信息是一致的。 所有对外能够输出出去的信息都应该有一种专门的对外表达方式

# 微服务应该如何更好的集成

集成的意思就是让服务可以互联，使他们既是整体，又是互不相关的独立个体。所以微服务在通信技术上有很多种选择。但是不管怎么样，我们需要记住下面几点

1. 一个服务的API修改不应该影响到下游或者说影响到消费者(消费这个API的服务)，比如说一个客户信息修改API，当客户信息服务对其改动了API，添加了新字段，那么其他调用这个API的服务，可以继续使用这个API不会报错

2. 保证通信方式和技术无关，其实我认为就是通信方式一定要选一个大众的，比如选择HTTP，这就是一个非常大众的通信方式，任何技术栈都对其有相应的支持库。当我们保证了通信方式与技术栈无关后，我们以后就可以随性所欲的使用新的技术栈去实现各种各样的服务，而不用担心这样一来无法继续与别的服务互联的问题

3. 尽可能的让你的API接口让消费者很简单的就可以使用，而不是让它变得很复杂

4. 不共享数据库，共享数据库在短时间看来是非常高效的一种操作，但是这样一来，消费者一方就需要对你的数据进行负责并小心翼翼的使用，时间一久，每次改动就会需要大量的回归测试来确保不出问题

5. 使用同步还是异步通信？各有各的好处，根据情况来选择最好的

6. 使用编排或者协同来集成各类服务
编排就是编制好一个功能的所有执行顺序，然后系统按照既定的流程一个个执行。比如创建一个新客户，就会先进行注册，然后发送短信，最后确认这一连串。 编排用同步和异步都能实现，它是一种请求/响应的通信方式。

协同是一种基于事件(生产者消费者)的流程模型， 比如创建一个新客户是一个事件， 当这个事件发生的时候，所有监听这个事件的其他服务，比如发送短信，确认短信等等都会自动开始执行。 协同的方式会让服务之间的耦合更低， 因为协同的方式下，最先发起创建客户的人不需要关心短信成不成功的问题，而相对的使用编排是需要知道的。 使用协同需要一个额外的监控系统来监控所有服务的执行状态，需要额外的开销。

# 针对请求/响应的通信方式推荐的有：RPC和REST

